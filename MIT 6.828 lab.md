# MIT 6.828

key： N91HXNNJ38GHGSYCUZNU2Z5GYDS87K4O

OS方向下一阶段学习任务：
MIT6.828lab：https://pdos.csail.mit.edu/6.828/2018/
推荐jyy的os的视频课程：https://space.bilibili.com/202224425
以及视频相配套的讲义：https://jyywiki.cn/OS/2023/
注意：视频课程和6.828没有关系，仅作为学习；
另外，后续我们会在每周开一次分享会，根据大家的学习记录，挑选一位同学去讲解当周的进度以及实现的思路，为了保证大家都能听懂，所以我们选择进度最慢的同学讲，如果内容不够充实（比如没有完成任何exercise），这时候，分享的内容可以是源码导读，选择一些框架源码进行解析（逐行or每个函数的功能）
下面是给大家的建议:一定要多动手做，不要只是看视频，避免一次性看完所有视频才去写代码

回顾学过的操作系统，感觉最难的其实还是繁杂的东西（源码和原理）。

1. 每一个功能调的变量含义是什么？函数的作用是什么？你需要的工具（函数，宏）在哪里？
2. 最基础的那些结构的理解，比如页表的结构，文件系统的构成，这些都是你写相关代码时需要的，不然就不知道如何调用和存放数据。
3. 最后回顾那些代码逻辑实际上你叫一个初中生来我感觉也行。所以啊，学系统相关的东西说到底其实就是根据原理和源码去了解框架，大量的代码以及许多的结构是难点，后续其实蛮简单的。

# 1. Tread on the pit

## Homework怎么做？

你会好奇这东西也要学习？等你写的绝望的时候可能会后悔自己没有看见这东西，如果你已经做到以下要求了，那我只能羡慕你是真的高瞻远瞩啊。

做过了两个Homework以后，明显注意到了，`shell`和`system call`在后续会进行讲解，这个板块给我的感觉是预习性质的，在鼓捣完`system call`才算理解了这一点，学到这一块推荐去看课表上的相关教程，然后再回来做，不然你可能网上的相关文档为什么这么写都看不懂，真的，看不懂为什么要这么做。

## github

**steam++端口的问题解决**

```
https://blog.csdn.net/wenzuowei110/article/details/7871971
```

**证书问题：Certificate verification failed**

```
https://blog.csdn.net/qq_41035283/article/details/124058657
```

**还是不行，要什么账号，密码。跑github下载源码算了**

```
https://github.com/mit-pdos/xv6-public
```

## 耦合？

原意：能量从一种介质传播到另一种介质的过程。

例如放大器级与级之间信号的逐级放大量是通过阻容耦合或变压器耦合、两个线圈之间的互感是通过磁场的耦合。

大多数情况下，形容关联关系非常密切，一个变化后其他的受到的影响非常的大。

## 共享文件夹

 `/mnt/hgfs`

有时候代码真不知道哪里有问题就这招，写好的简单粗暴的缩减范围。注意对方的lab版本，不然会白用功好几天。



# 2. Tools

一般gcc默认有编译工具链的，所以往往不需要下载。如果下面两条指令可以正确执行就代表不需要下载。

```
% objdump -i
```

```
% gcc -m32 -print-libgcc-file-name
```

如果无法执行请下载一些软件包。版本找较新的就行。

```
m4 gmp mpfr mpc binutils gcc gdb。
```

后续就是下载QEMU 仿真器。具体流程可以参考这里的步骤就行

```
https://blog.csdn.net/Alagagaga/article/details/109735168
```

**遇见的bug**

- ERROR: Python not found. Use --python=/path/to/python

  解决方法：

  ```
  apt-get install python
  ```

- 编译工具链安装时，出现头文件找不见之类的问题

  解决方法：

  这里通常是因为它们是依赖文件，要按顺序安装具体查看下面的网站

  ```
  https://blog.51cto.com/ohyeahbbs/568462
  ```

**什么是qemu**

QEMU是一个开源的虚拟机和仿真器，可以模拟多种CPU架构和硬件平台。它可以在不同的操作系统之间运行虚拟机。

使用QEMU仿真机可以加速开发过程，因为它可以在开发人员的主机上模拟目标硬件平台，而无需实际的硬件设备。

**然后找到代码？**

在根目录输入

```
grep -r "user_yield"
```

就可以查找目录下的包含`user_yield`的文件

更加具体的`grep`使用

```
https://www.runoob.com/linux/linux-comm-grep.html#:~:text=Linux%20grep%20%E5%91%BD%E4%BB%A4%201%20-i%20%EF%BC%9A%E5%BF%BD%E7%95%A5%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BF%9B%E8%A1%8C%E5%8C%B9%E9%85%8D%E3%80%82%202%20-v,-r%20%EF%BC%9A%E9%80%92%E5%BD%92%E6%9F%A5%E6%89%BE%E5%AD%90%E7%9B%AE%E5%BD%95%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E3%80%82%205%20-l%20%EF%BC%9A%E5%8F%AA%E6%89%93%E5%8D%B0%E5%8C%B9%E9%85%8D%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D%E3%80%82%206%20-c%20%EF%BC%9A%E5%8F%AA%E6%89%93%E5%8D%B0%E5%8C%B9%E9%85%8D%E7%9A%84%E8%A1%8C%E6%95%B0%E3%80%82
```

这么长？？？





# 3. xv6 printout

**xv 6涉及的源码**

<img src="https://cdn.staticaly.com/gh/ri-umk/picx-images-hosting@master/MIT-6-828/屏幕截图-2023-06-10-163450.2cnrtpob070g.webp" alt="屏幕截图-2023-06-10-163450" />







# 4. lab

## lab guide

### JOS 制作文件

- make qemu

  构建所有内容，并在新的 VGA 控制台中使用 QEMU 启动 QEMU。 窗口和终端中的串行控制台。要退出，请执行以下任一操作 关闭 VGA 窗口或在终端中按 `Ctrl-c` 或 `Ctrl-a x`。

- make qemu-nox

  就像`制作 qemu`，但只使用串行控制台运行。 要退出，请按 `Ctrl-a x`。这在与雅典娜拨号的 SSH 连接，因为 VGA 窗口消耗很多带宽。

- make qemu-gdb

  喜欢做`qemu`，而不是被动接受GDB 随时连接，这会在第一台机器上暂停指令并等待 GDB 连接。

- make qemu-nox-gdb

  `qemu-nox` 和 `qemu-gdb` 目标的组合。

- make run-*name*

  （实验 3+）运行用户程序*名称*。例如，`使 run-hello` run `user/hello.c.`

- make run-*name*-nox, , ,run-*name*-gdbrun-*name*-gdb-nox

  （实验 3+）对应于`` `QEMU`目标的变体。

生成文件还接受一些有用的变量：

- make V=1 ...

  详细模式。打印出正在执行的每个命令，包括 参数。

- make V=1 grade

  任何失败的等级测试后停止，并将QEMU输出留在`jos.out`中进行检查。

- make QEMUEXTRA='*args*' ...

  指定要传递给 QEMU 的其他参数。

### **JOS obj/**

在构建 JOS 时，makefile 还会生成一些额外的输出在调试时可能有用的文件：

- `obj/boot/boot.asm`， obj/`kern/kernel.asm， obj`/`user/hello.asm`， etc.

  引导加载程序、内核和用户的程序集代码清单 程序。

- `obj/kern/kernel.sym`， `obj/user/hello.sym`， etc.

  内核和用户程序的符号表。

- `obj/boot/boot.out`， `obj/kern/kernel`， `obj/user/hello`， etc

  内核和用户程序的链接 ELF 映像。这些 包含 GDB 可以使用的符号信息。

### **GDB**

查看[GDB GDB](http://sourceware.org/gdb/current/onlinedocs/gdb/) 命令完整指南的手册。这里有一些 对于 6.828 特别有用的命令，其中一些通常不会 出现在操作系统开发之外。

- Ctrl-c

  停止机器并在当前闯入 GDB 指令。如果 QEMU 有多个虚拟 CPU，则会停止所有 他们。

- c（或continue)

  继续执行，直到下一个断点或 `Ctrl-c`。

- si（或stepi)

  执行一条机器指令。

- b function或（或b file:linebreakpoint)

  在给定函数或行处设置断点。

- b **addr*（或breakpoint)

  在弹性公网IP*地址*设置断点。

- set print pretty

  启用数组和结构的漂亮打印。

- info registers

  打印通用寄存器、`eip`、`eflags`和段选择器。对于更多 彻底转储机器寄存器状态，请参阅 QEMU 自己的`信息 注册`命令。

- x/*N*x *addr*

  显示从虚拟地址*地址*开始的 *N* 个单词的十六进制转储。如果省略 *N*，则默认为 1。*addr* 可以是任何表达式。

- x/*N*i *addr*

  显示从 *addr* 开始的 *N* 条程序集指令。使用 `$eip` 作为*地址*将显示 当前指令指针上的指令。

- symbol-file *file*

  （实验 3+）切换到符号文件*文件*。当 GDB 附加时 对于QEMU，它没有流程边界的概念 虚拟机，所以我们必须告诉它使用哪些符号。由 默认情况下，我们将 GDB 配置为使用内核符号文件 `obj/kern/kernel`。如果机器正在运行用户代码，请说 `hello.c`，您可以使用 `symbol-file obj/user/`hello 切换到 hello 符号文件。

QEMU 将每个虚拟 CPU 表示为 GDB 中的一个线程，因此您可以使用 所有与 GDB 线程相关的命令，用于查看或操作 QEMU 的 虚拟中央处理器。

- thread *n*

  GDB 一次专注于一个线程（即 CPU）。此命令 将焦点切换到线程 *n*，从零开始编号。

- info threads

  列出所有线程（即 CPU），包括其状态（活动或 停止）以及它们处于什么功能。

### QEMU

QEMU 包括一个内置监视器，可以检查和修改 以有用的方式显示计算机状态。要进入显示器，请按运行 QEMU 的终端。再次按 以切换回串行控制台。Ctrl-a cCtrl-a c

有关监视器命令的完整参考，请参阅 [QEMU 手动](http://wiki.qemu.org/download/qemu-doc.html#pcsys_005fmonitor)。以下是一些特别有用的命令：

- `xp/Nx paddr`

  显示从物理地址 *paddr* 开始的 *N* 个单词的十六进制转储。如果省略 *N*，则默认为 1。 这是 GDB 的 `x` 命令的物理内存模拟。

- info registers

  显示计算机内部寄存器状态的完整转储。 特别是，这包括机器的*隐藏*部分 段选择器以及本地、全局和中断的状态 描述符表，以及任务寄存器。这种隐藏状态是 虚拟 CPU 在分段时从 GDT/LDT 读取的信息 选择器已加载。这是在 JOS 内核中运行时的 CS 在实验 1 中，每个字段的含义：

  ```
  CS =0008 10000000 ffffffff 10cf9a00 DPL=0 CS32 [-R-]
  ```

  `CS =0008`

  代码选择器的可见部分。我们正在使用细分 0x8. 这也告诉我们我们指的是全局描述符 表 （0x8&4=0），我们的 CPL（当前权限级别）为 0x8&3=0。

  `10000000`

  此段的基础。线性地址 = 逻辑地址 + 0x10000000。

  `fffffffff`

  此段的限制。0xffffffff上方的线性地址 将导致分段冲突异常。

  `10CF9a00`

  QEMU 帮助解码的该段的原始标志 对于我们接下来的几个领域。

  `DPL=0`

  此分段的权限级别。仅运行的代码 权限级别 0 可以加载此分段。

  `CS32`

  这是一个 32 位代码段。其他值包括数据段的 DS（不要与 `DS` 混淆） 寄存器），以及本地描述符表的 `LDT`。

  `[-R-]`

  此段是只读的。

## lab 1

**启动PC**

### 第 1 部分：PC 引导程序

#### x86 程序集入门

x86 汇编语言，NASM 使用所谓的英特尔语法而GNU使用AT&T语法。虽然在语义上等效，程序集文件至少会有很大差异表面上，取决于使用的语法。两者之间的转换非常简单，**[Brennan的内联装配指南](http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html)**中有介绍。

##### 练习1

阅读语法 [Brennan's Guide to Inline Assembly](http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html) 。了解  JOS 中的 GNU 汇编器中使用语法。

#### 模拟 x86

**退出qemu**

make qemu make qemu-nox Ctrl+a x

**监视内核的两个命令**

help：用来显示命令列表的命令

kerninfo：用于显示系统内核信息的命令

#### 电脑的物理地址空间

 电脑的物理地址空间常规布局：

```
+------------------+  <- 0xFFFFFFFF (4GB) 
|      32-bit      |
|  memory mapped   |
|     devices      |
|                  |
/\/\/\/\/\/\/\/\/\/\
/\/\/\/\/\/\/\/\/\/\
|                  |
|      Unused      |
|                  |
+------------------+  <- depends on amount of RAM
|                  |
|                  |
| Extended Memory  |
|                  |
|                  |
+------------------+  <- 0x00100000 (1MB) 
|     BIOS ROM     |
+------------------+  <- 0x000F0000 (960KB)
|  16-bit devices, |
|  expansion ROMs  |
+------------------+  <- 0x000C0000 (768KB)
|   VGA Display    |
+------------------+  <- 0x000A0000 (640KB)
|                  |
|    Low Memory    |
|                  | 
+------------------+  <- 0x00000000
```

通常我们将包含**MBR(主引导记录)引导代码**的扇区称为**主引导扇区**。通常由3部分组成：

- **主引导程序**（MBR，占446字节)
- **磁盘分区表项**（占4×16个字节，负责说明磁盘上的分区情况）
- **结束标志位**（占2个字节，其值为55 AA) 。

##### Low Memory

在物理地址空间中，有一部分被保留用于操作系统和硬件设备使用，这部分被称为低端内存（low memory）。

低端内存通常包括从地址0开始的一段连续的物理内存地址，其大小取决于计算机系统的架构和硬件配置。在x86架构的计算机系统中，低端内存通常是从地址0开始的640KB内存空间，这部分内存被称为传统内存（conventional memory）。

现代pc在物理内存0x000A0000到0x00100000之间有一个“洞”，将RAM分为“低端”或“传统内存”(前640KB)和“扩展内存”(其他所有内容)。此外，在PC的32位物理地址空间最顶端的一些空间，尤其是物理内存，现在通常由BIOS分配给32位PCI设备使用。

低端内存是操作系统和硬件设备必须使用的关键内存区域之一。

##### VGA Display

显示器接口

现在接口排名：

DP > HDMI > DVI > VGA

其他接口：

Type-C 接口，它其实使用的是 DP 标准的信号传输，优点是通过一根线解决了显示器的画面传输和供电。

USB 接口，最新的 USB3.0 接口，通过上行 USB 接口和电脑主机连接，用户可以通过显示器的下行 USB 接口与电脑主机连接。

接口转换：

VGA 和 DVI 互转，属于模拟信号和数字信号的转换，视频信号会有损失，造成失真。
DVI 和 HDMI 互转，属于数字信号之间的转换，但是从 HDMI 转换 DVI 时会自动舍去音频信号。

在早期的个人电脑中，640KB~768KB的物理内存地址空间通常被用作显存（Video RAM，VRAM），用于存储图形显示所需的图像数据和显示缓冲区。这个地址空间被称为VGA显示内存，因为它通常被用于支持VGA（Video Graphics Array）标准的图形显示。

在640KB~768KB的VGA显示内存中，通常包括了显存、显示缓冲区和其他显卡相关的寄存器和数据结构。这些寄存器和数据结构被用于控制显卡的工作模式、分辨率、颜色深度等参数，以及在屏幕上绘制图形和文本。

##### 16-bit devices, expansion ROMs

16位设备是**具有16位内部数据总线宽度的计算机设备。**这包括早期的个人电脑和游戏机，它们通常具有较低的计算能力和存储容量，但仍然可以执行基本的计算和图形操作。

扩展ROM是用来扩展计算机系统功能的固件。它们通常存储在设备内 ROM  芯片中，可以包含驱动程序、固件升级或其他扩展功能的代码。这允许用户扩展设备的功能，而无需更换硬件。

扩展rom已经被扩展设备功能的其他方法所取代，如软件驱动程序和固件更新。

**ROM**

ROM（Read-Only Memory）是一种只读存储器，其中存储的数据只能被读取，而不能被修改。

在计算机系统中，ROM通常用于存储一些基本的系统信息和程序，例如BIOS程序、操作系统引导程序、固件程序等。这些程序需要在计算机启动时被读取和执行，因此它们需要被存储在一种可靠且不易被修改的存储介质中，以确保系统的稳定性和安全性。

##### BIOS ROM

吐槽：从硬件角度看待启动

BIOS (Basic Input Output System : 基本输入输出系统)，实际上就是被"固化"在计算机硬件中、直接与硬件打交道的一组**程序**（内含三个主要程序模块），它为计算机提供最低级、最直接的硬件控制。

BIOS程序一般被存放在主板ROM(只读存储芯片)之中，即使在关机或掉电以后，该程序也不会丢失。

计算机的很多硬件中都有BIOS程序，最常见的比如：主板(也称为**系统BIOS**)、显示卡以及其它一些设备(例如IDE控制器、SCSI卡或网卡等)中都存在有BIOS程序；但是，计算机的启动过程是在系统BIOS的控制下进行的。

在计算机启动时，BIOS程序会被读取并执行，它会进行一系列硬件自检和初始化操作，包括检测内存、硬盘、光驱等硬件设备，并将它们初始化为可用状态。此外，BIOS程序还会从硬盘或其他存储介质中读取操作系统引导程序，并将控制权转交给操作系统。

除了硬件初始化和系统自检功能之外，BIOS程序还提供了一些基本的输入输出功能，例如键盘输入、屏幕输出等。在一些特定的应用场景下，BIOS程序还可以被用来进行一些系统设置和配置，例如修改系统时间、设置启动顺序等。

BIOS程序已经逐渐被UEFI（Unified Extensible Firmware Interface）取代。BIOS是16位汇编语言程序，只能运行在16位实模式，可访问的内存只有1MB，而UEFI是32位或64位高级语言程序（C语言程序），突破实模式限制，可以达到要求的最大寻址。

*BIOS自检*

第一步：CPU RESET

第二步：POST(自检程序)启动

第三步：执行显示卡的BIOS（初始化）

第四步：执行其它控制卡的BIOS（初始化）

第五步：检测CPU与内存

第六步：检测标准的系统硬件与即插即用设备

第七步：显示硬件配置列表信息

第八步：更新ESCD

*CPU RESET*

电源通电以后，提供一系列电路，向主板上各个元器件供电；向时钟控制信号发出信息，时钟芯片控制内存，CPU，AGP，I/O设备等时钟频率产生；向CPU发出CPU复位信号，CPU初始化，CPU复位完成，即CPU内的各寄存器（通用寄存器、段寄存器、标志寄存器等）均复位以后，发出寻址选中BIOS程序，CPU马上就从地址FFFF0H处开始执行指令，这个地址在系统BIOS的地址范围内，无论是AWARD BIOS还是AMI BIOS，放在这里的只是一条跳转指令，跳到系统BIOS中真正的启动代码处。这就是8引脚PG信号转化成复位信号的全过程。

*POST(自检程序)启动*

系统BIOS的启动代码处第一个例程是**POST程序**，它主要任务是检测系统中的一些关键设备是否存在和能否正常工作，如内存和显卡等。由于POST的检测过程在显示卡初始化之前，因此如果在POST自检的过程中发现了一些致命错误，如没有找到内存或者内存有问题时(POST过程只检查640K常规内存)，是无法在屏幕上显示出来的，这时系统PIOS可通过喇叭发声来报告错误情况，声音的长短和次数代表了错误的类型。

*调用显示卡的BIOS（初始化）*

接下来系统BIOS将查找显示卡的BIOS程序，存放显示卡BIOS程序的ROM芯片的起始地址通常在C0000H处，系统BIOS找到显卡BIOS之后调用它的初始化代码，由显卡BIOS程序来完成显示卡的初始化。这就是我们开机看到的第一个画面，显示器屏幕顶端会出现显卡BIOS的版本信息、显卡类型、显存容量等信息，不过这个画面几乎是一闪而过的。

*调用其它控制卡的BIOS（初始化）*

接着系统BIOS会查找其它设备的BIOS程序，按照CMOS RAM中存储的配置信息或主板上配置信息（如CPU的外频和倍频信息、内存数量等）去找相关设备，找到之后同样要调用这些BIOS内部的初始化代码来初始化这些设备。

查找完所有其它设备的BIOS之后，系统BIOS将显示它自己的启动画面，其中包括有系统BIOS的类型、序列号和版本号等内容。同时屏幕底端左下角会出现主板信息代码，包含BIOS的日期、主板芯片组型号、主板的识别编码及厂商代码等；**此时可以按“Del”键进入CMOS设置画面重新设置相关配置信息。**

*检测CPU与内存*

接着系统BIOS将检测CPU的类型和工作频率，并将检测结果显示在屏幕上，这就是我们开机看到的CPU类型和主频。接下来系统BIOS开始测试主机所有的内存容量，并同时在屏幕上显示内存测试的数值，就是大家所熟悉的屏幕上半部份那个飞速翻滚的内存计数器。这个过程我们可以在BIOS设置中选择耗时少的"快速检测"或者耗时多的"全面检测"两种方式；比如，在CMOS中将“Quick Power On Test”设置为“Disabled”,则将检测三次。

*检测标准的系统硬件与即插即用设备*

内存测试通过之后，系统BIOS将开始检测系统中安装的一些标准硬件设备，这些设备包括：硬盘、CD-ROM、软驱、串行接口和并行接口等连接的设备。此时硬盘电源指示灯闪亮，键盘的三个指示灯（Num Lock、Caps Lock、Scroll Lock）再次地一起闪亮。

标准的系统硬件检测完毕后，系统BIOS（内部的支持即插即用的代码）将开始检测和配置系统中安装在PCI扩展槽上（或ISA等）即插即用设备（如显示卡、声卡、视频卡、Modem等和串口、并口等I/O设备）。

每找到一个设备之后，系统BIOS都会在屏幕上显示出设备的名称和型号等信息，同时为该设备分配中断、DMA通道和I/O端口等资源。

*显示硬件配置列表信息*

到这一步为止，所有硬件都已经检测配置完毕了，系统BIOS会重新清屏并在屏幕上方显示出一个系统配置列表，其中概略地列出了系统中安装的各种标准硬件设备，以及它们使用的资源和一些相关工作参数。

*更新ESCD*

ESCD（扩展系统配置数据）是系统BIOS用来与操作系统交换硬件配置信息的数据，这些数据被存放在CMOS(一小块特殊的RAM，由主板上的电池来供电)之中。通常ESCD数据只在系统硬件配置发生改变后才会进行更新，所以不是每次启动机器时我们都能够看到"Update ESCD... Success"这样的信息。

**所有硬件检查完毕，系统BIOS的启动代码将进行它的最后一项工作，根据CMOS中所设置的引导顺序，加载MBR引导记录，为引导操作系统做准备。这就是进入引导扇区前的所有步骤**

*开机的寻访地址（8086）*

在Intel还在使用16位CPU时，8086,8088，地址空间为1M时，第一条指令的地址就是0xFFFF0。

##### Extended Memory

在计算机系统中，Extended Memory（扩展内存）是指超过1MB的内存空间。在早期的PC系统中，由于Intel 8086/8088处理器的寻址能力限制，只能寻址1MB的内存空间，因此超过1MB的内存空间无法被直接访问。为了解决这个问题，Intel推出了80386处理器，它支持32位寻址能力，可以访问4GB的内存空间，其中超过1MB的部分被称为Extended Memory。

##### (BIOS) 控制信息区

BIOS控制信息区是BIOS ROM中的一个特殊区域，它包含了一些重要的系统配置信息和控制参数，用于初始化计算机系统和启动操作系统。

BIOS控制信息区通常包括以下内容：

1. CMOS（Complementary Metal-Oxide-Semiconductor）RAM：这是一块小型的非易失性内存，用于存储系统的基本配置信息，如日期、时间、启动顺序、硬件设置等。
2. ACPI（Advanced Configuration and Power Interface）：这是一种用于管理电源和系统资源的标准接口，它可以帮助操作系统更好地管理系统资源和节能。
3. PCI（Peripheral Component Interconnect）配置空间：这是一种用于管理系统总线和外部设备的标准接口，BIOS控制信息区可以存储PCI设备的配置信息和驱动程序。
4. SMBIOS（System Management BIOS）：这是一种用于描述系统硬件和软件配置的标准接口，它可以帮助操作系统更好地了解系统硬件和软件配置。

BIOS控制信息区对于计算机系统的正常运行非常重要，它可以帮助操作系统更好地管理系统资源和硬件设备，并提高系统的稳定性和性能。

##### 闲话

**为什么有仍然保留1MB终止？**

PC架构师仍然保留了低1MB物理地址空间的原始布局，以确保与现有软件的向后兼容。

##### QEMU的调试工具

使用QEMU的调试工具来研究IA-32兼容计算机是如何启动的。

### 第 2 部分：引导加载程序

#### 引导加载程序

**在[PC汇编语言](https://pdos.csail.mit.edu/6.828/2018/readings/pcasm-book.pdf)的1.2.7部分：16位保护模式**

对于 6.828， 引导加载程序必须能够装入的512字节，因为使用传统的硬盘驱动器启动机制。引导加载程序由一个汇编语言源文件boot.s 和 main.c 组成。请仔细阅读这些源文件，确保你理解了所发生的事情。启动加载程序必须执行两个主要功能：

1. **在保护模式下，将分段地址(段:偏移量对)转换为物理地址的方式是不同的，转换后的偏移量是32位而不是16位。**
2. **引导加载程序通过x86的特殊I/O指令直接访问IDE磁盘设备寄存器，从硬盘读取内核。**如果您想更好地理解这里的特定I/O指令的含义，请查看 [6.828 参考页面上](https://pdos.csail.mit.edu/6.828/2018/reference.html)的“IDE硬盘驱动器控制器”部分。

**16 位保护模式**

在80286的16位保护模式下，选择器值的解释与实际模式下完全不同。**在实模式下，选择器的值是物理内存的段数。在保护模式下，选择器值是描述符表的索引。**在这两种模式下，程序都分为多个部分。在实模式下，这些段位于物理内存中的固定位置，选择器值表示段开始处的段号。在保护模式下，这些段不在物理内存中的固定位置，它们根本不必在内存中。

**保护模式使用一种称为虚拟内存的技术。**虚拟内存系统的基本思想是只将程序当前使用的数据和代码保存在内存中。其他数据和代码暂时存储在磁盘上，直到再次需要时再使用。在16位保护模式下，段会根据需要在内存和磁盘之间移动。当一个段从磁盘返回到内存时，它很可能会被放置到与移动到磁盘之前不同的内存区域中。所有这些都是由操作系统透明完成的。要使虚拟内存工作，程序不必编写不同的代码。

在保护模式下，每个段在描述符表中分配一个表项。这个条目包含了系统需要知道的关于该段的所有信息。这些信息包括:当前是否在内存中;如果在记忆里，它在哪里;访问权限(例如，只读)。段项的索引是存储在段寄存器中的选择器值。

16位保护模式的一个大缺点是偏移量仍然是16位的量。因此，段的长度仍然被限制在最多64K。这使得使用大型数组成为问题。

**选择器**

**在实模式下，选择器（Selector）是一种用于访问内存的机制。**选择器是由16位的段寄存器和16位的偏移地址组成的，其中段寄存器存储段的**起始地址**，偏移地址存储相对于段起始地址的**偏移量**。选择器可以用于访问内存中的任意位置，包括代码、数据和堆栈。

在实模式下，CPU使用段寄存器和偏移地址来计算物理地址，然后直接访问物理地址。这种方式的缺点是，段寄存器和偏移地址的组合有很多，需要占用大量的内存空间来存储。此外，由于选择器没有提供任何保护机制，程序可以随意访问内存，容易出现内存泄漏和崩溃等问题。

为了解决这些问题，后来的x86处理器引入了保护模式。**在保护模式下，选择器被替换为描述符（Descriptor）**，描述符包含了段的起始地址、段的长度、访问权限等信息，可以提供更加灵活和安全的内存管理机制。

**实模式，选择器的值是物理内存的段数**

在实模式下，选择器的值并不是物理内存的段数，而是段在内存中的起始地址右移4位后的结果。这个值被称为段地址，它指向的是内存中的一个64KB的段。实模式下，物理内存被划分成多个64KB的段，每个段都有一个段地址，通过选择器可以找到对应的段地址，从而访问对应的内存段。

**在保护模式下，选择器值是描述符表的索引。**

在保护模式下，选择器的值被用作描述符表的索引，描述符表中存储了各种段描述符和门描述符的信息，包括段的起始地址、大小、访问权限等信息。通过选择器的值，可以在描述符表中找到对应的段描述符或门描述符，从而访问对应的内存段或执行对应的门操作。因此，在保护模式下，选择器的值代表描述符表中的索引值。

**1.2.8部分： 32位保护模式**

80386引入了32位保护模式。386 32位和286 16位保护模式之间有两个主要的差异区别:

1. 偏移量被扩展为32位。这允许偏移量向上变化到40亿。因此，段的大小可以达到4g。
2. 段可以划分为更小的4k大小的单位，称为页。虚拟内存系统现在处理页，而不是段。这意味着在任何时候，只有一部分可能在内存中。在286 16位模式下，要么整个段都在内存中，要么一个都没有。32位模式允许较大的段，这是不实际的。

##### 练习 2

```assembly
# 了解ROM BIOS 
```

##### 练习 3

```assembly
# 收获：标识符会转换成物理地址。
# 阅读boot.s, main.c的源码
```

#### 4个问题

- 处理器在什么时候开始执行 32 位代码？ 究竟是什么原因导致从 16 位模式切换到 32 位模式？

```assembly
ljmp    $PROT_MODE_CSEG, $protcseg
```

处理器开始执行32位代码是在进入保护模式时。

切换到32位模式的原因是为了支持更多的内存和更高的性能。

- 执行的引导加载程序的最后一个指令是什么？ 它刚刚加载的内核的第一条指令是什么？

```assembly
gdtdesc:
  .word   0x17                   # sizeof(gdt) - 1
  .long   gdt                    # address gdt
  
lgdt    gdtdesc
```

**引导加载程序的最后一个指令通常是跳转指令，用于将控制权转移到操作系统内核的入口点。**具体来说，它会将处理器的指令指针（IP）设置为操作系统内核的入口点地址，将代码段选择器（CS）设置为操作系统内核的代码段选择器，然后执行跳转指令。这个跳转指令的具体指令码取决于处理器的架构和操作系统内核的编译方式，但通常是类似于"jmp 0x100000"这样的形式。

**一般情况下，内核的第一条指令是用来初始化系统和进行一些必要的设置。**这可能包括设置中断向量表、初始化内存管理、建立虚拟内存映射等。

- 内核的第一条指令在哪里？

```assembly
.code16
```

在x86架构的计算机中，内核的第一条指令通常存储在BIOS中断向量表中的地址0x7C00处。在计算机启动时，BIOS会将控制权转移给0x7C00地址处的代码，这段代码通常是**一个简单的引导加载程序（bootloader）**，它的主要任务是加载操作系统内核到内存中并执行。内核的第一条指令会在引导加载程序将内核加载到内存中后执行。**在Linux操作系统中，内核的第一条指令通常是在start_kernel函数中执行的。**

在start_kernel函数中，内核会进行一系列的初始化操作，包括初始化内存管理、进程调度、文件系统、网络协议栈等子系统。

- 引导加载程序如何决定它必须读取多少个扇区为了从磁盘获取整个内核？ 它在哪里可以找到此信息？

**在 elf 头文件的 Program Header Table 中存放有。内核载入内存执行时，是以段为组织的，每个段对应 elf 文件中 Program Header Table 中的一个条目，故可以依据 Program Header Table 来确定需要读取多少扇区来获取整个内核。[ELF文件解析（一）：Segment和Section](https://www.cnblogs.com/jiqingwu/p/elf_format_research_01.html)**

```c
while (pa < end_pa) {
```

在Linux系统中，GRUB引导加载程序通常会读取整个**内核文件**（通常是vmlinuz或bzImage文件），以及一个用于初始化根文件系统的**RAM磁盘映像文件**（通常是initrd.img或initramfs.img文件）。GRUB会读取这些文件的大小，并根据磁盘扇区的大小（通常是512字节）来计算需要读取的扇区数。具体来说，GRUB会将内核文件和RAM磁盘映像文件的大小相加，然后将结果除以扇区大小并向上取整，得到需要读取的扇区数。

**GDTR寄存器**

**GDTR寄存器是x86架构中的一个控制寄存器，用于存储全局描述符表（Global Descriptor Table，简称GDT）的地址和大小。**在保护模式下，GDT是一个用于存储段描述符的表格，其中每个段描述符定义了一个内存段的基地址、大小和访问权限等信息。当处理器需要访问内存时，会根据段描述符的信息对内存地址进行访问权限检查和地址转换。GDTR寄存器的值由lgdt指令加载，它包含一个48位的基地址和一个16位的表格大小，其中基地址指向GDT的起始地址，表格大小指示GDT表格的大小。GDTR寄存器的值在系统启动时被初始化，一般由操作系统内核负责初始化。

**引导扇区的组成**

在硬盘中，硬盘的0柱面0磁头第一个1扇区称为主引导扇区，也叫主引导记录-MBR(main boot record)，其中MBR是以下三个部分组成

1. Bootloader，主引导程序（446个字节）
2. Dpt（Disk Partition table），硬盘分区表（64个字节）
3. 扇区结尾标志（55aa）（2个字节）

总共512字节，前446个字节是主引导记录，是bios加电自检后要运行的代码，中间64字节为分区表。

简单的来说MBR=bootloader+dpt(64)+结尾标志(55aa)。其中dpt磁盘分区表(64字节，每16个字节为一组，一共4组)

**vmlinuz、initrd.img的作用**

1. vmlinuz指的是内核，作用：进程管理、内存管理、文件管理、驱动管理、网络管理。
2. initrd.img是一个小的映象， 放的是和启动相关的驱动模块。通常的步骤是先启动内核，然后内核挂载initrd.img，并执行里面的脚本来进一步挂载各种各样的模块。其中最重要的就是**根文件系统驱动模块**，有了它才能挂载根文件系统，继而运行用户空间的第一个应用程序init或者systemd，完成系统后续的启动。

##### 练习4

```c
//阅读C指针
```



#### 加载内核

**kernel**的三个重要函数：

- `.text`:程序的可执行指令
- `.rodata`: 只读数据，如C编译器生成的ASCII字符串常量。（不过，我们不会麻烦地设置硬件来禁止写入。）
- `.data`: 数据区保存着程序的初始化数据，比如用初始化式声明的全局变量。

`.ld`文件是一种链接器脚本文件，用于描述如何将多个目标文件链接成一个可执行文件或共享库。

```
Idx Name	Size		VMA		LMA		File off	Algn
0 .text		0000178e  f0100000  00100000  00001000  2**2
			CONTENTS, ALLOC, LOAD, READONLY, CODE
1 .rodata	00000704  f01017a0  001017a0  000027a0  2**5
			CONTENTS, ALLOC, LOAD, READONLY, DATA
2 .stab		000044d1  f0101ea4  00101ea4  00002ea4  2**2
			CONTENTS, ALLOC, LOAD, READONLY, DATA
3 .stabstr	00008b04  f0106375  00106375  00007375  2**0
			CONTENTS, ALLOC, LOAD, READONLY, DATA
4 .data		0000a300  f010f000  0010f000  00010000  2**12
			CONTENTS, ALLOC, LOAD, DATA
5 .bss		00000648  f0119300  00119300  0001a300  2**5
			CONTENTS, ALLOC, LOAD, DATA
6 .comment	00000011  00000000  00000000  0001a948  2**0
			CONTENTS, READONLY
```

.text部分的VMA（链接地址）和LMA（加载地址）段的加载地址是该段加载到内存中的内存地址。节的链接地址是该节期望执行的内存地址。

Algn：对齐方式，在编译器将源代码编译成目标文件后，目标文件中的数据和代码需要按照一定的方式排列，以便程序能够正确地访问它们。

File off：文件偏移量(flie offset)，文件偏移量是指文件中某个数据或代码的位置相对于文件开头的字节偏移量。

BIOS从地址0x7c00开始将引导扇区加载到内存中，因此这是引导扇区的加载地址。**这也是引导扇区执行的地方，所以这也是它的链接地址。**我们通过将 text 0x7C00传递给boot/Makefrag中的链接器来设置链接地址，因此链接器将在生成的代码中生成正确的内存地址。

**boot/Makefrag中的链接器**

`boot/Makefrag`是一个Makefile片段，**它定义了如何编译和链接操作系统的启动代码。**在这个Makefile片段中，链接器被用来将编译器生成的目标文件链接成一个可执行文件。链接器的作用是将不同的目标文件中的代码和数据组合成一个整体，并解析它们之间的引用关系，以便生成最终的可执行文件。在操作系统的启动过程中，启动代码是最先执行的代码，它负责初始化硬件和设置操作系统的运行环境。因此，链接器在操作系统的启动过程中扮演着非常重要的角色。

##### 练习 5

```assembly
# 将boot / Makefrag 中的链接地址更改为错误的地址，运行make clean，使用make重新编译 lab，再次遍历引导加载程序的前几条指令，并确定第一条可能“中断”或执行错误操作的指令。
```

详细过程

第一步

```c
将
$(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o $@.out $^
修改成
$(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o $@.out $^
```

第二步

```c
make clean
make
```

将链接地址改为 `0x7000` ，在执行 `lgdtw` 处的加载地址变为了 `0x7064` ，接着后面的运行就会报错。修改地址后，导致引导加载器的段描述符表 `gdt` 加载出错。

**ELF loader**

ELF loader（Executable and Linkable Format loader）是一种用于加载和执行ELF格式可执行文件的程序。ELF格式是一种常见的可执行文件格式，用于在各种UNIX系统中运行的程序。ELF loader的主要功能是**将ELF文件从磁盘中读取到内存中，并将其解析成可执行代码和数据。**它还负责处理程序的符号表、重定位表和动态链接等信息，以确保程序能够正确地运行。在Linux系统中，ld-linux.so是一个常见的ELF loader，它在程序启动时被调用，负责加载和解析程序的ELF文件。

##### 练习 6

重置机器（退出QEMU / GDB并重新启动它们）。在BIOS进入引导加载程序时，检查 `0x00100000` 处的8个内存字，然后在引导加载程序进入内核时再次检查。他们为什么不同？第二个断点有什么？（您实际上并不需要使用QEMU来回答这个问题。只需考虑一下即可。）

**具体步骤**

```c
// 使用 x/Nx addr 打印地址为 addr 处的 N 个字（字长 16bit）。
// 分别在引导加载程序的开始 0x7c00 和 内核程序的开始 0x10000c 处设置断点 (最早查的资料少个0，服了)
// b *0x7c00
// c
// x/12x 0x00100000
// b *0x10000c
// c
// x/12x 0x00100000
```

不同是因为 bootmian 将内核的 `.text` 段内容加载到了此处。



### 第 3 部分：内核

#### 使用虚拟内存解决位置依赖性问题

映射前 4MB 的物理内存， 足以让我们启动并运行。我们使用kern/entrypgdir.c中手写的、静态初始化的页目录和页表来实现这一点。在kern/entry.S 设置该标志之前，内存引用都被视为物理地址(严格地说，它们是线性地址，但boot/boot.s 设置了一个从线性地址到物理地址的身份映射，我们永远不会改变它)。**一旦设置，内存引用就是虚拟地址，由虚拟内存硬件转换为物理地址。**

将虚拟地址从0xf0000000到0xf0400000转换为物理地址0x00000000到0x00400000，将虚拟地址0x00000000到0x00400000转换为物理地址0x00000000到0x00400000。

任何不在这两个范围内的虚拟地址都将导致硬件异常，因为我们还没有设置中断处理，这将导致QEMU转储机器状态并退出或无限重启

##### 练习 7

```assembly
# 使用QEMU和GDB跟踪JOS内核，并在。检查0x00100000和0xf0100000的内存。现在，使用GDB命令单步执行该指令。同样，检查0x00100000和0xf0100000的内存。确保你明白刚才发生了什么。
# movl %eax, %cr0
# 建立新映射后，如果映射不到位，将无法正常工作的第一条指令是什么?注释掉在kern/entry.S中的代码，跟踪它，看看你的判断是否正确。
# movl %eax, %cr0
```

**具体过程**

```assembly
# 用断点,调到0x0010000c
# 之后si,发现到74行代码 movl $0x0, %ebp 开始使用虚拟地址 
# 开始使用虚拟地址以后，x/x 0x00100000 和x/x 0xf0100000对比，发现虚拟地址和物理地址一致。使用虚拟地址前是不一致的。
# 注释掉 movl %eax, %cr0
# 用x/x 0x00100000 和x/x 0xf0100000对比前后，发现虚拟地址和物理地址不一致。
```

**错误的原因**

如果我们注释掉`movl %eax,%cr0`，当访问高位地址时，会出现RAM or ROM 越界错误。

**文件部分**

```assembly
# Turn on paging.
movl	%cr0, %eax
orl	$(CR0_PE|CR0_PG|CR0_WP), %eax
movl	%eax, %cr0
```

这部分指令启动了分页机制，内存引用变成了通过 virtual memory hardware 转换过的物理地址产生的虚拟地址。例如，虚拟地址 0x00000000 到 0x00400000 以及 0xf0000000 到 0xf0400000 都被转为物理地址 0x00000000 到 0x00400000。

通读`kern/printf.c`， `lib/printfmt.c`， 和 `kern/console.c`， 并确保您了解他们的关系。 在以后的实验中会很清楚为什么`printfmt.c`位于单独的`lib`目录中。

##### 练习 8

```assembly
# 我们省略了一小段代码——使用“%o”模式打印八进制数所需的代码。查找并填充此代码片段。
```

阅读完源码，我们可以知道需要替换的部分为printfmt.c中的`case 'o':`部分

```c
		// (unsigned) octal	无符号八进制整数
		case 'o':
			// Replace this with your code.
			putch('X', putdat);
			putch('X', putdat);
			putch('X', putdat);
			break;
```

参考代码中的16机制和10机制修改为

```
		case 'o':
			num = getuint(&ap, lflag);
			base = 8;
			goto number;
```

和10机制的差不多

```c
// unsigned decimal	无符号十进制整数
		case 'u':
			num = getuint(&ap, lflag);
			base = 10;
			goto number;
```

具体跑过了能行。

#### 6个问题

1. 解释`printf.c和console.c`之间的接口。具体来说，`console.c` 导出什么函数？`printf.c`如何使用这个函数？

   **回答**

   `printf.c` 调用 `cputchar` 将字符输出到 console.c 中。console.c导出了putch函数。`printf.c` 使用 `putch` 函数来实现 `printf` 系列函数的输出功能。具体是通过printfmt.c中的vprintfmt函数。

2. 解释 `console.c` 的如下内容：

   **回答**

   这段代码的作用是在达到每行最大显示字符数后，将当前显示内容向上移动一行。

   ```c
   	// crt_pos：当前输出的位置；CRT_SIZE：每行最大显示字符数      
      if (crt_pos >= CRT_SIZE) {
       // 显示字符数超过CRT一屏可显示的字符数
                int i;
       //清除buf中"第一行"的字符
                
     	// 将当前显示内容向上移动一行	  
                memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
       //CRT显示器需要对其用空格擦写才能去掉本来以及显示了的字符。
                for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
                        crt_buf[i] = 0x0700 | ' ';
       //显示起点退回到最后一行起始
                crt_pos -= CRT_COLS;
        }
   ```

3. 逐步跟踪以下代码的执行：

   `make clean` 之后重新 `make` 。在进行 gdb 调试。

   ```
   int x = 1, y = 3, z = 4;
   cprintf("x %d, y %x, z %d\n", x, y, z);
   ```

   - 在对 `cprintf（）`的调用中，`fmt` 指向什么？ `ap`指向什么？
   - 列出（按执行顺序）对 `cons_putc`，`va_arg` 和 `vcprintf` 的每个调用。对于 `cons_putc`，列出其参数。对于`va_arg`，请列出调用之前和之后 `ap` 指向的内容。对于 `vcprintf`，列出其两个参数的值。

   **回答**

   在`kernel.asm`查找位置，再打断点，无数次打错断点的折磨。

   ```
   vcprintf (fmt=0xf0101abe "x %d, y %x, z %d\n", ap=0xf0116fe4 "\001") at kern/printf.c:18
   ```

   ```
   x/s 0xf0101abe
   0xf0101abe: 	"x %d, y %x, z %d\n"
   x/s 0xf0116f04
   0xf0116fe4: 	"\001"
   x/16x 0xf0116f04
   0xf0116f04: 0x01 0x00 0x00 0x00 0x03 0x00 0x00 0x00
   0xf0116f0c: 0x04 0x00 0x00 0x00 0x00 0x00 0x00 0x00
   ```

   fmt指向字符串这是很显然的；ap指向的是可变参数的值，即存储的是x，y，z的值，结果的0x01,0x03,0x04也证明了这个观点。

   ```
   vcprintf(&("x %d, y %x, z %d\n"), &(x))// 两个参数："x %d, y %x, z %d\n"
   													var_list{x,y,z}														 	cons_putc('x')
   cons_putc(' ')
   va_arg() //调用前：x 调用后：y
   cons_putc('1')
   cons_putc(',')
   cons_putc('y')
   cons_putc(' ')
   va_arg() //调用前：y 调用后：z
   cons_putc('3')
   cons_putc(',')
   cons_putc('z')
   cons_putc(' ')
   va_arg() //调用前：z，调用后：
   cons_putc('4')
   cputchar('\n')
   ```

   抄打，只会si一点点看累死，到时候问吧。直接说明一下意义。

   `cons_putc`：属于`console.s`的函数，由源码可以得知是用来输出的，具体将字符输出到串口、并口和CGA显示器上

   `va_arg`：属于`#include <inc/stdarg.h>`的一员，自动获取设置类型的下一个参数。

   `vcprintf`：属于`printf.c`的函数，纯源码，就是调用`printfmt.c`函数，处理获取的字符串，得到的字符串随后交给`putch`函数输出到显示器上。

4. 运行如下代码。输出是什么？解释此输出如何以上一练习的方式逐步到达。

   ```
       unsigned int i = 0x00646c72;
       cprintf("H%x Wo%s", 57616, &i);
   ```

   输出是什么？解释此输出如何以上一练习的方式逐步到达。输出取决于 x86 是小端存储，如果 x86 是大端存储，那么 i 应该设置为什么才能产生相同的输出，是否需要更改 57616 为其他值。

   **回答**

   Hello World可还行，小端存储。如果改为大端序，57616无需改动，只需将`i = 0x726c6400`

5. 在如下代码中，`y =` 之后的输出是什么？（不是固定的值。）为什么会这样？

   ```
   cprintf("x=%d y=%d", 3);
   ```

   `y=-267292872`，由于y并没有参数被指定，所以会输出一个不确定的值。有人说是%(ebp)+20,没证实。

6. 假设GCC改变了它的调用约定，按照声明的顺序将参数压入栈中，这样最后一个参数就会压入栈中。如何改变cprintf或它的接口，以便仍然可以向它传递可变数量的参数?

   变化：压入顺序改变了。

   ```
   int cprintf(const char *fmt, int num_args, ...)
   {
       va_list ap;
       int cnt;
   
       va_start(ap, num_args);
       cnt = vcprintf(fmt, ap);
       va_end(ap);
   
       return cnt;
   }
   ```

   在原本格式化字符串和可变参数的基础上加入了， `num_args`，用于指示可变参数的数量。

#### 栈堆

在本实验的最后一个练习中，我们将更详细地探索C语言在x86上使用栈的方式，并在此过程中编写一个有用的新内核监视器函数，用于打印栈的回溯:从嵌套调用指令到当前执行点保存的指令指针(IP)值的列表。

##### 练习9

确定内核初始化栈的位置，以及栈在内存中的确切位置。内核如何为其栈分配空间?栈指针初始化指向该保留区域的“末端”?

**回答**

我们重新回顾kernel.asm,会发现其中没有boot.s和main.c的代码，很显然它们不是内核的代码，当main.c文件中的bootmain函数运行到最后时，它执行的最后一条指令就是跳转到entry.S文件中的entry地址处。此时控制权已经被转交给了entry.S。entry.S是内核中的第一段代码。

查看反汇编代码kernel.asm，对应entry.S的代码，第56行。

```
# Set the stack pointer
movl	$(bootstacktop),%esp
f0100034:	bc 00 70 11 f0       	mov    $0xf0117000,%esp
```

这块调用的指针%esp根据之前CSAPP可知是栈指针，则栈顶初始位置是$0xf0117000。这里没执行，你可以看见16位系统时的值可还行。

这块定义在inc/memlayout.h中，KSTKSIZE指内核栈空间，KSTKSIZE = 8 × PGSIZE = 8 × 4096B = 32KB。由于内核栈空间为32KB，则栈堆虚拟地址为0xf010f000-0xf0117000，物理地址为0x0010f000-0x00117000

栈指针指向该区域的底端，即栈空间的最高处。

**衔接实验后的知识点**

在32位模式下，堆栈以32位值为单位进行操作，并且**堆栈指针寄存器的值始终保持4字节对齐。这确保了堆栈操作的正确性和效率。**

这里谈到了两个重要的寄存器ebp(栈底指针)和esp(栈顶指针)。esp在上一个实验已经说明过了。下面是对于ebp的说明。ebp算是一份vm的快照，在esp变化时保存之前esp的值，当某个函数出错时，可以通过它进行栈回溯，找见问题函数。

##### 练习10

为熟悉x86平台上的C语言调用约定，请在obj/kern/kernel.asm中找到test_backtrace函数的地址。在那里设置一个断点，并检查在内核启动后每次调用它时发生了什么。每个递归的test_backtrace嵌套层在栈上压入多少个32位(双字)的单词，这些单词是什么?

注意，为了让这个练习正常工作，您应该使用工具页面或Athena上提供的打过补丁的QEMU版本。否则，你必须手动将所有断点和内存地址转换为线性地址。

**回答**

啊这，就是entry.s的后一个函数。这个子程序是一个循环调用，在每一层循环中先打印信息 "entering test_backtrace x"，然后对test_backtrace进行循环调用。当被循环调用完成，再打印信息 "leaving test_backtrace x"。所以最先进入的程序会最后退出。

<img src="https://cdn.staticaly.com/gh/ri-umk/picx-images-hosting@master/xv6/屏幕截图-2023-07-13-104645.4n3yme3nxd4.webp" alt="屏幕截图-2023-07-13-104645" />

第一句语句的汇编

```
1     push %ebp
2     mov %esp, %ebp
3     push %ebx
4     sub $0x14, %esp
```

0xf0116fdc~0xf0116ff8就是当前i386_init子程序的栈帧

子程序中第一句push %ebp，把i386_init的ebp寄存器的值压入堆栈中，即地址0xf0116fd8处，此时esp的值变为0xf0116fd8。

然后 mov %esp, %ebp 把ebp的值更新为esp的值，0xf0116fd8。这个就是当前test子程序的ebp寄存器的值。即它的栈帧的高地址边界。

然后 push %ebx 把ebx寄存器的值压入堆栈，此时esp变为0xf0116fd4。因为%ebx寄存器可能被这个子程序所使用，所以必须把它之前的值保留。

然后 sub $0x14, %esp 把esp中的值减去0x14=20，esp的值变为0xf010ffc0。这就是给test子程序分配一个大小为20个存储单元的额外的栈帧空间，供它存储一些临时变量的值。

对比开始前后和每次的调用

esp：0xf0116fdc	fd8	fd8	fd4	fc0

ebp：0xf0116ff8	ff8	fd8	fd8	fd8

后续的执行都是相似的。

算，具体看这个博客，这个函数重要的汇编都读了，并且解释了。属实nb。

```
https://www.cnblogs.com/wuhualong/p/lab01_exercise10_test_backtrace.html
```

%esp存储栈顶的位置，%ebp存储调用者栈顶的位置，%eax存储x的值。

共有两个4字节的整数被压入栈：

1. 输入参数的值（也就是5）。
2. call指令的下一条指令的地址（也就是f01000dd）

```
%esp = 0xf0116fdc
%ebp = 0xf0116ff8
// stack info
0xf0116fe0: 0x00000005  // 第1次调用时的输入参数：5
0xf0116fdc: 0xf01000dd  // 第1次调用时的返回地址
```

进入**test_backtrace函数**后，涉及栈内数据修改的指令可以分为三部分：

1. 函数开头，将部分寄存器的值压栈，以便函数结束前可以恢复。
2. 调用cprintf前，将输入参数压入栈。
3. 在第2次调用test_backtrace前，将输入参数压入栈。

默认输入参数有4个4字节的word，不足4个的话也分配4个，这样从栈中清除输入参数很简单，直接将esp的值加上16即可。

**mon_backtrace(0, 0, 0)**

通过`add $0x10, %esp`语句，将输入参数及预留的4字节从栈中清除。此时%esp = 0xf010ff30，%ebp = 0xf010ff38.

**退出test_backtrace(0)**

连续3个pop语句将ebx, esi和ebp寄存器依次出栈，然后通过ret语句返回。其他1~5的退出过程类似，不再赘述。

每次调用test_backtrace时，主要做了如下事情：

1. 将返回地址（call指令的下一条指令的地址）压栈
2. 将ebp, esi, ebx三个寄存器的值压栈，以便退出函数前恢复它们的值
3. 调用cprintf函数打印"entering test_backtrace x"，其中x为输入参数的值
4. 将输入参数(x-1)压栈，再在栈中分配3个双字，共16字节，以方便清栈
5. 调用test_backtrace(x-1)
6. 调用cprintf函数打印"leaving test_backtrace x"，其中x为输入参数的值

结论是每次调用test_backtrace时共将8个双字压栈：

1. 返回地址
2. ebp, esi, ebx三个寄存器的值
3. 输入参数(x-1)的值
4. 3个预留双字（与输入参数构成4字节，方便清栈）

##### 练习11

上面的练习应该提供了实现堆栈回溯函数所需的信息。你可以完全用C语言完成，但你可能会发现inc/x86.h中的read_ebp()函数很有用。还必须将这个新函数挂钩到内核监视器的命令列表中，以便用户可以交互式地调用它。

backtrace函数应该以以下格式显示函数调用帧的列表:

```
Stack backtrace:
  ebp f0109e58  eip f0100a62  args 00000001 f0109e80 f0109e98 f0100ed2 00000031
  ebp f0109ed8  eip f01000d6  args 00000000 00000000 f0100058 f0109f28 00000061
  ...
```

每行包含一个 ebp，eip 和 args 。ebp 值指示该函数使用的堆栈中的基本指针：即，刚进入该函数并将前一个函数的基址指针压栈之后的堆栈指针的位置。 列出的 eip 值是函数的返回指令指针：函数返回时控件将返回到的指令地址。 返回指令指针通常指向调用指令之后的指令（为什么？）。 最后，在 args 之后列出的五个十六进制值是所讨论函数的前五个参数，在调用该函数之前，这些参数已被压入堆栈。 当然，如果调用的函数少于五个参数，那么并非所有这五个值都有用。 （为什么回溯代码无法检测到实际有多少个参数？如何解决此限制？）

打印的第一行反映了当前正在执行的函数，即 `mon_backtrace` 本身，第二行反映了称为`mon_backtrace` 的函数，第三行反映了调用该函数的函数，依此类推。 您应该打印所有未完成的堆栈帧。 通过研究内核/入口，您会发现有一种简单的方法可以告诉您何时停止。

提示

1. 如果int* p = (int * )100，那么(int)p + 1和(int)(p + 1)是不同的数:第一个是101，第二个是104。在将整数与指针相加时(如第二种情况)，整数会隐式地乘以指针所指向对象的大小。
2. p[i]定义为与*(p+i)相同，表示p所指向的内存中的第i个对象。上述加法规则在对象大于1字节时适用。
3. &p[i]与(p+i)相同，得到的是p所指向的内存中第i个对象的地址。

**练习11：实现上述backtrace函数。**如果您使用read_ebp()，请注意GCC可能会生成“优化”的代码，在mon_backtrace()的函数序言之前调用read_ebp()，这将导致不完整的堆栈跟踪(最近函数调用的堆栈帧丢失)。虽然我们已经尝试禁用导致此重排的优化，但您可能希望检查mon_backtrace()的程序集，并确保对read_ebp()的调用发生在函数序言之后。

**回答**

回顾：栈堆回溯机制

寻址步骤

```assembly
push %rbp		#将父函数的栈桢起始地址(CFA)压入栈空间
moveq %rsp %rbp	#将子函数的 CFA 存入 RBP 寄存器 
# 结束子函数调用时
moveq %rbp %rsp	#将 RSP 寄存器指回当前函数的 CFA 
pop %rbp		#将父函数的栈桢起始位置 pop 到 RBP 寄存器
ret				#回到上一个函数
```

关于要求列出的值

- ebp记录了前一个函数的栈指针位置
- eip记录了下一条指令的地址位置
- args记录了参数，即所讨论函数的前五个参数

关于栈帧地址相关知识，这里涉及调用时栈顶，返回地址之类的位置。回顾CSAPP笔记中的3.7过程。以及3.11中帧指针（ebp）可以了解到

![屏幕截图 2023-04-19 123214](https://cdn.staticaly.com/gh/ri-umk/picx-images-hosting@master/CS：APP/屏幕截图 2023-04-19 123214.4bbost31ww40.webp)

帧指针和返回地址的位置。

![屏幕截图-2023-04-13-214645](https://cdn.staticaly.com/gh/ri-umk/picx-images-hosting@master/CS：APP/屏幕截图-2023-04-13-214645.o8lrie5rmu8.jpg)

返回地址和被调用函数的参数位置

格式要求：

```
Stack backtrace:  
	ebp f0109e58  eip f0100a62  args 00000001 f0109e80 f0109e98 f0100ed2 00000031  
	ebp f0109ed8  eip f01000d6  args 00000000 00000000 f0100058 f0109f28 00000061  ...
```

代码书写：打印函数调用栈的信息。

```c
int
mon_backtrace(int argc, char **argv, struct Trapframe *tf){
	cprintf("Stack backtrace:\n");
//先声明ebp,eip。ebp获取当前ebp寄存器的值，这个值是地址用*
//read_ebp()被定义在x86.h中,用内联汇编获取ebp的值
	uint32_t *ebp = (uint32_t*)read_ebp();
    uint32_t eip
//终止条件是 ebp = 0，因为 ebp 在一开始的值是 0,而当函数调用发生时，ebp 的值会被设置为上一个函数的 ebp 值。
//这块的位置选择请看上面的图解
    while(ebp){
		eip = *(ebp + 1);
		cprintf("ebp %x eip %x args", ebp, eip);
		uint32_t *esp = ebp + 2;
		for(int i = 0; i < 5; ++i) {
			cprintf(" %08x", esp[i]);
		}
		cprintf("\n");
        // 当前 ebp 指向的地址存储上一个 ebp 的地址
        ebp = (uint32_t*)(*ebp);
    }   
	return 0;
}
```

打印函数调用栈的信息，包括每个函数的 `ebp`、`eip` 和参数的值，并按照调用顺序从当前函数一直回溯到最外层函数。

补充：**函数序言**

函数序言是指在**函数执行之前所执行的一系列指令或操作。它通常用于准备函数执行所需的环境和设置必要的状态。**

函数序言的主要目的是：

1. 保存寄存器状态：函数执行时，寄存器中的值可能会被修改。为了保护调用者的寄存器状态，函数序言会将需要保存的寄存器的值保存到堆栈中。
2. 分配局部变量的空间：函数序言会为函数中定义的局部变量分配内存空间。这通常是通过调整堆栈指针来实现的。
3. 处理函数参数：函数序言会将函数参数从调用者传递的位置复制到函数内部的寄存器或堆栈中，以便函数可以使用这些参数。
4. 设置堆栈帧指针：堆栈帧指针（例如EBP寄存器）用于访问函数的局部变量和参数。函数序言会将堆栈帧指针设置为当前堆栈指针的值，以便在函数执行期间可以轻松地访问局部变量和参数。
5. 执行其他必要的初始化操作：函数序言可能还包括其他必要的初始化操作，例如清除寄存器、设置标志位等。

函数序言的具体实现方式可能因编程语言和编译器而异。在汇编语言中，函数序言通常由一系列特定的指令组成。而在高级编程语言中，函数序言的实现通常由编译器自动生成。

总之，函数序言是在函数执行之前所执行的一系列指令或操作，用于准备函数执行所需的环境和设置必要的状态，例如保存寄存器状态、分配局部变量的空间、处理函数参数、设置堆栈帧指针等。

**不错的栈帧博客**

```
https://blog.csdn.net/qq_41412237/article/details/119489211
```

##### 练习12

此时，`backtrace` 函数可提供栈上导致 `mon_backtrace()` 被执行的函数调用程序的地址。 但是，**通常还想知道与这些地址相对应的函数名称。 例如，哪些函数可能包含导致内核崩溃的错误。**

为了帮助您实现此功能，我们提供了函数`debuginfo_eip()`，该函数在符号表中查找`eip`并返回该地址的调试信息。该函数定义在`kern/kdebug.c`中。

修改堆栈回溯函数，以显示每个 eip 的函数名称，源文件名以及与该 eip 对应的行号。

在`debuginfo_eip`中，`__stab_*`是从哪里来的?这个问题的答案很长;为了帮助你找到答案，你可能需要做以下事情:

1. 在`kern/kernel.ld`文件中查找`__STAB _*`
2. 执行命令objdump -h obj/kern/kernel
3. 执行命令objdump -G obj/kern/kernel
4. 执行gcc -pipe - nostic -O2 -fno-builtin -I. -MD -Wall -Wno-format -DJOS_KERNEL -gstab -c -S kern/init.c，并且查看init.s。
5. 查看引导加载程序是否在加载内核二进制文件时加载符号表

通过插入对`stab_binsearch`的调用来查找地址对应的行号，完成`debuginfo_eip`的实现。

向内核监视器添加一个`backtrace`命令，并扩展`mon_backtrace`的实现，以调用`debuginfo_eip`，并为表单的每个堆栈帧打印一行:

```
K> backtrace
Stack backtrace:
  ebp f010ff78  eip f01008ae  args 00000001 f010ff8c 00000000 f0110580 00000000
         kern/monitor.c:143: monitor+106
  ebp f010ffd8  eip f0100193  args 00000000 00001aac 00000660 00000000 00000000
         kern/init.c:49: i386_init+59
  ebp f010fff8  eip f010003d  args 00000000 00000000 0000ffff 10cf9a00 0000ffff
         kern/entry.S:70: <unknown>+0
K> 
```

**每一行给出了文件名和栈帧的`eip`文件中的行，后面是函数名和`eip`与函数第一条指令的偏移量(例如，`monitor+106`表示返回的`eip`比`monitor`的开头多106字节)。**

确保将文件和函数名打印在单独的一行上，以避免混淆评分脚本。

提示:`printf`格式字符串提供了一种简单的(虽然不明确)方法来打印像stab表中那样以非空字符结尾的字符串。`printf(" %。*s"， length, string)`打印字符串中最多长度的字符看看printf手册页，以了解为什么这样做可行。

你可能会发现回溯过程中遗漏了一些函数。例如，您可能会看到对`monitor()`的调用，但不会看到对`runcmd()`的调用。这是因为编译器内联了一些函数调用。其他优化可能会让你看到意想不到的行号。如果从`GNUMakefile`中去掉-O2，则回溯可能会更有意义(但内核将运行得更慢)。

**几个问题**

**问题1：**在 debuginfo_eip 中,__STAB _* 来自哪里?

来自kern/kernel.ld的第26行到第40行.它们指向elf文件的.stab部分,该部分包含调试信息,即符号表.它被强制链接到内核并加载到内核内存中.objdump -h obj/kern/kernel命令的输出显示确实包含一个.stab和一个.stabstr部分.objdump -G obj/kern/kernel 命令将打印符号表.因此 debuginfo_eip() 可以从 .stab 部分读取调试信息,如函数名称,这就是使用 __STAB _* 的原因.

符号表的重点就是，了解结构体中所指代对象的意义（stab.h）

```
struct Stab
     Symnum是符号索引，换句话说，整个符号表看作一个数组，Symnum是当前符号在数组中的下标
     n_type是符号类型，FUN指函数名，SLINE指在text段中的行号
     n_othr目前没被使用，其值固定为0
     n_desc表示在文件中的行号
     n_value表示地址。特别要注意的是，这里只有FUN类型的符号的地址是绝对地址，SLINE符号的地址是偏移量，其实际地址为函数入口地址加上偏移量。比如第3行的含义是地址f01000b8(=0xf01000a6+0x00000012)对应文件第34行。

```

```
struct Eipdebuginfo {
	const char *eip_file;	//EIP的源代码文件名
	int eip_line;			//EIP的源代码行号

	const char *eip_fn_name;	//函数名称
					//注意:非null终止!
	int eip_fn_namelen;		//函数名的长度
	uintptr_t eip_fn_addr;		//函数起始地址
	int eip_fn_narg;		//函数参数数量
};
```

**问题2：**为什么要了解__ STAB _*?

`__STAB_*` 符号是在链接脚本中通过 `PROVIDE` 指令定义的全局符号，用于传递调试信息的起始和结束位置给其他代码使用。

**问题3：**通过插入对`stab_binsearch`的调用来查找地址对应的行号，完成`debuginfo_eip`的实现。

`stab_binsearch`的作用是在给定的 `stabs` 数组中查找符合条件的元素。

```
stab_binsearch(stabs, &lline, &rline, N_SLINE, addr);
```

- `stabs`：指向 `struct Stab` 结构体数组的指针。
- `region_left` 和 `region_right`：指向表示查找范围的两个整数的指针。
- `type`：要查找的元素类型。
- `addr`：要查找的地址。

Hint:要求查看 stab.h 知道了使用 N_SLINE，

代码如下：根据符号表，更新eip_line的值，即eip的行号。

```
stab_binsearch(stabs, &lline, &rline, N_SLINE, addr);
if (lline <= rline)
    info->eip_line = stabs[lline].n_desc;
else
    return -1;
```

在 `stab_binsearch` 函数中找到了符合条件的元素，则将 `stabs[lline].n_desc` 的值赋给 `info->eip_line`，更新 `info` 结构体中的 `eip_line` 成员。

**问题4：**向内核监视器添加一个`backtrace`命令，并扩展`mon_backtrace`的实现，以调用`debuginfo_eip`，并为表单的每个堆栈帧打印一行:

```
K> backtrace
Stack backtrace:
  ebp f010ff78  eip f01008ae  args 00000001 f010ff8c 00000000 f0110580 00000000
         kern/monitor.c:143: monitor+106
  ebp f010ffd8  eip f0100193  args 00000000 00001aac 00000660 00000000 00000000
         kern/init.c:49: i386_init+59
  ebp f010fff8  eip f010003d  args 00000000 00000000 0000ffff 10cf9a00 0000ffff
         kern/entry.S:70: <unknown>+0
K> 
```

在monitor.c的`static struct Command commands[] =`中添加

```
{ "backtrace", "Display stack backtrace", mon_backtrace },
```

操作台显示backtrace

在monitor.c的`mon_backtrace`中添加

```
	struct Eipdebuginfo info;
	// addr: 传入 eip 的内容
	debuginfo_eip((uintptr_t)eip, &info);
	cprintf("\t%s:%d: %.*s+%d\n",
		 info.eip_file, info.eip_line,
		 info.eip_fn_namelen, info.eip_fn_name, (uintptr_t)eip - info.eip_fn_addr);
```

就可以了，吐槽，实验1单独完成不查资料不得死那里。。。

<img src="https://cdn.staticaly.com/gh/ri-umk/picx-images-hosting@master/xv6/屏幕截图-2023-07-15-105046.1ef3ob0d79pc.webp" alt="屏幕截图-2023-07-15-105046" />

完结撒花，中间出大问题了，所以用快照重置了一下，代码就复制粘贴。



## lab 2

**内存管理**

开始前的题外话：下了个Steam++，想着好用，但是出现了443端口被占用的问题。这里是解决方法。（注意这里的文件夹是隐藏文件夹）

```
https://www.cnblogs.com/Pipe-fish/p/17026252.html
```

**前置浏览：新的源文件**

- inc/memlayout.h：描述了必须通过修改pmap.c来实现的虚拟地址空间的布局
- kern/pmap.c
- kern/pmap.h：PageInfo 用于跟踪哪些物理内存页可用的结构
- kern/kclock.h：操纵PC的电池供电时钟和CMOS RAM硬件，其中BIOS记录PC包含的物理内存量。
- kern/kclock.c

推荐阅读的文章

```
https://www.cnblogs.com/oasisyang/p/15421981.html
https://www.cnblogs.com/t1ostang/p/lab2-memory-managerment.html
```

### 工具

本实验涉及的一些常用函数，宏

**PageInfo**

```c
来自于 memlayout.h
struct PageInfo {
	// Next page on the free list.
	struct PageInfo *pp_link;

// pp_ref是指针的计数(通常是页表项)
//指向该页，表示使用page_alloc分配的页。
//启动时使用pmap.c分配的页
// boot_alloc没有有效的引用计数字段。

	uint16_t pp_ref;
};
```

##### **函数**

这里有几个很有用的地址变换工具，具体实现可以查看`mmu.h`和`pmap.h`，提前掌握这些小工具对于理解地址变换和后续的程序编写有很大帮助。

| **名称**      | **参数**                      | 作用                                                  |
| ------------- | ----------------------------- | ----------------------------------------------------- |
| PADDR         | 内核**虚拟地址**kva           | 将内核虚拟地址kva转成对应的物理地址                   |
| KADDR         | **物理地址**pa                | 将物理地址pa转化为内核虚拟地址                        |
| page2pa       | 页信息结构**struct PageInfo** | 通过空闲页结构得到这一页起始位置的物理地址            |
| pa2page       | **物理地址**pa                | 通过物理地址pa获取这一页对应的页结构体struct PageInfo |
| page2kva      | 页信息结构**struct PageInfo** | 通过空闲页结构得到这一页起始位置的虚拟地址            |
| PDX           | **线性地址**la                | 获得该线性地址la对应的页目录项索引                    |
| PTX           | **线性地址**la                | 获得该线性地址la在二级页表中对应的页表项索引          |
| PTE_ADDR(pte) | 页表项或页目录项的**值**      | 获得对应的页表基址或者物理地址基址(低12位为0)         |

**标志**

```assembly
//页表/目录项标志

#define pte_p 0x001 //存在
#define pte_w 0x002 //可写
#define pte_u 0x004 //用户
#define pte_pwt 0x008 // Write-Through
#define pte_pcd 0x010 //禁用cache
#define pte_a 0x020 //访问
#define pte_d 0x040 //脏
#define pte_ps 0x080 //页大小
#define pte_g 0x100 //全局
```



### 第 1 部分：物理页面管理

这个注释和代码，上来就被哄住了，好多啊。

#### 练习 1

```
// 在kern/pmap.c文件中实现一下代码
boot_alloc()
mem_init()
page_init()
page_alloc()
page_free()
```

**回答**

函数作用

```c
// 在内核中分配一块足够大的内存空间，以供后续的操作系统代码使用。
// boot_alloc()
// 初始化操作系统的内存管理系统，包括设置页目录、初始化页数据结构、设置虚拟内存等。
// mem_init()
// 初始化页数据结构和空闲页链表。
// page_init()
// 分配物理页。根据指定的标志分配一个物理页，并返回该页的信息。
// page_alloc()
// 释放物理页。记得要确保在释放物理页之前，需要确保该页的引用计数为零，并且该页没有被链接到其他数据结构中。
// page_free()
```

这不就是写一个内存分配嘛，，，高度直接上去了。

相关变量

```
size_t npages;//物理内存的数量(以页为单位)
static size_t npages_basemem;//基本内存的数量(以页为单位)
//这些变量在mem_init()中设置
pde_t * kern_pgdir;//内核的初始页面目录
struct PageInfo *pages;//物理内存页状态数组
static struct PageInfo *page_free_list;//物理内存页的空闲链表
```

**PageInfo**

```c
来自于 memlayout.h
struct PageInfo {
	// Next page on the free list.
	struct PageInfo *pp_link;

// pp_ref是指针的计数(通常是页表项)
//指向该页，表示使用page_alloc分配的页。
//启动时使用pmap.c分配的页
// boot_alloc没有有效的引用计数字段。

	uint16_t pp_ref;
};
```

##### **工具**

这里有几个很有用的地址变换工具，具体实现可以查看`mmu.h`和`pmap.h`，提前掌握这些小工具对于理解地址变换和后续的程序编写有很大帮助。

| **名称**      | **参数**                      | 作用                                                  |
| ------------- | ----------------------------- | ----------------------------------------------------- |
| PADDR         | 内核**虚拟地址**kva           | 将内核虚拟地址kva转成对应的物理地址                   |
| KADDR         | **物理地址**pa                | 将物理地址pa转化为内核虚拟地址                        |
| page2pa       | 页信息结构**struct PageInfo** | 通过空闲页结构得到这一页起始位置的物理地址            |
| pa2page       | **物理地址**pa                | 通过物理地址pa获取这一页对应的页结构体struct PageInfo |
| page2kva      | 页信息结构**struct PageInfo** | 通过空闲页结构得到这一页起始位置的虚拟地址            |
| PDX           | **线性地址**la                | 获得该线性地址la对应的页目录项索引                    |
| PTX           | **线性地址**la                | 获得该线性地址la在二级页表中对应的页表项索引          |
| PTE_ADDR(pte) | 页表项或页目录项的**值**      | 获得对应的页表基址或者物理地址基址(低12位为0)         |

**推荐参考**

```
https://www.cnblogs.com/oasisyang/p/15495908.html
```

**代码：记得读注释**

##### `boot_alloc()`

在内核中分配一块足够大的内存空间，以供后续的操作系统代码使用。

```c
	if (n == 0){
		return nextfree;
	} else if (n > 0){
		result = nextfree;
		nextfree = ROUNDUP((char *)result + n, PGSIZE);
		return result;
	}
```

不带了一个个头文件找了这里简单说一下。

```
ROUNDUP((char *) end, PGSIZE)是一个宏，用于将end地址向上舍入到最接近的PGSIZE的倍数。PGSIZE是一个宏，表示页的大小。
```

问题：其实不是很理解为什么，nextfree这个值哪里来的。



##### `mem_init()`

初始化操作系统的内存管理系统，包括设置页目录、初始化页数据结构、设置虚拟内存等。

`string.h` ==》`memset`函数 

前置代码解析

```c
	//i386_detect_memory获取物理内存大小
	i386_detect_memory();

	//////////////////////////////////////////////////////////////////////
	// create initial page directory.
	kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
	memset(kern_pgdir, 0, PGSIZE);

	//////////////////////////////////////////////////////////////////////
	// Permissions: kernel R, user R
    // UVPT是 User read-only virtual page table的虚拟地址
    // PDX获得页目录项索引
    // 将内核页目录安装到内核页目录中（参考前一篇文章中类似的搞法）
    /*
    ULIM, MMIOBASE-->+------------------------------+ 0xef800000
                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE
     UVPT       ---->+------------------------------+ 0xef400000
	此处PTSIZE=4096*1024 =4MB 为一个页目录项能映射的内存大小
	*/
	kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;

```

...........................

```c
// create initial page directory.
kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
memset(kern_pgdir, 0, PGSIZE);
```

对照上面的写就行

```c
//// 分配pages数组，一共有npages个物理页，每个页使用struct PageInfo结构记录，并填充0	
pages = (struct PageInfo *) boot_alloc (npages * sizeof(struct PageInfo));
	memset(pages, 0, npages * sizeof(struct PageInfo));
```

认真看题：虚拟内存看的我崩溃，然后发现不用写，，，对照上面的函数写就行。



##### `page_init()`

初始化页数据结构和空闲页链表。这块得先区分那些是空闲的，确定需要初始化的，然后再初始化。

不需要初始化的：**物理内存的第0页需要被标记为已使用；IO-hole需要被标记为已使用，不能被分配出去；扩展地址包含内核地方不能被分配出去，剩下的空间就可标记为free并后续可以分配出去。**

<img src="https://cdn.staticaly.com/gh/ri-umk/picx-images-hosting@master/xv6/2845449-20220420202005770-49778064.117wxlg0c44g.webp" alt="2845449-20220420202005770-49778064" />

代码如下

```c
void
page_init(void)
{
	// The example code here marks all physical pages as free.
	// However this is not truly the case.  What memory is free?
	//  1) Mark physical page 0 as in use.
	//     This way we preserve the real-mode IDT and BIOS structures
	//     in case we ever need them.  (Currently we don't, but...)
	//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)
	//     is free.
	//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must
	//     never be allocated.
	//  4) Then extended memory [EXTPHYSMEM, ...).
	//     Some of it is in use, some is free. Where is the kernel
	//     in physical memory?  Which pages are already in use for
	//     page tables and other data structures?
	//
	// Change the code to reflect this.
	// NB: DO NOT actually touch the physical memory corresponding to
	// free pages!	
	size_t i;

	for (i = 0; i < npages; i++) {
		if(i == 0){
                        pages[i].pp_ref = 1;
                        pages[i].pp_link = NULL;
                } else if(i>=1 && i<npages_basemem){
                        pages[i].pp_ref = 0;
                        pages[i].pp_link = page_free_list;
                        page_free_list = &pages[i];
                } else if(i>=IOPHYSMEM/PGSIZE && i < EXTPHYSMEM/PGSIZE){
                        pages[i].pp_ref = 1;
                        pages[i].pp_link = NULL;
                } else if(i >= EXTPHYSMEM/ PGSIZE && i < (PADDR(boot_alloc(0)))/PGSIZE){
                        pages[i].pp_ref = 1;
                        pages[i].pp_link = NULL;
                } else{
                        pages[i].pp_ref = 0;
                        pages[i].pp_link = page_free_list;
                        page_free_list = &pages[i];
                }
	}
}
```



##### `page_alloc()`

分配物理页。根据指定的标志分配一个物理页，并返回该页的信息。

```
// 分配一个物理页
// If (alloc_flags & ALLOC_ZERO) 用0填充该页
// 不要增加页引用数
// 链接域要设为NULL
// 如果内存不够了，返回NULL
// Hint: use page2kva and memset
```

代码

```c
struct PageInfo *
page_alloc(int alloc_flags)
{
	// Fill this function in
	struct PageInfo *ppt = page_free_list;
	if (ppt == NULL){
		cprintf("There is no memory to allocate\n");
		return NULL;
	}
	
	page_free_list = page_free_list->pp_link;
	ppt->pp_link = NULL;
	
	if (alloc_flags & ALLOC_ZERO){
		memset(page2kva(ppt), 0, PGSIZE);
	}
	
	return ppt;
}
```



##### `page_free()`

作用是释放一个页。也就是将一个`struct PageInfo`结构，重新挂回`page_free_list`。注意不能释放一个引用值不为0的页，或者链接值不为空的页。

代码：（判断完没问题只要导入就行）

```c
void
page_free(struct PageInfo *pp)
{
	// Fill this function in
	// Hint: You may want to panic if pp->pp_ref is nonzero or
	// pp->pp_link is not NULL.
	if (pp->pp_ref != 0 || pp->pp_link != NULL){
		panic("page_free can free the memory");
		return ;
	} 
		pp->pp_link = page_free_list;
		page_free_list = pp;
}
```

##### 改bug中发生的问题：

1.初始化页数据结构和空闲页链表。

```
出现了一些不应该在空闲列表上的页面，assert(page2pa(pp) != EXTPHYSMEM);
问题在于扩展内存(EXTPHYSMEM，…)其中一些正在使用，一些是空闲的。这里要查资料区分开，然后进行初始化。
```

2.虚拟地址无效

```
没有空闲内存，所以我们不能分配页表 assert(page_insert(kern_pgdir, pp1, 0x0, PTE_W) < 0);可能的错误。

```



### 第 2 部分：虚拟内存

#### 练习 2

阅读 80386 中的5,6章内容，**重点是页翻译和基于页的保护的章节(5.2和6.3)。**

**5.内存管理**

80386 转换逻辑地址变成物理地址分两步：

- 段转换，其中逻辑地址（由段选择器和段偏移量）转换为线性地址。
- 页面转换，其中线性地址转换为物理地址地址。

<img src="https://cdn.staticaly.com/gh/ri-umk/picx-images-hosting@master/xv6/屏幕截图-2023-07-18-172948.65nqigjf5840.webp" alt="屏幕截图-2023-07-18-172948" />

##### 5.1 段变换

###### **描述符**

段描述符为处理器提供了将逻辑地址映射到线性地址所需的数据。描述符是由编译器、链接器、加载器或操作系统创建的。

段描述符字段包括:

- BASE:**定义段在4g线性地址空间中的位置。**处理器将基地址的三个片段连接起来形成一个32位值。
- LIMIT:**定义段的大小。**当处理器将极限字段的两部分连接起来时，会得到一个20位的值。处理器根据Granularity bit的设置，以两种方式之一解释limit字段。
  1. 以1字节为单位，定义最多1兆字节的限制。
  2. 以4kb为单位，定义最多4gb的限制。加载时，极限向左移动12位，插入低阶1位。
- Granularity bit:**指定解释LIMIT字段的单位。**当该比特位被清除时，以1字节为单位解释限制;设置后，以4千字节为单位解释限制。
- TYPE:**区分各种类型的描述符。**
- DPL(描述符特权级别):**由保护机制使用(参见第6章)。**
- Segment-Present bit(段存在位):**如果该位为0，则描述符在地址转换中无效;**当描述符的选择器加载到段寄存器时，处理器将发出异常信号。图5-4显示了当前位为0时描述符的格式。操作系统可以自由使用标记为可用的位置。实现基于段的虚拟内存的操作系统会在两种情况下清除当前的比特位:
  1. 当段所跨越的线性空间没有被分页机制映射时。
  2. 当段不在内存中时。
- Accessed bit:**处理器在访问该段时设置该比特位。**例如，描述符的选择器被加载到段寄存器中或由选择器测试指令使用。在段级实现虚拟内存的操作系统可以通过定期测试和清除该位来监控段的使用频率。

<img src="https://cdn.staticaly.com/gh/ri-umk/picx-images-hosting@master/xv6/fig5-3.5zfqb6tjbw80.gif" alt="fig5-3" />

###### **描述符表**

段描述符存储在两种描述符表中:

- 全局描述符表(GDT)
- 局部描述符表(local descriptor table, LDT)

描述符表就是一个存储了描述符的8字节数组，描述符表的长度是可变的，最多可以包含8192(2^(13))个描述符。但GDT(索引=0)的第一项不由处理器使用。

处理器通过GDTR和LDTR寄存器在内存中定位GDT和当前LDT。这些寄存器在线性地址空间中存储表的基地址，并存储段限制。LGDT和SGDT指令用于访问GDTR;LLDT和SLDT指令用于访问LDTR。

<img src="https://cdn.staticaly.com/gh/ri-umk/picx-images-hosting@master/xv6/fig5-5.2rrald3uic20.gif" alt="fig5-5" />

###### **选择器**

逻辑地址的选择器部分通过指定描述符表并在该表中索引描述符来标识一个描述符。

- 索引:从描述符表的8192个描述符中选择一个。处理器只需将该索引值乘以8(描述符的长度)，并将结果添加到描述符表的基址，以便访问表中适当的段描述符。
- 表指示符(Table Indicator):选择器指向的描述符表。0表示GDT;1表示当前LDT。
- 请求权限级别:由保护机制使用。(参见第6章)

因为处理器不使用GDT的第一项，所以索引为0、表指示符为0的选择器(即指向GDT第一项的选择器)可以用作null选择器。当用null选择器加载段寄存器(CS或SS除外)时，处理器不会引起异常。但在使用段寄存器访问内存时，它将导致异常。该特性用于初始化未使用的段寄存器，以捕获意外引用。

###### **段寄存器**

80386将描述符的信息存储在段寄存器中，从而避免了每次访问内存时都需要查询描述符表的需要。

加载这些寄存器的操作是普通的程序指令(曾在第3章描述过)。这些指令分为两类:

- 直接装载指令;例如:MOV、POP、LDS、LSS、LGS、LFS。这些指令显式地引用段寄存器。
- 隐含负载指令;例如，far CALL和JMP。这些指令隐式地引用CS寄存器，并向其加载一个新值。

因为大多数指令引用的数据段，其选择器已经加载到段寄存器中，处理器可以将指令提供的段相对偏移量添加到段基地址，而不需要额外的开销。



##### 5.2 分页地址转换

在地址转换的第二阶段，80386将线性地址转换为物理地址。这一阶段的地址转换实现了面向页的虚拟内存系统和页级保护所需的基本特性。

###### **页帧**

页帧是物理内存连续地址的4k字节单位。页以字节边界开始，大小是固定的。

###### **线性地址**

线性地址通过指定一个页表、表中的一页以及该页中的偏移量间接引用物理地址。处理器如何通过两级页表将线性地址的DIR、PAGE和OFFSET字段转换为物理地址。寻址机制使用DIR字段作为页目录的索引，使用page字段作为页目录确定的页表的索引，使用OFFSET字段寻址由页表确定的页内的一个字节。

<img src="https://cdn.staticaly.com/gh/ri-umk/picx-images-hosting@master/xv6/fig5-9.5oiuxvv7a5c0.gif" alt="fig5-9" />

###### **页表**

页表就是一个32位页说明符的数组。

当前页目录的物理地址存储在CPU寄存器CR3中，也称为页目录基本寄存器(PDBR)。内存管理软件可以选择对所有任务使用一个页面目录，对每个任务使用一个页面目录，或者两者的某种组合。

###### **页表条目**

两层页表中的项格式相同。图5-10展示了这种格式。

<img src="https://cdn.staticaly.com/gh/ri-umk/picx-images-hosting@master/xv6/fig5-10.2s20ys70f1g0.gif" alt="fig5-10" />

###### **页帧地址**

页帧地址指定了页的物理起始地址。因为页位于4K边界上，低阶12位总是0。在页目录中，页帧地址是一个页表的地址。在二级页表中，页帧地址是包含所需内存操作数的页帧的地址。

###### **当前位**

当前比特位表示页表项是否可用于地址转换。

- P=1表示该表项可以使用。
- 当P=0时，页表项对地址转换无效，剩余的页表项可供软件使用。入口中的其他比特位都不经过硬件测试。

###### **访问位和脏位**

这些位提供了有关页表两级的页使用情况的数据。除页目录项中的脏比特位外，其他比特位都由硬件设置。但是，处理器并不清除这些比特位。

处理器在对页进行读或写操作之前，将两层页表中对应的访问位都设置为1。

在对二级页表项覆盖的地址进行写操作之前，处理器将脏位设置为1。目录项中的脏位未定义。

支持分页虚拟内存的操作系统可以使用这些位来确定在内存需求超过可用物理内存时从物理内存中删除哪些页。操作系统负责测试和清除这些位。

###### **读写位和用户/管理员位**

这些比特位不用于地址转换，而是用于页级保护，处理器在进行地址转换的同时执行该操作。

###### **页翻译缓存**

为了提高地址转换的效率，处理器将最近使用的页表数据存储在片上高速缓存中。只有在必要的分页信息不在缓存中时，才需要引用这两层页表。

页翻译缓存的存在对应用程序程序员是不可见的，但对系统程序员是不可见的。操作系统程序员必须在页表改变时刷新缓存。页转换缓存可以通过以下两种方法刷新。

1. 通过使用MOV指令重新加载CR3;例如:

   Mov cr3, eax

2. 通过执行任务切换到与当前TSS具有不同CR3映像的TSS。

##### 5.3 结合片段和页面翻译

###### **“扁平”架构**

通过将段寄存器加载为覆盖整个32位线性地址空间的选择子，可以绕过分段机制。这样，程序可以使用32位的偏移量直接寻址整个内存空间，而不需要考虑段基址和段界限。

总之，通过加载段寄存器的选择子来覆盖整个32位线性地址空间，可以在80386处理器上实现类似于没有分段的架构的执行环境，简化编程并提高执行效率。

###### **跨越几页的片段**

80386的体系结构允许段的大小大于或小于页的大小(4千字节)。例如，假设一个段用于寻址和保护一个跨越132 kb的大型数据结构。在支持分页虚拟内存的软件系统中，不需要整个结构立即进入物理内存。该结构分为33页，其中任意页数都可能不存在。应用程序程序员不需要知道虚拟内存子系统以这种方式对该结构进行分页。

###### **非对齐的页面和段边界**

80386的体系结构并不强制页和段的边界之间存在任何对应关系。一个页包含一个段的结尾和另一个段的开头是完全允许的。同样，一个段可能包含一页的结尾和另一页的开头。

###### **对齐的页面和段边界**

如果内存管理软件强制要求页和段边界之间有某种对应关系，它可能会简单一些。例如，如果段的分配仅以一页为单位，则段和页的分配逻辑可以合并。

###### **每个段对应的页表**

空间管理的一种方法甚至可以进一步简化空间管理软件，即在段描述符和页-目录项之间维护一一对应的关系，如图5-13所示。每个描述符都有一个基址，其中低阶22位为0;换句话说，基址由页表的第一项映射。段可以有1 ~ 4 mb的限制。根据限制的不同，该段包含在1 ~ 1 k个页帧中。因此，一个进程被限制为1K个段(这对许多应用程序来说已经足够了)，每个段最多包含4 mb。描述符、对应的页目录项和对应的页表可以同时分配和释放。

<img src="https://cdn.staticaly.com/gh/ri-umk/picx-images-hosting@master/xv6/fig5-13.3nlwo8kzy3k0.gif" alt="fig5-13" />

##### 6.1 80386保护机制概述

在80386的保护有五个方面:

- 类型检查
- 限制检查
- 可寻址域限制
- 程序入口限制
- 指令集限制

80386的保护硬件是内存管理硬件的组成部分。保护既适用于片段翻译，也适用于页面翻译。

硬件会检查每个对内存的引用，以确认它满足保护标准。所有这些检查都是在内存周期开始之前进行的。任何违规都会阻止循环的启动，并导致异常。由于这些检查与地址生成同时进行，因此不会造成性能损失。

访问内存的无效尝试将导致异常。有关异常机制的解释，请参考第9章。本章定义了导致异常的保护违反。

“特权”的概念对保护的几个方面至关重要。特权适用于过程，是指过程可以被信任的程度，在这种程度上，过程不会犯可能影响其他过程或数据的错误。在应用于数据时，特权是数据结构对不太可信的过程应该具有的保护程度。

权限的概念既适用于段保护，也适用于页保护。

##### 6.2 段层面的保护

这五个方面的保护都适用于分段翻译:

- 类型检查
- 限制检查
- 可寻址域限制
- 程序入口限制
- 指令集限制

段是保护的单位，段描述符存储保护参数。保护检查由CPU自动执行，当段描述符的选择器加载到段寄存器时，以及每次段访问时。段寄存器保存了当前可寻址段的保护参数。

###### **描述符存储保护参数**

保护参数在创建描述符时由系统软件放置在描述符中。当程序将选择器载入段寄存器时，处理器不仅载入段的基地址，而且载入保护信息。每个段寄存器在不可见部分中都有一些位，用于存储基本、限制、类型和特权级别;因此，对同一段的后续保护检查不会消耗额外的时钟周期。

###### **类型检查**

描述符的类型字段有两个函数:

- 区分不同的描述符格式。
- 指定段的预期用途。

除了应用程序常用的数据和可执行段的描述符外，80386还具有操作系统和门使用的特殊段的描述符。表6-1列出了为系统段和门定义的所有类型。请注意，并非所有描述符都定义了段。门描述符有不同的用途，我们将在本章后面讨论。

数据的类型字段和可执行段描述符包括一些位，这些位进一步定义了段的用途(参见图6-1):

<img src="https://cdn.staticaly.com/gh/ri-umk/picx-images-hosting@master/xv6/fig6-1.3uzygp80q940.gif" alt="fig6-1" />

- 数据段描述符中的可写位指定指令是否可以写入该段。

- 可执行段描述符中的可读位指定了是否允许从段中读取指令

  (例如，访问与指令一起存储的常数)。可读、可执行的段有两种读取方式:

  1. 通过CS寄存器，通过使用CS覆盖前缀。
  2. 通过将描述符的选择器加载到数据段寄存器(DS、ES、FS或GS)。

类型检查可用于检测试图以程序员不希望的方式使用段的编程错误。处理器在以下两种情况下检查类型信息。

1. 当描述符的选择器载入段寄存器时。某些段寄存器只能包含某些类型的描述符;例如:
   - CS寄存器只能用可执行段的选择器加载。
   - 不可读的可执行段的选择器不能装入数据段寄存器。
   - 只有可写数据段的选择器才能加载到SS中。

2. 当指令(隐式或显式)指向段寄存器时。某些段只能以某种预定义的方式被指令使用;例如:
   - 任何指令都不能写入可执行段。
   - 如果可写位未设置，则任何指令都不能写入数据段。
   - 除非设置了可读位，否则任何指令都不能读取可执行段。

###### **限制检查**

段描述符的limit字段由处理器用来防止程序寻址该段外部。

处理器对该限制的解释取决于G(granularity)位的设置。对于数据段，处理器对该限制的解释也依赖于e位(expansion-direction bit) 和b位(big bit)(参见表6-2)。

当G=0时，实际的limit是描述符中20位limit字段的值。在这种情况下，限制的范围可能是0到0FFFFFH(2^(20) - 1或1兆字节)。当G=1时，处理器在limit字段的值上附加12个低阶1位。在这种情况下，实际限制可能从0FFFH(2^(12) - 1或4 kb)到0ffffffh(2^(32) - 1或4 gb)。

对于除向下扩展数据段之外的所有类型的段，限制的值比段的大小(以字节表示)小1。在上述任何一种情况下，处理器都会导致通用保护异常:

- 试图以地址>限制访问内存字节。
- 试图访问地址为>= limit的内存字。
- 试图访问地址>= (limit-2)的内存双字。

对于向下扩展的数据段，极限具有相同的功能，但解释不同。在这种情况下，有效地址的范围是从limit + 1到64K或2^(32)- 1 (4 gb)，具体取决于b位。当极限为零时，向下扩展段具有最大尺寸。(打开扩展位交换，哪些字节可以访问，哪些不能。)

向下扩展特性使得可以通过将栈复制到更大的段中来扩展栈的大小，而无需更新栈内指针。

描述符表的limit字段由处理器用于防止程序选择描述符表之外的表项。描述符表的限制标识了表中最后一个描述符的最后一个有效字节。因为每个描述符都是8字节长，所以对于最多可以包含N个描述符的表，其最大值是N * 8 - 1。

极限检查可以捕获编程错误，如失控的下标和无效的指针计算。这样的错误在发生时就会被检测出来，因此更容易确定原因。如果没有限制检查，这样的错误可能会损坏其他模块;这种错误的存在直到稍后被损坏的模块行为不正常且难以识别原因时才会被发现。

###### **特权级别**

特权的概念是通过为处理器识别的关键对象分配一个0到3的值来实现的。这个值称为特权级别。值0表示最大权限，值3表示最小权限。

下列处理器识别的对象包含特权级别:

- 描述符包含一个称为描述符特权级别(DPL)的字段。
- 选择器包含一个称为请求者特权级别(RPL)的字段。RPL用于表示源自选择器的过程的特权级别。
- 一个内部处理器寄存器记录了当前的特权级别(CPL)。通常CPL等于处理器当前执行的段的DPL。当控制转移到具有不同DPLs的段时，CPL发生变化。

处理器通过将CPL与一个或多个其他特权级别进行比较，自动评估一个过程访问另一个段的权限。在描述符选择器加载到段寄存器时执行求值。用于评估对数据访问的标准与评估向可执行段的控制转移的标准不同。

<img src="https://cdn.staticaly.com/gh/ri-umk/picx-images-hosting@master/xv6/fig6-2.2y3fo85z1ku0.gif" alt="fig6-2" />

###### **限制数据访问**

为了寻址内存中的操作数，80386程序必须将数据段的选择器加载到数据段寄存器(DS, ES, FS, GS, SS)中。处理器通过比较特权级别自动评估对数据段的访问。在将目标段描述符的选择器加载到数据段寄存器时执行评估。共有三种不同的权限级别进入这种权限检查。

- CPL(当前特权级别)。
- 用于指定目标段的选择器的RPL(请求者特权级别)。
- 目标段描述子的DPL。

只有当目标段的DPL在数字上大于或等于CPL和选择器的RPL的最大值时，指令才能加载数据段寄存器(并随后使用目标段)。换句话说，一个过程只能访问具有相同或更低特权级别的数据。

任务的可寻址域随着CPL的变化而变化。当CPL为0时，所有特权级别的数据段都是可访问的。当CPL为1时，只有特权级别1到3的数据段是可访问的;当CPL为3时，只有特权级别3的数据段是可访问的。例如，80386的这个属性可以用来防止应用程序程序读取或更改操作系统的表。

###### **在代码段中访问数据**

使用数据段相比，不太常见的是使用代码段存储数据。代码段可以合法地保存常量;不能写入被描述为代码段的段。下列在代码段中访问数据的方法是可能的：

- 用一个不符合标准的、可读的、可执行的段的选择器载入一个数据段寄存器。
- 用符合标准的、可读的、可执行段的选择器载入数据段寄存器。
- 使用CS覆盖前缀来读取可读、可执行的段，其选择器已经加载在CS寄存器中。

访问数据段的规则也适用于Case 1。Case 2总是有效的，因为设置了符合比特位的段的特权级别实际上与CPL相同，而不管它的DPL是什么。Case 3总是有效的，因为根据定义，CS中的代码段的DPL等于CPL。

###### **限制控制转移**

在80386中，控制传输由JMP、CALL、RET、INT和IRET指令以及异常和中断机制完成。本章只讨论JMP、CALL和RET指令。

处理器确保JMP、CALL或RET指令的目标不超过当前可执行段的限制。该限制缓存在CS寄存器中;因此，近距离传输的保护检查不需要额外的时钟周期。

“far”形式的JMP和CALL的操作数指向其他段;因此，处理器执行权限检查。JMP或调用可以通过两种方式引用另一个段:

- 操作数选择另一个可执行段的描述符。
- 操作数选择call gate描述符。

两个不同的权限级别进入权限检查，检查不使用调用门的控制转移。

- CPL(当前特权级别)。
- 目标段描述子的DPL。

通常CPL等于处理器当前执行的段的DPL。但如果在当前可执行段的描述符中设置了符合条件的比特位，CPL可能大于DPL。处理器在CS寄存器中保存缓存的CPL记录;该值可能与代码段描述符中的DPL不同。

仅当满足下列特权规则之一时，处理器才允许直接对另一个段进行JMP或调用。

- 目标的DPL等于CPL。
- 设置目标码段描述符的符合位，使目标的DPL小于等于CPL。

描述符具有符合位集的可执行段称为符合段。一致性段机制允许共享可以从各种特权级别调用但应该在调用过程的特权级别上执行的过程。

控制转移到符合条件的段时，CPL不会改变。只有在这种情况下，CPL可能不等于当前可执行段的DPL。

大多数代码段都不符合规范。上述特权的基本规则意味着，对于不符合规则的段，控制只能转移到权限级别相同的可执行段，而无需gate。

###### **门描述符守卫程序入口点**

为了在不同特权级别的可执行段之间提供控制转移的保护，80386使用了gate描述符。有四种类型的门描述符:

- Call gates
- Trap gates
- Interrupt gates
- Task gates

本章只讨论 Call gates 。Task gates 用于进程切换。 Trap gates Interrupt gates 用于异常和中断。

调用门描述符可以驻留在GDT或LDT中，但不驻留在IDT中。调用门有两个主要功能:

- 定义过程的入口点。
- 指定入口点的特权级别。

调用门描述符由调用和跳转指令以与代码段描述符相同的方式使用。当硬件识别到目标选择器引用一个门描述符时，指令的操作根据调用门的内容被扩展。

门的选择器和偏移量字段构成了一个指向过程入口点的指针。调用门(call gate)保证所有到另一个段的转换都到达一个有效的入口点。

控制转移指令的远指针操作数不指向目标指令的段和偏移量;相反，指针的选择器部分选择了一个门，而不使用偏移量。

使用四种不同的特权级别来检查通过调用门进行的控制转移的有效性。

- CPL(当前特权级别)。
- 选择器的RPL(请求者特权级别)，用于指定呼叫门。
- 门描述符的DPL。
- 目标可执行段描述符的DPL。

gate描述符的DPL字段确定可以使用gate的特权级别。一个代码段可以有多个过程，供不同的特权级别使用。例如，一个操作系统可能有一些服务打算供应用程序使用，而其他服务可能只打算供其他系统软件使用。

门可用于向数值较小的特权级别或相同特权级别的控制转移(尽管对相同特权级别的转移不需要使用门)。只有调用指令可以使用门来转移到较小的特权级别。JMP指令只能使用门来传输到具有相同特权级别的可执行段或符合该特权级别的段。

- 对于指向不符合条件的段的JMP指令，必须满足以下两个特权规则;否则，将导致一个通用的保护异常。

  ```
  MAX (CPL,RPL) <= gate DPL
  target segment DPL = CPL
  ```

- 对于一个调用指令(或一个符合条件的段的JMP指令)，必须满足以下两个特权规则;否则，将导致一个通用的保护异常。

  ```
  MAX (CPL,RPL) <= gate DPL
  target segment DPL <= CPL
  ```

###### **栈堆切换**

如果调用门的目标代码段与CPL的特权级别不同，则请求进行级别间传输。

为了维护系统完整性，每个特权级别都有一个单独的堆栈。这些栈确保有足够的栈空间来处理特权级别较低的调用。如果没有它们，如果调用过程没有在调用者的堆栈上提供足够的空间，则可信过程将无法正确工作。

处理器通过进程状态段定位这些栈(见图6-8)。每个任务都有一个单独的TSS，从而允许任务具有单独的堆栈。系统软件负责创建tss，并在其中放置正确的栈指针。TSS中的初始栈指针是严格只读的值。处理器在执行过程中不会改变它们。

在使用调用门(call gate)改变特权级别时，通过从任务状态段(TSS)加载一个指针值来选择一个新的栈。处理器使用目标代码段的DPL(新的CPL)来索引PL 0、PL 1或PL 2的初始堆栈指针。

新的栈数据段的DPL必须等于新的CPL;如果没有，则发生堆栈异常。系统软件负责为所使用的所有特权级别创建栈和栈段描述符。每个栈必须包含足够的空间来保存旧的SS:ESP、返回地址以及处理调用可能需要的所有参数和局部变量。

与层次内调用一样，子例程的参数放在栈上。为了使权限转换对被调用过程透明，处理器将参数复制到新堆栈。call gate的count字段告诉处理器从调用者的栈中复制多少个双字(最多31个)到新的栈中。如果计数为0，则不复制任何形参。

处理器在执行级间调用时执行下列与栈相关的步骤。

1. 检查新的栈，确保它足够大，可以容纳参数和连杆;如果不是，则发生堆栈错误，错误码为0。
2. 栈的旧值寄存器SS:ESP被压入到新栈中，作为两个双字。
3. 复制参数。
4. 一个指向调用指令之后的指令的指针(CS:EIP的前一个值)被压入新的栈。SS:ESP的最终值指向新栈上的返回指针。

TSS没有权限级别3堆栈的堆栈指针，因为权限级别3不能由任何其他权限级别的任何过程调用。

可能从另一个特权级别调用的过程，如果需要超过31个双字参数，则必须使用保存的SS:ESP链接来访问上次复制的双字之外的所有参数。

通过call gate的调用不会检查复制到新栈中的单词的值。被调用的过程应该检查每个参数的有效性。后面一节将讨论如何使用ARPL、VERR、VERW、LSL和LAR指令来检查指针值

###### **从程序中退出**

RET指令的“接近”形式在当前代码段内传递控制，因此只受限制检查。对应调用之后的指令偏移量从栈中弹出。处理器确保该偏移量不超过当前可执行段的限制。

RET指令的“far”形式弹出由之前的far调用指令压入栈的返回指针。通常情况下，返回指针是有效的，这是因为它与之前的调用或INT的关系。尽管如此，处理器还是会执行权限检查，因为当前过程可能改变了指针，或未能正确维护栈。CS选择器的RPL通过return指令从栈中弹出，它标识了调用过程的特权级别。

段间返回指令可以改变权限级别，但仅限于权限较低的过程。当RET指令遇到保存的CS值，其RPL在数值上大于CPL时，发生级间返回。这种回归遵循以下步骤:

1. 执行表6-3所示的检查，将CS:EIP和SS:ESP加载到栈中保存的之前的值。
2. 旧的SS:ESP(从当前栈的顶部开始)值根据RET指令中指示的字节数进行调整。得到的ESP值不会与堆栈段的极限进行比较。如果ESP超出了限制，直到下一次栈操作时才会发现这一事实。(返回过程的SS:ESP值不保留;通常，该值与TSS中包含的值相同。)
3. 检查DS、ES、FS和GS段寄存器的内容。如果这些寄存器中的任何一个所引用的段的DPL大于新的CPL(不包括符合CPL的代码段)，段寄存器将加载null选择器(INDEX = 0, TI = 0)。在这种情况下，RET指令本身不发出异常信号;但是，任何试图使用包含null选择器的段寄存器的后续内存引用都会导致通用保护异常。这可以防止权限较低的代码使用权限较高的过程留在段寄存器中的选择器访问权限较高的段。

###### **有些指令是为操作系统保留的**

具有影响保护机制或影响一般系统性能的指令只能由可信过程执行。80386有两类这样的指令:

- 特权指令——用于系统控制的指令。
- 敏感指令——用于I/O和I/O相关活动的指令。

###### **特权指令**

影响系统数据结构的指令只能在CPL为0时执行。如果CPU在CPL大于零时遇到这些指令之一，它会发出一个通用保护异常信号。这些说明包括:

- [CLTS -- Clear Task-Switched Flag](https://pdos.csail.mit.edu/6.828/2018/readings/i386/CLTS.htm)
- [HLT -- Halt Processor](https://pdos.csail.mit.edu/6.828/2018/readings/i386/HLT.htm)
- [LGDT -- Load GDL Register](https://pdos.csail.mit.edu/6.828/2018/readings/i386/LGDT.htm)
- [LIDT -- Load IDT Register](https://pdos.csail.mit.edu/6.828/2018/readings/i386/LGDT.htm)
- [LLDT -- Load LDT Register](https://pdos.csail.mit.edu/6.828/2018/readings/i386/LLDT.htm)
- [LMSW -- Load Machine Status Word](https://pdos.csail.mit.edu/6.828/2018/readings/i386/LMSW.htm)
- [LTR -- Load Task Register](https://pdos.csail.mit.edu/6.828/2018/readings/i386/LTR.htm)
- [MOV to/from CRn -- Move to Control Register n](https://pdos.csail.mit.edu/6.828/2018/readings/i386/MOVRS.htm)
- [MOV to /from DRn -- Move to Debug Register n](https://pdos.csail.mit.edu/6.828/2018/readings/i386/MOVRS.htm)
- [MOV to/from TRn -- Move to Test Register n](https://pdos.csail.mit.edu/6.828/2018/readings/i386/MOVRS.htm)

###### **敏感指令**

处理I/O的指令需要受到限制，但也需要由以非零特权级别执行的过程执行。

###### **指针验证指令**

指针验证是程序错误定位的重要组成部分。指针验证对于维护特权级别之间的隔离是必要的。指针验证由以下步骤组成。

- 检查指针的提供者是否有权访问该段。
- 检查段类型是否适合其预期用途。
- 检查指针是否违反了段的限制。

80386处理器在指令执行过程中自动执行第2和第3项检查，软件必须协助执行第1项检查。非特权指令ARPL就是为此提供的。软件也可以显式执行第2步和第3步来检查潜在的违规(而不是等待异常)。非特权指令LAR、LSL、VERR和VERW就是为此目的而提供的。

LAR (Load Access Rights，加载访问权限)用于验证一个指针是否指向适当的权限级别和类型的一段。LAR对要检查访问权限的描述符有一个操作数选择器。描述符必须在特权级别可见，该特权级别是CPL和选择器RPL的最大值。

LSL (Load Segment Limit)允许软件测试描述符的限制。如果给定的选择器(在内存中或寄存器中)表示的描述符在CPL中可见，LSL会加载指定的32位寄存器，其中包含32位、字节粒度的、未加密的限制，该限制是根据分片的限制字段和该描述符的g位计算得到的。这只能用于段(数据、代码、任务状态和局部描述符表)。无法访问门描述符。

VERR(验证读取)验证一个段以进行读取，如果该段从当前特权级别可读，则加载ZF为1。VERR会检查

- 选择器指向GDT或LDT边界内的描述符。
- 它表示代码或数据段描述符。
- 该段是可读的，具有适当的特权级别。

对数据段和不符合规则的代码段进行权限检查时，DPL必须在数字上大于或等于CPL和选择器的RPL。不检查符合的段的特权级别。

VERW(写验证)提供了与VERR相同的可写性验证功能。和VERR指令一样，如果可写性检查的结果为正，VERW会加载ZF。该指令检查描述符是否在边界内，是否是段描述符，是否可写，其DPL在数值上是否大于或等于CPL和选择器的RPL。无论是否符合规范，代码段都不可写。

###### **指针完整性和RPL**

请求者的特权级别(RPL)特性可以防止不恰当地使用指针，以免在特权级别较低的情况下破坏对特权级别较高的代码或数据的操作。PL字段允许将特权属性分配给选择器。这个特权属性通常表示生成选择器的代码的特权级别。80386处理器自动检查加载到段寄存器中的任何选择器的RPL，以确定RPL是否允许访问。

##### 6.3 页面级保护

与页面相关的保护有两种。

- 可寻址域限制。
- 类型检查。

###### **页表项保存了保护参数**

图6-10突出显示了控制页面访问的pde和pte中的字段。

<img src="https://cdn.staticaly.com/gh/ri-umk/picx-images-hosting@master/xv6/fig6-10.34qb4ib5p080.gif" alt="fig6-10" />

###### **可寻址域限制**

页权限的概念，通过将每个页分配到以下两个级别来实现。

- 管理员级别(U/S=0)——用于操作系统和其他系统软件及相关数据。
- 用户级别(U/S=1)——用于应用程序和数据。

当前级别(U或S)与cpll有关。如果CPL为0、1或2，则处理器在supervisor级别执行。如果CPL为3，则处理器在用户级执行。

当处理器在管理级执行时，所有页都是可寻址的，但当处理器在用户级执行时，只有属于用户级的页是可寻址的。

###### **类型检查**

页寻址级别，定义了两种类型。

- 只读访问(R/W=0)
- 读写访问(R/W=1)

在处理器在管理级执行时，所有页都是可读写的。在处理器在用户级执行时，只有属于用户级并标记为读/写访问的页是可写的。属于管理员级别的页面在用户级别上既不可读也不可写。

###### **合并两级页表的保护**

对于任何一页，其页目录项的保护属性可能与其页表项的保护属性不同。80386通过检查目录和页表中的保护属性，来计算页的有效保护属性。

###### **覆盖页面保护**

某些访问被当作特权级别0的引用来检查，即使CPL = 3:

- LDT, GDT, TSS, IDT参考文献。
- 在环交换调用/INT时访问内部栈。

##### 6.4 页面和段保护结合

当启用分页时，80386首先评估段保护，然后评估页面保护。如果处理器在段或页级别检测到违反保护的情况，则所请求的操作无法继续。发生保护异常。

#### 虚拟、线性和物理地址

在x86术语中，虚拟地址由段选择器和段内的偏移量组成。线性地址是在段翻译之后、页翻译之前得到的地址。物理地址是经过段和页转换后最终得到的，也是最终通过硬件总线发送到RAM的地址。

指针是虚拟地址的“偏移量”部分。在 boot/boot.S，我们安装了一个全局描述符表(GDT)，通过将所有段的基址设置为0和限制设置为0xffffffff来有效地禁用段转换。因此，“选择器”没有作用，线性地址始终等于虚拟地址的偏移量。在实验3中，我们必须与分割进行更多的交互以设置特权级别，但是对于内存转换，我们可以在整个JOS实验室中忽略分割，而只关注页面转换。

#### 练习 3

```
练习3。虽然GDB只能通过虚拟地址访问QEMU的内存，但在设置虚拟内存时能够检查物理内存通常很有用。查看实验室工具指南中的QEMU监控命令，特别是xp命令，它可以检查物理内存。要访问QEMU监视器，在终端中按Ctrl-a c(相同的绑定返回到串行控制台)。

在QEMU监视器中使用xp命令和在GDB中使用x命令检查对应物理地址和虚拟地址的内存，并确保看到相同的数据。


我们打过补丁的QEMU提供了一个info pg命令，它也可能被证明是有用的:它显示了当前页表的紧凑但详细的表示，包括所有映射的内存范围、权限和标志。普通QEMU还提供了info mem命令，该命令概述了映射的虚拟地址范围和权限。
```

回顾该网页[6.828 / 秋季 2018 (mit.edu)](https://pdos.csail.mit.edu/6.828/2018/labguide.html#qemu)

**这块没什么好说的就是`qemu`的使用。**

```bash
xp/Nx paddr -- 查看paddr物理地址处开始的，N个字的16进制的表示结果。
　　info registers -- 展示所有内部寄存器的状态。
　　info mem -- 展示所有已经被页表映射的虚拟地址空间，以及它们的访问优先级。
　　info pg -- 展示当前页表的结构。
```

#### 练习 3 后续的正文

从CPU上执行的代码来看，一旦我们进入保护模式(在boot/boot. s中首先进入的是保护模式)，就无法直接使用线性地址或物理地址。所有的内存引用都解释为虚拟地址，并由MMU转换，这意味着C语言中所有的指针都是虚拟地址。

"MMU" 是指内存管理单元（Memory Management Unit）。MMU 是计算机系统中的一个硬件组件，负责将虚拟地址转换为物理地址，以实现虚拟内存的功能。

JOS内核经常需要将地址操作为不透明值或整数，而不能对它们进行解引用，例如在物理内存分配器中。这些地址有时是虚拟地址，有时是物理地址。为了帮助记录代码，JOS源代码区分了两种情况:类型uintptr_t表示不透明的虚拟地址，而physaddr_t表示物理地址。这两种类型实际上都是32位整数(uint32_t)的同义词，所以编译器不会阻止你将一种类型分配给另一种类型!由于它们是整数类型(而不是指针)，如果试图解引用它们，编译器将发出警告。`uintptr_t ` `physaddr_t` `uint32_t`

在JOS内核中，可以通过将物理地址转换为指针类型来解引用。这是因为JOS内核使用了页表来进行虚拟内存管理，而不是直接使用物理地址。

在JOS内核中，物理地址是通过将其转换为指针类型来进行解引用的。这样可以通过指针操作来访问物理内存中的数据。相比之下，虚拟地址是经过MMU转换后的地址，可以映射到任意的物理内存位置。

因此，在JOS内核中，对于物理地址，可以将其转换为指针类型，并进行解引用操作，以访问物理内存中的数据。而对于虚拟地址，可以直接将其转换为指针类型，并进行解引用操作，以访问虚拟内存中的数据。

在JOS内核中，有时需要读取或修改只知道物理地址的内存。为了解决这个问题，JOS在虚拟地址0xf0000000重新映射了从物理地址0开始的所有物理内存。

为了将物理地址转换为内核可以实际读写的虚拟地址，内核需要在物理地址上加上0xf0000000，以便在重新映射的区域中找到其对应的虚拟地址。为了方便实现这个转换，JOS提供了一个宏函数 `KADDR(pa)`，它将物理地址作为参数，返回对应的虚拟地址。

同理，为了将虚拟地址转换为物理地址，内核需要在虚拟地址上减上0xf0000000，以便在重新映射的区域中找到其对应的物理地址。JOS提供了一个宏函数 `PADDR(va)`，它将虚拟地址作为参数，返回对应的物理地址。

#### 问题

```c
假设下面的JOS内核代码是正确的，那么variable应该是什么类型?
x	uintptr_t	physaddr_t

	mystery_t x;
	char* value = return_a_pointer();
	*value = 10;
	x = (mystery_t) value;
```

回答

```
变量 x 的类型应该是 uintptr_t 或 physaddr_t。由于 x 是用来存储一个地址的不透明值，我们可以选择使用其中一个类型来表示。这取决于 return_a_pointer() 函数返回的是虚拟地址还是物理地址。

如果 return_a_pointer() 函数返回的是虚拟地址，那么 x 的类型应该是 uintptr_t，因为它是用来表示不透明的虚拟地址的。
如果 return_a_pointer() 函数返回的是物理地址，那么 x 的类型应该是 physaddr_t，因为它是用来表示物理地址的。

需要根据具体的上下文和代码逻辑来确定 return_a_pointer() 函数返回的是虚拟地址还是物理地址。根据返回类型来选择适当的类型来声明变量 x。
```

#### 引用次数

在未来的实验室中，您经常将同一个物理内存页同时映射到多个虚拟地址(或多个环境的地址空间)。用户可以在对应物理内存页的字段中保存对每个物理内存页的引用次数。

对于物理内存页，当该计数变为0时，表示该页不再被使用，可以被释放。对于物理内存页的引用计数，可以根据它在所有页表中出现在UTOP以下的次数来进行计算。一般来说，这些页表中的映射大多是由内核在启动时建立的，不应该被释放，因此不需要进行引用计数。

只有当物理内存页不再被任何页表所引用时，才会将其引用计数减为0，并释放该页。

此外，引用计数还可以用于跟踪指向页目录页的指针数目，以及页目录对表页的引用次数。这样可以确保在释放页目录页或表页之前，没有任何指针或引用指向它们，避免出现悬空指针或内存泄漏的情况。

 `pp_ref` `struct PageInfo` `UTOP`

在使用`page_alloc`时要小心。它返回的页的引用计数总是0，因此只要对返回的页做了一些操作(比如将其插入到页表中)，就应该增加`pp_ref`的值，确保正确的引用。有时这由其他函数处理(例如，`page_insert`)，有时调用`page_alloc`的函数必须直接完成。

#### 练习4（二级页表）

**页表管理**

现在我们将编写一组例程来管理页表:插入和删除线性到物理的映射，以及在需要时创建页表页。

```
在文件kern/pmap.c中，必须实现下列函数的代码。

pgdir_walk ()
boot_map_region ()
page_lookup ()
page_remove ()
page_insert ()

Check_page()在其中调用，用于测试页表管理例程。在继续之前，您应该确保它报告成功。mem_init ()
```

**表格**

| **名称**      | **参数**                      | 作用                                                  |
| ------------- | ----------------------------- | ----------------------------------------------------- |
| PADDR         | 内核**虚拟地址**kva           | 将内核虚拟地址kva转成对应的物理地址                   |
| KADDR         | **物理地址**pa                | 将物理地址pa转化为内核虚拟地址                        |
| page2pa       | 页信息结构**struct PageInfo** | 通过空闲页结构得到这一页起始位置的物理地址            |
| pa2page       | **物理地址**pa                | 通过物理地址pa获取这一页对应的页结构体struct PageInfo |
| page2kva      | 页信息结构**struct PageInfo** | 通过空闲页结构得到这一页起始位置的虚拟地址            |
| PDX           | **线性地址**la                | 获得该线性地址la对应的页目录项索引                    |
| PTX           | **线性地址**la                | 获得该线性地址la在二级页表中对应的页表项索引          |
| PTE_ADDR(pte) | 页表项或页目录项的**值**      | 获得对应的页表基址或者物理地址基址(低12位为0)         |

**PageInfo**

```c
来自于 memlayout.h
struct PageInfo {
	// Next page on the free list.
	struct PageInfo *pp_link;

// pp_ref是指针的计数(通常是页表项)
//指向该页，表示使用page_alloc分配的页。
//启动时使用pmap.c分配的页
// boot_alloc没有有效的引用计数字段。

	uint16_t pp_ref;
};
```



##### `pgdir_walk`

在给定的页目录 `pgdir` 中查找并返回虚拟地址 `va` 对应的页表项。

**代码**

```
//给定 pgdir ，一个指向页面目录的指针，pgdir_walk将返回
//一个指向页表项(PTE)的指针，表示线性地址'va'。
//这需要遍历两级页表结构
//
//相关的页表页可能还不存在。
//如果这是true，并且create == false，那么pgdir_walk返回NULL。
//否则，pgdir_walk用page_alloc分配一个新的页表页。
// -如果分配失败，pgdir_walk返回NULL。
// -否则，新页的引用计数将递增，递增后页面被清除
// pgdir_walk返回一个指向新页表页的指针。
//
//提示1:你可以将PageInfo *转换为的物理地址
//使用kern/pmap.h中的page2pa()函数指向的页面
//
//提示2:x86 MMU检查两个页面目录的权限位
//和页表，所以在页面中保留权限是安全的目录过于宽松。
//
//提示3:在inc/mmu.h中查找操作页表和页目录项的有用宏。
```

`dir` 是一个指向页目录项的指针。通过将页目录的起始地址 `pgdir` 加上虚拟地址 `va` 对应的页目录索引 `PDX(va)`，可以计算出虚拟地址 `va` 对应的页目录项的地址。

```c
// 两段代码
/************
页目录的起始地址 + 虚拟地址 va 对应的页目录索引---->虚拟地址 va 对应的页目录项的地址。
************/
pde_t *dir = pgdir + PDX(va);
/************
页表的起始物理地址转为虚拟地址+在页表项中的索引---->一个指向页表项的指针
************/
return (pte_t *) KADDR(PTE_ADDR(*dir)) + PTX(va);
```

```c
//具体代码
pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
	// Fill this function in
	pde_t *dir = pgdir + PDX(va);
	if (!(*dir & PTE_P) && create == false){
		return NULL;
	} else if (!(*dir & PTE_P) && create != false){
		struct PageInfo *pp = page_alloc(1);
		if (pp == NULL){
			return NULL;
		} else {
			pp->pp_ref++;
			*dir = page2pa(pp) | PTE_P | PTE_W | PTE_U;
			return (pde_t *)page2kva(pp) + PTX(va);
		}
	}
	return (pte_t*)KADDR(PTE_ADDR(*dir)) + PTX(va);
}
```



##### `boot_map_region`

启动阶段进行内存映射（将虚拟地址和物理地址进行映射）,将虚拟地址范围映射到物理地址上，并设置相应的权限。也就是填充页表的值。

**注释**

```
//在以pgdir为根的页表中，将虚拟地址空间映射到物理地址空间。
//Size是PGSIZE的倍数，va和pa都是页面对齐的。
//使用权限位perm|PTE_P
//
//该函数仅用于建立上层的静态映射。
//因此，它不应该改变映射页上的pp_ref字段。
//
//提示:TA解决方案使用pgdir_walk
```

**步骤**

```
首先，通过循环遍历每个虚拟地址所对应的页表项。循环次数为 size / PGSIZE。

在每次循环中，首先调用 pgdir_walk 函数来获取虚拟地址 va 对应的页表项的地址。如果返回的页表项地址为 NULL，则表示无法获取或创建页表项，直接跳过当前循环。

如果成功获取到页表项的地址，则将物理地址 pa 与相应的权限 perm | PTE_P 进行组合，得到新的页表项内容。这里的 PTE_P 是设置页表项的存在标志。

将新的页表项内容写入页表项地址所指向的内存位置，完成内存映射。
```

**代码**

```c
static void
boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
{
	// Fill this function in
	for (size_t i = 0; i < size; i++){
		pte_t *pte = pgdir_walk(pgdir, (void *)va, 1);
		if(pte == NULL){
			panic("run out of memory!");
		} else {
			*pte = pa | perm | PTE_P;
		}
		pa += PGSIZE;
		va += PGSIZE;		 
	} 	
}
```

**两段代码**

```
//是用来获取虚拟地址 va 对应的页表项的指针。
pte_t *pte = pgdir_walk(pgdir, (void *)va, 1);
//将物理地址 pa 与权限 perm 进行位运算，并将结果写入页表项中。
*pte = pa | perm | PTE_P;
```



##### `page_lookup` 

查找一个虚拟地址对应的页。

**注释**

```
//返回映射到虚拟地址'va'的页。
//如果pte_store不为0，则将该页的pte地址存储在其中。
//该函数由page_remove使用，可用于验证系统调用参数的页面权限，但大多数调用者不应该使用该函数。
//如果没有页映射到va，则返回NULL,
//提示:TA解决方案使用了pgdir_walk和pa2page。
```

感觉这个得改一下顺序，看的歧义了。

```
//如果pte_store不为0，则将该页的pte地址存储在其中。
//该函数由page_remove使用，可用于验证系统调用参数的页面权限，但大多数调用者不应该使用该函数。
//如果没有页映射到va，则返回NULL,
//返回映射到虚拟地址'va'的页。
//提示:TA解决方案使用了pgdir_walk和pa2page。
```

**一段代码**

```
(pte == NULL || !(*pte & PTE_P))
```

纠结了半天要不要写上后一个条件，想了想写上了。`pte` 为 NULL 或者页表项的标志位 `PTE_P` 未被设置，即表示**没有找到对应的页表项**。这两者还是有些区别的，虽然感觉用到的地方很少就是了。

**代码**

```
struct PageInfo *
page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
{
	// Fill this function in
	pte_t *pte = pgdir_walk(pgdir, va, 0);
	if (pte_store != 0){
		*pte_store = pte;
	} 
	if (pte == NULL || !(*pte & PTE_P)){
		panic("Page directory not found");
		return NULL;
	}	
	return pa2page(PTE_ADDR(*pte));
}

```



##### `page_remove`

取消一个映射关系

```
//
//解除映射虚拟地址'va'的物理内存页。
//如果该地址没有物理内存页，则不执行任何操作
//
//说明:
// -物理内存页上的引用计数应该递减。
// -如果refcount达到0，则释放物理内存页。
// - pg表中对应` va `的条目应该被设置为0。
//(如果存在这样的PTE)
// -如果从页表删除一项，TLB必须失效。
//
//提示:TA解决方案是使用page_lookup、tlb_invalidate和page_decref实现的。
```

**目标总结**

```
/*
	取消虚拟地址va映射到的物理页
	物理内存页的引用计数应该减少(为0是释放)
	这个地址对应的页表项（如果有）应该清空
	TLB失效
*/
```

相关代码看源码`tlb_invalidate` `page_decref`，就2,3行。

**代码**

```
void
page_remove(pde_t *pgdir, void *va)
{
	// Fill this function in
	pte_t *pte_store;
	struct PageInfo* pp = page_lookup(pgdir, va, &pte_store);
	if (pp){
		*pte_store = 0;
		page_decref(pp);
		tlb_invalidate(pgdir, va);
	}	
}
```

吐槽：这个变量没有的话咱们可以设一个。



##### `page_insert`

将一个物理页 `pp` 映射到给定的虚拟地址 `va` 上，并设置相应的权限 `perm`。

**注释**

```
//将物理页'pp'映射到虚拟地址'va'。
//页表项的权限(低12位)应该设置为'perm|PTE_P'
//
//要求
// -如果已经有一个页映射到'va'，那么应该执行是page_remove()。
// -如果有必要，应该按需分配一个页表并插入到` pgdir `中。
// - pp->如果插入成功，pp_ref应该加1。
// -如果页之前存在于'va'，则TLB必须无效。
//
//边角情况提示:请确保考虑当同一个pp被重新插入到同一个pgdir中的同一个虚拟地址时会发生什么。
//但是，尽量不要在代码中区分这种情况，因为这经常会导致微妙的bug;有一种优雅的方法可以在一个代码路径中处理所有内容。
//
//返回:
// 0表示成功
// -E_NO_MEM，如果无法分配页表
//
//提示:TA解决方案是使用pgdir_walk、page_remove和page2pa实现的。
```

**问题回复**

```
在处理同一个 pp 被重新插入到同一个 pgdir 中的同一个虚拟地址时，确实可能会出现一些微妙的 bug。为了避免这种情况，可以采用一种优雅的方法，在一个代码路径中处理所有情况。

一种常见的方法是使用原子操作来确保在并发环境下的一致性。可以使用原子操作来执行以下操作：

检查给定虚拟地址 va 是否已经映射到了物理页 pp。
如果已经映射，则更新页表项的相关信息。
如果尚未映射，则执行插入操作。
```

**代码**

梳理先干嘛后干嘛好乱啊。这次几乎没啥是自己写的，，，

```c
/*
	将物理地址pp映射到虚拟地址va 权限设置为 perm|PTE_P
	如果va以及和一个物理地址关联了，那么应该使用page_remove()并刷TLB
	pp所在的物理页的引用计数增加
*/
int
page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)
{
	// Fill this function in
	// 得到对应的页表项，如果有必要申请新的页。
	pte_t *pte = pgdir_walk(pgdir, va, 1);
	if (!pte){
    // 没有足够内存创建新的页表项
		return -E_NO_MEM;
	}
    // 增加物理页 pp 的引用计数，以确保在映射存在期间物理页不会被释放。
	pp->pp_ref++;
	
    // 如果页表项已经存在，则先移除旧的映射
    // 刷新 TLB
	if (*pte & PTE_P){
		page_remove(pgdir, va);
		tlb_invalidate(pgdir, va);
	} 
	
    // 设置页表项的值，包括物理页的地址和权限
	*pte = page2pa(pp) | PTE_P | perm;
	return 0;	
}
```

映射的本质

```
得到虚拟地址页表项，页表项上加上物理地址和权限
如：

pte_t *pte = pgdir_walk(pgdir, va, 0);
*pte = page2pa(pp) | PTE_P | perm;

pte_t *pte = pgdir_walk(pgdir, (void *)va, 1);
*pte = pa | perm | PTE_P;
```

写完了，虚拟内存和物理内存这块，但是感觉自己是个菜狗。

##### 改bug

1.之前还感觉理解了结果还是错的

```
正确的
	pte_t *pte = pgdir_walk(pgdir, va, 1);
错误的
	pte_t *pte = pgdir_walk(pgdir, va, 0);
```

2.

```
正确的
pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
	// Fill this function in
	pde_t *dir = pgdir + PDX(va);
	if (!(*dir & PTE_P) && create == false){
		return NULL;
	} else if (!(*dir & PTE_P) && create != false){
		struct PageInfo *pp = page_alloc(1);
		if (pp == NULL){
			return NULL;
		} else {
			pp->pp_ref++;
			*dir = page2pa(pp) | PTE_P | PTE_W | PTE_U;
			return (pde_t *)page2kva(pp) + PTX(va);
		}
	}
	return (pte_t*)KADDR(PTE_ADDR(*dir)) + PTX(va);
}
错误的
pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
	// Fill this function in
	pde_t *dir = pgdir + PDX(va);
	if (!(*dir & PTE_P) && create == false){
		return NULL;
	} else if (!(*dir & PTE_P) && create != false){
		struct PageInfo *pp = page_alloc(1);
		if (pp == NULL){
			return NULL;
		} else {
			pp->pp_ref++;
			*dir = page2pa(pp) | PTE_P | PTE_W | PTE_U;
		}
	}
	return (pde_t *)page2kva(pp) + PTX(va);
}
```

### 第 3 部分：内核地址空间

JOS将处理器的32位线性地址空间分成两部分。我们将在实验3中开始加载和运行的用户环境(进程)将控制下层的布局和内容，而内核始终保持对上层的完全控制。该分界线由`inc/memlayout.h`中的`ULIM`符号定义，为内核分配了大约256MB的虚拟地址空间。

这解释了为什么我们在实验1中需要向内核提供如此高的链接地址:否则内核的虚拟地址空间中就没有足够的空间同时映射到下面的用户环境中。

#### 权限和故障隔离

在JOS操作系统中，为了确保内核和用户环境之间的隔离和安全性，我们使用了x86页表中的权限位来限制用户代码对地址空间的访问。

具体来说，我们使用了以下权限位设置：

1. 对于ULIM之上的内存，用户环境没有权限访问，而内核可以读写这些内存。这样做是为了确保内核对这部分内存的完全控制，防止用户环境越界访问内核的数据。
2. 对于地址范围[UTOP, ULIM)，内核和用户环境具有相同的权限，即可以读取但不能写入。这个地址范围用于向用户环境公开只读的内核数据结构，以便用户环境可以读取这些数据结构但不能修改它们。
3. 最后，UTOP以下的地址空间是供用户环境使用的。用户环境可以设置访问此内存的权限，包括读、写和执行权限，以满足其特定的需求。

需要注意的是，可写权限位（PTE_W）同时影响用户代码和内核代码。这是因为内核和用户环境共享同一份代码，所以对于这部分代码，内核和用户环境具有相同的权限。因此，在设计和实现用户环境时，需要特别注意确保代码的正确性和安全性。

#### 初始化内核地址空间

现在我们将在top之上建立地址空间:地址空间的内核部分。`Inc/memlayout.h`显示了你应该使用的布局。我们将使用刚才编写的函数建立适当的线性到物理映射。

#### 练习5

```
在调用check_page()之后，补齐mem_init()中缺失的代码。
你的代码现在应该传递check_kern_pgdir(),check_page_installed_pgdir()检查。
```

**相关的两段代码**

```c
//用于检查内核页表的正确性。
static void check_kern_pgdir(void)
//使用已安装的kern_pgdir检查page_insert、page_remove和c
static void check_page_installed_pgdir(void)
```

**看看有什么菜**

```c
	uint32_t cr0;
	size_t n;
	kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
	memset(kern_pgdir, 0, PGSIZE);
	pages = (struct PageInfo *) boot_alloc (npages * sizeof(struct PageInfo));
	memset(pages, 0, npages * sizeof(struct PageInfo));
```

**用到的函数**

```c
static void
boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
{
	// Fill this function in
	size_t num = size /PGSIZE;
	for (size_t i = 0; i < num; i++){
		pte_t *pte = pgdir_walk(pgdir, (void *)va, 1);
		if(pte == NULL){
			panic("run out of memory!");
		} else {
			*pte = pa | perm | PTE_P;
		}
		pa += PGSIZE;
		va += PGSIZE;		 
	} 	
}
```

**三段代码**

1. 用户栈（初始化内核地址空间）

```
//用户在线性地址更新时只读映射` pages `
//权限:
// -更新时的新图像——kernel R, user R
//(即。PTE_U | PTE_P)
// -页本身——内核RW，用户无
```

2. 内核栈（初始化内核地址空间）

```
//使用 bootstack 引用的物理内存作为内核栈。
//内核栈从虚拟地址KSTACKTOP向下增长
//我们考虑从[KSTACKTOP- ptsize, KSTACKTOP)开始的整个范围
//作为内核栈，但将其分成两部分:
// * [KSTACKTOP- kstksize, KSTACKTOP)——由物理内存支持
// * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE)——不支持;因此,如果
//内核溢出其栈，它将出错而不是覆盖内存。被称为“守卫页”。
//权限:内核RW，用户无
```

3. 映射整个内核，wc

```
//////////////////////////////////////////////////////////////////////
//映射KERNBASE的所有物理内存。
// VA的范围[KERNBASE, 2^32)应该映射到
// PA范围[0,2 ^32 - KERNBASE]
//我们可能没有2^32 - KERNBASE字节的物理内存，但是我们只是设置了映射。
//权限:内核RW，用户无
```

**代码**

```c
boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U| PTE_P);

boot_map_region(kern_pgdir, KSTACKTOP - KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W| PTE_P);

boot_map_region(kern_pgdir, KERNBASE, 0xffffffff - KERNBASE, 0, PTE_W| PTE_P);

```

<img src="https://cdn.staticaly.com/gh/ri-umk/picx-images-hosting@master/xv6/2067071-20211101200421491-1459782411.72ihhys3et80.webp" alt="2067071-20211101200421491-1459782411" />

完结撒花，但是make grade过不去不知道为什么。



#### 问题

1. 此时，页面目录中的哪些条目(行)已经填充?它们映射什么地址，指向哪里?

   详见memlayout.h，更详细些追踪pmap，这里就懒得说（看）了。

2. 我们已经将内核和用户环境放在同一个地址空间中。为什么用户程序不能读写内核内存?保护内核内存的具体机制是什么?

   详见练习2中关于页保护的部分，就是特权位的设置，相关特权位查看该文档的工具这块，或者查看mmu.h中对于特权数的设置。机制叫可寻址域限制。类型检查。

3. 这个操作系统可以支持的最大物理内存是多少?为什么?

   pages 这个数组只能占用最多 4MB 的空间，而每个 PageInfo 占用 8Byte，也就是说最多只能有512k页，每页容量4kB，总共最多 2GB。

4. 如果我们有最大的物理内存，那么管理内存的空间开销是多少呢?这些开销是如何分解的?

   当我们达到最高物理内存时，显然1 个 page_dir 和 1024 个 page_table 都在工作，page_dir 和 page_table 每个 entry 都是 4 byte，且都有1024个 entry。所以一共 (1024 + 1) * 4kB = 4100 kB，还要加上 pages 数组所占用的 4MB，一共 8196 kB。如果要削减这个开支，可以使每个页的容量变大，例如变为 8kB 。

5. 重新查看kern/entry.s 和 kern/entrypgdir.c 的页表设置。在我们打开分页后，EIP仍然是一个很小的数字(略高于1MB)。我们在什么时候过渡到在KERNBASE之上的EIP上运行?在启用分页和在KERNBASE之上的EIP开始运行之间，是什么使我们能够在低EIP下继续执行?为什么这种转变是必要的?

   语句`jmp *%eax`即转到 eax 所存的地址执行，在这里完成了跳转。relocated 部分代码主要设置了栈指针以及调用 kern/init.c。由于在 kern/entrypgdir.c 中将 0~4MB 和 KERNBASE ~ KERNBASE + 4 MB 的虚拟地址都映射到了 0~4MB 的物理地址上，因此无论 EIP 在高位和低位都能执行。必需这么做是因为如果只映射高位地址，那么在开启分页机制的下一条语句就会crash。

```
//未完成 make grade 可能有其他锅，可以再参考以下网页
https://www.jianshu.com/p/3be92c8228b6
```

结尾吐槽：好好改了，还是过不去，猜测是前期合并之类的状况出了问题，代码过不去。懂了就行，你说是吧。



## lab 3

**用户环境**

1. 用户环境建立，可以加载用户ELF文件并执行。（目前还没有文件系统，需要在内核代码硬编码需要加载的用户程序）
2. 建立异常处理机制，异常发生时能从用户态进入内核进行处理，然后返回用户态。
3. 借助异常处理机制，提供系统调用的能力。

**参考**

```
https://www.cnblogs.com/gatsby123/p/9838304.html
https://zhuanlan.zhihu.com/p/594129926	这个比较抽象些
```

**前言部分**

在本实验中，您将实现运行受保护的用户态环境(即“进程”)所需的基本内核设施。您将增强JOS内核，以设置数据结构来跟踪用户环境、创建单个用户环境、将程序映像加载到环境中并启动它运行。您还将使JOS内核能够处理用户环境发出的任何系统调用，并处理它引起的任何其他异常。

注意:在本实验中，环境和进程这两个术语是可以互换的——它们都指的是允许你运行程序的抽象。我们引入“环境”这个术语，而不是传统的“进程”，是为了强调JOS环境和UNIX进程提供了不同的接口，并且没有提供相同的语义。

此次实验涉及的文件

```
inc/	
1.env.h
Public definitions for user-mode environments
2.trap.h	
Public definitions for trap handling
3.syscall.h
Public definitions for system calls from user environments to the kernel
4.lib.h
Public definitions for the user-mode support library

kern/	
1.env.h
Kernel-private definitions for user-mode environments
2.env.c
Kernel code implementing user-mode environments
3.trap.h
Kernel-private trap handling definitions
4.trap.c
Trap handling code
5.trapentry.S
Assembly-language trap handler entry-points
6.syscall.h
Kernel-private definitions for system call handling
7.syscall.c
System call implementation code

lib/	
1.Makefrag	
Makefile fragment to build user-mode library, obj/lib/libjos.a
2.entry.S
Assembly-language entry-point for user environments
3.libmain.c
User-mode library setup code called from entry.S
4.syscall.c
User-mode system call stub functions
5.console.c
User-mode implementations of putchar and getchar, providing console I/O
5.exit.c
User-mode implementation of exit
6.panic.c
User-mode implementation of panic

user/	*	Various test programs to check kernel lab 3 code
```

### lab2的工具

本实验涉及的一些常用函数，宏

**PageInfo**

```c
来自于 memlayout.h
struct PageInfo {
	// Next page on the free list.
	struct PageInfo *pp_link;

// pp_ref是指针的计数(通常是页表项)
//指向该页，表示使用page_alloc分配的页。
//启动时使用pmap.c分配的页
// boot_alloc没有有效的引用计数字段。

	uint16_t pp_ref;
};
```

**函数**

这里有几个很有用的地址变换工具，具体实现可以查看`mmu.h`和`pmap.h`，提前掌握这些小工具对于理解地址变换和后续的程序编写有很大帮助。

| **名称**      | **参数**                      | 作用                                                  |
| ------------- | ----------------------------- | ----------------------------------------------------- |
| PADDR         | 内核**虚拟地址**kva           | 将内核虚拟地址kva转成对应的物理地址                   |
| KADDR         | **物理地址**pa                | 将物理地址pa转化为内核虚拟地址                        |
| page2pa       | 页信息结构**struct PageInfo** | 通过空闲页结构得到这一页起始位置的物理地址            |
| pa2page       | **物理地址**pa                | 通过物理地址pa获取这一页对应的页结构体struct PageInfo |
| page2kva      | 页信息结构**struct PageInfo** | 通过空闲页结构得到这一页起始位置的虚拟地址            |
| PDX           | **线性地址**la                | 获得该线性地址la对应的页目录项索引                    |
| PTX           | **线性地址**la                | 获得该线性地址la在二级页表中对应的页表项索引          |
| PTE_ADDR(pte) | 页表项或页目录项的**值**      | 获得对应的页表基址或者物理地址基址(低12位为0)         |

**标志**

```assembly
//页表/目录项标志

#define pte_p 0x001 //存在
#define pte_w 0x002 //可写
#define pte_u 0x004 //用户
#define pte_pwt 0x008 // Write-Through
#define pte_pcd 0x010 //禁用cache
#define pte_a 0x020 //访问
#define pte_d 0x040 //脏
#define pte_ps 0x080 //页大小
#define pte_g 0x100 //全局
```





### Part A: 用户环境和异常处理

#### 环境状态

**`env.h`中的变量**

```
struct env中的环境状态值:
    ENV_FREE：环境空闲，可以被分配和使用。
    ENV_DYING：环境正在终止的过程中。
    ENV_RUNNABLE：环境可以被调度运行。
    ENV_RUNNING：环境正在运行。
    ENV_NOT_RUNNABLE：环境不能被调度运行。

特殊的环境类型
    ENV_TYPE_USER：特殊环境类型，表示用户环境。
    
struct Env:
    env_tf：保存了环境的寄存器状态。
    env_link：指向下一个空闲的环境。
    env_id：唯一的环境标识符。
    env_parent_id：当前环境的父环境的标识符。
    env_type：表示环境的特殊类型。
    env_status：环境的状态，使用上述枚举类型中的常量。(上面那5个)
    env_runs：环境已经运行的次数。
    env_pgdir：环境的页目录的内核虚拟地址。
```

**lab 3 中给出的解释**

```
env_tf:
该结构定义在inc/trap.h中，保存了在环境不运行时为该环境保存的寄存器值:即在内核或其他环境运行时。内核在从用户态切换到核心态时保存了这些数据，以便稍后可以从中断的位置恢复环境。
env_link:
这是一个链接到下一个。指向列表中的第一个空闲环境。
env_id:
内核在这里存储了创建该环境的环境的信息。通过这种方式，环境可以形成一个“族谱”，这将有助于做出关于哪些环境可以对谁执行什么操作的安全决策。
env_type:
这用于区分特殊环境。对于大多数环境来说，是这样的。我们将在后面的实验室中介绍更多用于特殊系统服务环境的类型。
env_status:
这个变量包含下列值之一:
    ENV_FREE：该结构是未运行的，因此在envenv_free_list中
    ENV_DYING：该结构表示等待在处理器上运行的环境。
    ENV_RUNNABLE：该结构表示当前运行的环境。
    ENV_RUNNING：该结构表示当前活动的环境，但目前还没有准备好运行
    ENV_NOT_RUNNABLE：结构表示一个僵尸环境。僵尸环境将在下次捕获到内核时被释放。
env_pgdir:
该变量保存了该环境的页目录的内核虚拟地址。
```

JOS环境耦合了“线程”和“地址空间”的概念。线程主要由保存的寄存器(该字段)定义，地址空间由所指向的页目录和页表定义。为运行环境，内核必须用保存的寄存器和适当的地址空间设置CPU。`env_tf env_pgdir`

我们的操作类似于xv6。这两个结构体都将环境(即进程)的用户态寄存器状态保存在一个结构中。在JOS，各个环境不像xv6中的进程那样有自己的内核栈。同一时间内核中只能有一个活动的JOS环境，因此JOS只需要一个内核栈。(安全，但是好鸡肋啊)

#### 分配环境数组:练习 1

**要求**

在实验2中，您为数组分配了内存，这是一个内核用来跟踪哪些页是空闲的，哪些页是空闲的表。现在需要进一步修改，以分配一个类似的数组结构。`mem_init() pages[] mem_init() Envenvs`

```
练习1。修改kern/pmap.c来分配和映射数组。这个数组由分配的结构的实例组成，与分配数组的方式非常相似。与数组一样，内存后备也应该映射为只读用户(定义在inc/memlayout.h中)，以便用户进程可以从该数组中读取。mem_init()
你应该运行代码并确保成功。check_kern_pgdir ()
```

**代码前面的注释**

```
让 envs 指向一个大小为 NENV 且为 struct Env 的数组。
```

```
用户在线性地址UENVS处将 envs 数组映射为只读
(即。perm = PTE_U | PTE_P)。

权限:
    - UENVS的新映像——kernel R, user R
    - envs本身——内核RW，用户NONE
```

**代码**

就像之前的`lab2`的练习一样，分配个数组，根据题的要求，看着`memlayout.h`来就行。

具体是：建立个`Env`页表.

分配一个`struct Env`的数组并将其存储在` envs `中。内核使用该数组来跟踪物理内存页,初始化结构体 `PageInfo`。然后就是建立虚拟内存和物理内存映射。

##### `mem_init:`

```c
mem_init:
	envs = (struct Env *) boot_alloc (NENV * sizeof(struct Env));
	memset(envs, 0, NENV * sizeof(struct Env));
	
	boot_map_region(kern_pgdir, UENVS, PTSIZE, PADDR(envs), PTE_U| PTE_P);	
	
//外面记得声明,放这里吧。
// These variables are set in mem_init()
pde_t *kern_pgdir;		// Kernel's initial page directory
struct PageInfo *pages;		// Physical page state array
static struct PageInfo *page_free_list;	// Free list of physical pages
struct Env* envs;		//lab3 Environment page array
```

#### 创建和运行环境:练习 2

**要求**

现在，我们将在`kern/env.c`中编写运行用户环境所需的代码。因为我们还没有文件系统，我们将设置内核加载一个嵌入到内核本身中的静态二进制映像。jos将该二进制文件作为ELF可执行映像嵌入到内核中。

在`kern/init.c`中，你将看到在环境中运行这些二进制映像的代码。但是，用于建立用户环境的关键功能还不完整;你需要填写它们。

```
在文件env.c中，完成以下函数的编码:
env_init ()
初始化数组中的所有结构，并将它们添加到。调用，它将分段硬件配置为特权级别0(内核)和特权级别3(用户)的单独段。

env_setup_vm ()
为新环境分配一个页目录，并初始化新环境地址空间的内核部分。

region_alloc ()
为环境分配和映射物理内存

load_icode ()
您将需要解析ELF二进制映像，就像启动加载程序已经做的那样，并将其内容加载到新环境的用户地址空间中。

env_create ()
分配一个环境，并调用该函数将ELF二进制文件加载到环境中

env_run ()
启动在用户模式下运行的给定环境。

在编写这些函数时，您可能会发现新的cprintf动词很有用——它打印与错误代码相对应的描述。例如:%e

r = -E_NO_MEM;
Panic ("env_alloc: %e"， r);

会报出“env_alloc: out of memory”。
```

**调用步骤**

下面是直到调用用户代码为止的代码调用图。确保你理解了每个步骤的目的。

```
开始(kern / entry.S)
i386_init (kern / init.c)
cons_init
mem_init
env_init
Trap_init(此时仍然不完整)
env_create
env_run
env_pop_tf
```



##### `env_init ()`

**目的**

初始化数组中的所有结构。调用：它将分段硬件配置为特权级别0(内核)和特权级别3(用户)的单独段。

**注释**

```c
//将'envs'中的所有环境标记为空闲，将其env_id设置为0，并将它们插入到env_free_list中。

//确保空闲列表中的环境与envs数组中的顺序相同(即第一次调用env_alloc()时返回envs[0])。
```

**代码**

```c
void
env_init(void)
{
	// Set up envs array
	// LAB 3: Your code here.
	for(int i = NENV - 1; i >= 0; i--){
		envs[i].env_status = ENV_FREE;
		envs[i].env_id = 0;
		envs[i].env_link = env_free_list;
        env_free_list = &envs[i];
	}
	// Per-CPU part of the initialization
	env_init_percpu();
}
```

这里要注意一下顺序，反向遍历。

```c
//将当前环境的env_link字段设置为env_free_list的值。
//将空闲列表的头部指针env_free_list更新为当前环境的地址。
//每次初始化一个环境时，它会被链接到空闲列表的头部，成为新的头部。
		envs[i].env_link = env_free_list;
        env_free_list = &envs[i];
        
//其实就是环境成为新的头部。
		envs[i].env_link = &envs[i];
```



##### `env_setup_vm()`

**目的**

为新环境分配一个页目录，并初始化新环境地址空间的内核部分。

**注释**

```c
//为环境e初始化内核虚拟内存布局。
//分配一个页目录，相应地设置e->env_pgdir，并初始化新环境地址空间的内核部分。
//暂时不要将任何东西映射到环境虚拟地址空间的用户部分。
//
//成功时返回0，错误时返回< 0错误包括:
//如果无法分配页目录或表，则- e_no_mem

//现在，设置e->env_pgdir并初始化page目录。
//
//提示:
// -所有环境的VA空间在UTOP上都是相同的(除了UVPT，我们在下面设置)。
//查看inc/memlayout.h了解权限和布局。
//你可以使用kern_pgdir作为模板吗?提示:是的。
//(确保你在实验2中设置了正确的权限。)
// - UTOP下面的初始VA为空。
// -不再需要调用page_alloc
// -注意:一般来说，仅在顶层映射的物理页不维护pp_ref，但env_pgdir是个例外——您需要增加env_pgdir的pp_ref才能使env_free正确工作。
// - kern/pmap.h中的函数很方便。
```

**代码**

```c
	e->env_pgdir = page2kva(p);
	memcpy(e->env_pgdir, kern_pgdir, PGSIZE);
	p->pp_ref++;
```

这里的`kern_pgdir`作为模板是这个啊，`memcpy(e->env_pgdir, kern_pgdir, PGSIZE);`也就是页目录值是完全一样的。



##### `region_alloc()`

**目的**

为环境分配和映射物理内存

**注释**

```c
//为环境env分配len字节的物理内存，并将其映射到环境地址空间中的虚拟地址va。
//不归零或以任何方式初始化映射页。
//页应该由用户和内核可写。
//如果任何分配尝试失败，则返回Panic

//实验3:这里是你的代码
//(但只有当你在load_icode中需要它时才会这样。)
//
//提示:如果调用者可以传递不按页面对齐的` va `和` len `值，那么使用region_alloc会更容易。
//你应该向下舍入va，向上舍入(va + len)。
//(注意边界情况!)
```

**代码**

```c
static void
region_alloc(struct Env *e, void *va, size_t len)
{
	// LAB 3: Your code here.
	// (But only if you need it for load_icode.)
	//
	// Hint: It is easier to use region_alloc if the caller can pass
	//   'va' and 'len' values that are not page-aligned.
	//   You should round va down, and round (va + len) up.
	//   (Watch out for corner-cases!)
	void *start=ROUNDDOWN(va,PGSIZE),*end=ROUNDUP(va+len,PGSIZE);
	for (void * addr=start;addr<end;addr+=PGSIZE){
		struct PageInfo* p=page_alloc(0);
		if(p==NULL){
			panic("region alloc failed: No more page to be allocated.\n");
		}
		else {
			if(page_insert(e->env_pgdir, p, addr, PTE_U | PTE_W)==-E_NO_MEM){
				panic("region alloc failed: page table couldn't be allocated.\n");
			}
		}
	}
}
```

找了找ROUNDUP返回什么类型，想找函数原型没找见啊。用的都是过去的函数，但是保不齐用错，比如想用`boot_map_region`.

区别点：`boot_map_region`用于内核初始化阶段的静态映射，而`region_alloc`用于运行时动态映射用户环境的页表。



##### `load_icode()`

**目的**

解析ELF二进制映像，就像启动加载程序已经做的那样，并将其内容加载到新环境的用户地址空间中。（好多注释啊）

**注释**

```c
//设置用户进程的初始程序二进制、栈和处理器标志。
//该函数仅在内核初始化期间，即运行第一个用户态环境之前调用
//
//该函数从ELF程序头中指定的适当虚拟地址开始，将ELF二值映像中的所有可加载段加载到环境的用户内存中。
//同时，它将这些段的任何部分清除为零，这些部分在程序头中标记为映射，但实际上没有出现在ELF文件中，即程序的bss段。
//
//所有这些都与我们的引导加载程序所做的非常相似，除了引导加载程序还需要从磁盘读取代码。
//查看boot/main.c以获得一些想法。
//

//提示:
//根据ELF段头指定的地址，将每个程序段加载到虚拟内存中。
//你应该只加载ph->p_type == ELF_PROG_LOAD的段。
//每个段的虚拟地址可以在ph->p_va中找到，其在内存中的大小可以在ph->p_memsz中找到。
//将ELF二进制文件中的ph->p_filesz字节(从'binary + ph->p_offset'开始)复制到虚拟地址ph->p_va。
//所有剩余的内存字节都应该清空为0。
// (ELF头应该有ph->p_filesz <= ph->p_memsz。)
//使用之前实验中的函数来分配和映射页。
//
//目前所有的页面保护位都应该是用户读/写的。
// ELF段不一定是按页对齐的，但你可以假定该函数没有两个段会接触同一个虚拟页。
//你可能会发现类似region_alloc的函数很有用。
//
//如果可以将数据直接移动到ELF二进制文件中存储的虚拟地址中，则读取段会简单得多。
//那么在这个函数执行期间，哪个页面目录应该生效呢?
//
//你还必须处理程序的入口点，确保环境从那里开始执行。
//什么?(参见下面的env_run()和env_pop_tf()。)

//实验3:这里是你的代码
//现在在虚拟地址USTACKTOP - PGSIZE处映射一页作为程序的初始栈。

//实验3:这里是你的代码

```

**代码**

我们都知道ELF是二进制文件，上文提到的二进制映像就是指的ELF文件。

```c
//蚌埠住了,参见下面的env_run()和env_pop_tf()一个是内联汇编+报错，一个就是直接报错，这参考除了注释还是注释。
//怎么有一种让你参考答案，模仿的写例题，但是例题答案还没写，等着你去写的感觉
static void
load_icode(struct Env *e, uint8_t *binary)
{
	// LAB 3: Your code here.
	struct Proghdr *ph, *eph;
	struct Elf *elf = (struct Elf *)binary;
	
	ph = (struct Proghdr *) ((uint8_t *) elf + elf->e_phoff);
	eph = ph + elf->e_phnum;
	
	if (elf->e_magic != ELF_MAGIC){
		panic("ELF is illegal");
	}
	lcr3(PADDR(e->env_pgdir));
	for (; ph < eph; ph++){
		if(ph->p_type == ELF_PROG_LOAD){
			region_alloc(e, (void *)ph->p_va, ph->p_memsz);
			memset((void *)ph->p_va, 0, ph->p_memsz);
			memcpy((void *)ph->p_va, binary + ph->p_offset, ph->p_filesz);
		}
	}
	// Now map one page for the program's initial stack
	// at virtual address USTACKTOP - PGSIZE.

	// LAB 3: Your code here.
	e->env_tf.tf_eip = elf->e_entry;
	region_alloc(e, (void *)(USTACKTOP - PGSIZE), PGSIZE);
	lcr3(PADDR(kern_pgdir));
}
```

难点吐槽1. 知道给了你什么，主要是说`binary`这个二进制镜像。2.随后是模仿`main.c`这块，模仿了初始的一些东西，核心的将其内容加载到新环境的用户地址空间中。这块完全是根据过去的函数进行写入，这块根据注释来就行，有时候感觉注释大部分都说了，但是说的蛮抽象了。3.最后那点借鉴你也不能给点正常的，注释套注释是吧，最后这块就是理解`env_run`的注释写。

第一次写的缺陷(不要问，问就是注释里没写或者有提示也搞不明白):

1. 缺少对页目录的设置。在`load_icode`函数中，需要在开始时设置正确的页目录，以便可以正确映射虚拟地址到物理地址。可以使用`lcr3`指令将页目录的物理地址加载到CR3寄存器。
2. 没有处理程序的入口点。在加载完所有的程序段后，需要设置环境的入口点，以确保环境从程序的入口点开始执行。可以使用`env_pop_tf`函数将环境的上下文切换到保存在环境结构体中的Trapframe结构体中的状态。

```
	struct Proghdr *ph, *eph;
	struct Elf *elf = (struct Elf *)binary;
	
	ph = (struct Proghdr *) ((uint8_t *) elf + elf->e_phoff);
	eph = ph + elf->e_phnum;
	int va = (int)elf + ph->p_offset;
	
	if (elf->e_magic != ELF_MAGIC){
		panic("ELF is illegal");
	}
	lcr3(PADDR(e->env_pgdir));
	for (; ph < eph; ph++){
		if(ph->p_type != ELF_PROG_LOAD){
			continue;
		}
		region_alloc(e, (void *)ph->p_va, ph->p_memsz);
		uint8_t *e_seg=(uint8_t *)ph->p_va,*ker_seg=(uint8_t *)(binary+ph->p_offset);
    	for(int i=0;i<ph->p_filesz;i++){
      		e_seg[i]=ker_seg[i];
    	}for(int i=ph->p_filesz;i<ph->p_memsz;i++)e_seg[i]=0;
  	}
```



##### `env_create()`

**目的：**

分配一个环境，并调用该函数将ELF二进制文件加载到环境中

**注释**

```c
//
//用env_alloc分配一个新的环境，用load_icode将命名elf二进制文件加载到其中，并设置其env_type。
//该函数仅在内核初始化期间，即运行第一个用户态环境之前调用
//新环境的父节点ID被设置为0
//
```

**代码**

```c
//关于env_alloc
env_alloc(struct Env **newenv_store, envid_t parent_id)

//struct Env **newenv_store：指向指针的指针，用于存储新分配的环境的指针。通过修改newenv_store指向的指针，函数可以将新分配的环境的指针返回给调用者。

//envid_t parent_id：表示父环境（进程）的ID。新分配的环境将作为父环境的子环境。这个参数可以用来设置新环境的父ID字段。
```

```c
void
env_create(uint8_t *binary, enum EnvType type)
{
	// LAB 3: Your code here.
	struct Env *e = NULL;
	env_alloc(&e, 0);
	load_icode(e, binary);
	e->env_type = type;
}
```



##### `env_run()`

**目的**

启动在用户模式下运行的给定环境。

**注释**

```c
//从curenv切换到env e。
//注意:如果这是第一次调用env_run，则curenv为NULL。
//
//这个函数没有返回
//

//第一步:如果这是一个上下文切换(一个新环境正在运行):
// 1。如果当前环境是ENV_RUNNING，则将当前环境(如果有的话)设置回ENV_RUNNABLE(考虑它可能处于其他状态)，
// 2。将 curenv 设置为新环境，
// 3。将其状态设置为ENV_RUNNING，
// 4。更新 env_runs 计数器，
// 5。使用lcr3()切换到它的地址空间。
//第二步:使用env_pop_tf()恢复环境的寄存器，并在环境中切换到用户模式。
//提示:该函数从e->env_tf加载新环境的状态。回顾一下您在上面编写的代码，并确保您已经将e->env_tf的相关部分设置为合理值。
```

**代码**

```c
void
env_run(struct Env *e){
	if (curenv && curenv->env_status == ENV_RUNNING) {
		curenv->env_status = ENV_RUNNABLE;
	}
	curenv = e;
	curenv->env_status = ENV_RUNNING;
	curenv->env_runs++;
	lcr3(PADDR(curenv->env_pgdir));
	
	unlock_kernel();
	env_pop_tf(&(curenv->env_tf));
}
```



#### 练习2后续

后续就两段话，但是为什么还单独挑出来说明？还不是自己傻乎乎的在**三重中断**的情况下调试了半天。我就是为什么代码崩了，代码还没写完，，，

完成后，应该编译内核并在QEMU下运行。因为JOS还没有设置硬件来允许从用户空间到内核的任何类型的转换。当CPU发现它没有设置好来处理这个系统调用中断时，它将产生一个通用保护异常，发现它不能处理这个异常，产生一个双重故障异常，发现它也不能处理这个异常，最后以所谓的“三重故障”放弃。

稍后我们会解决这个问题，但现在我们可以使用调试器来检查是否进入了用户模式。使用make qemu-gdb并在env_pop_tf处设置一个GDB断点，这应该是实际进入用户模式之前遇到的最后一个函数。使用si单步执行此函数;在iret指令之后，处理器应该进入用户模式。



#### 处理中断和异常:练习 3

此时，用户空间中的第一个int $0x30系统调用指令是一条死胡同:一旦处理器进入用户模式，就没有办法退出。大家现在需要实现基本的异常和系统调用处理，以便内核能够从用户态代码恢复对处理器的控制。你应该做的第一件事是彻底熟悉x86中断和异常机制。

```
如果读者还没有读过，请阅读80386程序员手册第9章(或IA-32开发人员手册第5章)。
```

[80386 Programmer's Reference Manual -- Chapter 09 (mit.edu)](https://pdos.csail.mit.edu/6.828/2017/readings/i386/c09.htm)

[80386 Programmer's Reference Manual -- Table of Contents (mit.edu)](https://pdos.csail.mit.edu/6.828/2017/readings/i386/toc.htm)

[pdos.csail.mit.edu/6.828/2017/readings/ia32/IA32-3A.pdf](https://pdos.csail.mit.edu/6.828/2017/readings/ia32/IA32-3A.pdf)

在本实验室中，我们通常遵循英特尔的中断、异常等术语。但异常、陷阱、中断、故障和abort等术语在不同的体系结构或操作系统上没有标准含义，在使用时往往忽略了它们在特定体系结构(如x86)上的细微差别。当你在实验室之外看到这些术语时，其含义可能略有不同。

##### 异常和中断

有两个外部中断源和两个异常源：

1. 中断

   可屏蔽中断，通过INTR引脚发出信号。

   不可屏蔽中断，通过NMI(不可屏蔽中断)引脚发出信号。

2. 异常

   处理器检测到：这些行为又分为故障、陷阱和中止。

   编程：指令INTO、INT 3、INT n和BOUND可以触发异常。这些指令通常称为“软件中断”，但处理器将它们作为异常处理。

##### 识别中断

**NMI和处理器识别的异常被分配在0到31范围内的预定标识符。可屏蔽中断的标识符由外部中断控制器(如Intel的8259A可编程中断控制器)确定，并在处理器的中断应答序列期间与处理器通信。8259A PIC分配的数字可以通过软件指定。**32 ~ 255范围内的任何数字都可以使用。中断和异常标识符的分配如表9-1所示。

```
Table 9-1. Interrupt and Exception ID Assignments

Identifier   Description

0            Divide error
1            Debug exceptions
2            Nonmaskable interrupt
3            Breakpoint (one-byte INT 3 instruction)
4            Overflow (INTO instruction)
5            Bounds check (BOUND instruction)
6            Invalid opcode
7            Coprocessor not available
8            Double fault
9            (reserved)
10           Invalid TSS
11           Segment not present
12           Stack exception
13           General protection
14           Page fault
15           (reserved)
16           Coprecessor error
17-31        (reserved)
32-255       Available for external interrupts via INTR pin
```

- 错误

  错误是指在导致异常的指令之前报告的异常。错误要么在指令开始执行之前检测到，要么在指令执行过程中检测到。如果在指令执行过程中检测到故障，则报告该故障，并将机器恢复到允许指令重新启动的状态。

- 陷阱

  陷阱是在检测到异常的指令之后，立即在指令边界报告的异常。

- 中断

  中断是一种异常，它既不允许精确定位导致异常的指令，也不允许重启导致异常的程序。中止用于报告严重错误，例如硬件错误和系统表中不一致或非法的值。



##### 启用和禁用中断

看不大懂，有点地方。

1. NMI（非屏蔽中断）掩蔽了进一步的 NMI

   当 NMI 处理程序正在执行时，处理器会忽略进一步的中断 NMI 引脚上的信号，直到执行下一个 [IRET](https://pdos.csail.mit.edu/6.828/2017/readings/i386/IRET.htm) 指令。

2. IF（中断启用标志） 掩码 INTR（中断请求信号）

   当IF=0时，抑制INTR中断;IF=1时，启用INTR中断。与其他标志位一样，处理器会根据复位信号清除标志位。CLI和STI修改IF设置。

   IF也隐含地受到以下操作的影响。

   - 指令PUSHF将所有标志(包括IF)存储在栈中，以便对它们进行检查。
   - 任务切换和指令POPF和IRET加载标志寄存器;因此，它们可用于修改IF。
   - 中断通过中断门自动复位，禁用中断。(本章稍后会解释中断门。)

3. RF 掩码调试故障

   EFLAGS中的RF位控制调试故障的识别。这允许针对给定指令最多引发一次调试错误，无论该指令被重启多少次。

4. MOV或POP to SS屏蔽了一些中断和异常

   需要修改栈段的软件通常使用一对指令;例如:如果中断或异常是在SS被改变之后处理的，但在ESP收到相应的改变之前，则栈指针SS:ESP的两个部分在中断处理程序或异常处理程序的持续时间内是不一致的。

   ```
   Mov ss, ax
   MOV ESP, StackTop
   ```

   为了防止这种情况，80386，在MOV到SS和POP到SS指令之后，抑制NMI, INTR，调试异常，和在指令边界上的单步陷阱，改变SS的指令之后。一些异常仍然可能发生;即缺页故障和一般保护故障。



##### 同时中断和异常之间的优先级

```c
//中断或异常的优先级

HIGHEST    Faults except debug faults
Trap instructions INTO, INT n, INT 3
Debug traps for this instruction
Debug faults for next instruction
NMI interrupt
LOWEST     INTR interrupt
```



##### IDT 中断描述符表

IDT是一个8字节的描述符数组。与GDT和IDT不同，IDT的第一项可以包含一个描述符。IDT表共256个表项，每一个表项是8个字节。

处理器通过IDT寄存器(IDTR)定位IDT。LIDT和SIDT操作IDTR的指令。这两条指令都有一个显式的操作数:内存中6字节区域的地址。

LIDT(加载IDT寄存器)用内存操作数中的线性基址和限制值加载IDT寄存器。该指令只能在CPL为0时执行。在创建IDT时，它通常由操作系统的初始化逻辑使用。操作系统也可以使用它从一个IDT更改为另一个IDT。

SIDT(存储IDT寄存器)将IDTR中存储的基数和极限值复制到内存位置。该指令可以在任何特权级别执行。



##### IDT描述符

IDT可以包含以下三种描述符中的任意一种:

- 任务门
- 中断门
- 陷阱门



##### 中断任务和中断程序

中断或异常可以“call”中断处理程序，在响应中断或异常时，处理器使用中断或异常标识符在IDT中索引描述符。如果处理器索引到中断门或陷阱门，它会以类似于调用调用门的方式调用处理程序。如果处理器找到任务门，就会触发任务切换，其方式类似于调用任务门。

**中断程序**

中断门或陷阱门间接指向将在当前执行任务的上下文中执行的过程，如图9-4所示。门的选择器指向GDT或当前LDT中的可执行段描述符。门的偏移字段指向中断或异常处理过程的开始。

<img src="https://cdn.staticaly.com/gh/ri-umk/picx-images-hosting@master/xv6/fig9-4.5xu144aez4k0.gif" alt="fig9-4" />



**中断过程堆栈**

正如由于调用指令而进行的控制转移一样，将控制转移到中断或异常处理过程时使用堆栈来存储返回到原始过程所需的信息。如图9-5所示，中断将EFLAGS寄存器推送到指向被中断指令的指针之前的堆栈中。

某些类型的异常还会导致错误代码被压入堆栈。异常处理程序可以使用错误代码来帮助诊断异常。



**从中断过程返回**

中断过程与普通过程的区别还在于离开过程的方法。IRET指令用于退出中断过程。IRET与RET类似，除了IRET将ESP额外增加4个字节(因为堆栈上的标志)并将保存的标志移动到EFLAGS寄存器中。只有当CPL为零时，EFLAGS的IOPL字段才会被改变。只有当CPL <= IOPL时，IF标志才会改变。



**中断过程对标志的使用**

通过中断门或陷阱门的矢量中断导致TF(陷阱标志)在TF的当前值作为EFLAGS的一部分保存在堆栈上后被重置。通过此操作，处理器可以防止使用单步进的调试活动影响中断响应。随后的IRET指令将TF恢复为堆栈上EFLAGS映像中的值。

中断门和陷阱门之间的区别在于对IF(中断使能标志)的影响。通过中断门复位中频的中断，从而防止其他中断干扰当前的中断处理程序。随后的IRET指令将IF恢复为堆栈上EFLAGS映像中的值。通过陷阱门的中断不会改变中频。



**中断过程中的保护**

控制中断过程的特权规则类似于过程调用的特权规则:CPU不允许中断将控制转移到比当前特权级别低的段中的过程中(在数字上特权级别更高)。试图违反此规则将导致一般保护异常。

由于中断的发生通常是不可预测的，因此该特权规则有效地对可以执行中断和异常处理过程的特权级别施加了限制。



**中断任务**

IDT中的任务门间接指向任务，当一个中断或异常矢量到达IDT中的一个任务门时，就会产生一个任务切换。用单独的任务处理中断有两个优点:

- 整个上下文将自动保存。
- 中断处理程序可以通过给它一个单独的地址空间(通过它的LDT或通过它的页目录)来与其他任务隔离。

中断任务通过执行IRET指令返回被中断的任务。

如果任务切换是由带有错误代码的异常引起的，处理器会自动将错误代码推送到与中断任务中要执行的第一条指令的特权级别相对应的堆栈中。



##### 错误号

对于与特定段相关的异常，处理器将错误代码压入异常处理程序的栈(无论是过程还是任务)。

- 如果程序外部的事件导致异常，处理器会设置EXT位。
- 如果错误码的索引部分引用了IDT中的门描述符，则处理器设置i位(IDT位)。

<img src="https://cdn.staticaly.com/gh/ri-umk/picx-images-hosting@master/xv6/fig9-7.6xc6x318j1c0.gif" alt="fig9-7" />

如果i位未设置，则TI位表示错误码是指向GDT(值为0)还是指向LDT(值为1)。剩余的14位是所涉及的段选择器的上14位。在某些情况下，栈上的错误码为null，即低阶字中的所有比特都为零。



##### 异常条件(INT)

```c
//中断 0 -- 除法错误
	除数为零
        
//中断 1 -- 调试异常
    指令地址断点错误。
    数据地址断点陷阱。
    常规检测故障。
    单步陷阱。
    任务切换断点陷阱。
   
//中断 3 -- 断点     
//中断 4 -- 溢出        
//中断 5 -- 边界检查
//中断 6 -- 操作码无效   
        
//中断 7 -- 协处理器不可用  
    处理器遇到ESC(转义)指令，设置cr0(控制寄存器零)的EM(仿真)位。
    处理器遇到WAIT指令或ESC指令时，CR0的MP(监控协处理器)和TS(任务切换)位都会被设置。        
        
//中断8 -- 双重故障   
Class           ID          Description     
                 1          Debug exceptions
                 2          NMI
                 3          Breakpoint
Benign           4          Overflow
Exceptions       5          Bounds check
                 6          Invalid opcode
                 7          Coprocessor not available
                16          Coprocessor error

                 0          Divide error
                 9          Coprocessor Segment Overrun
Contributory    10          Invalid TSS
Exceptions      11          Segment not present
                12          Stack exception
                13          General protection

Page Faults     14          Page fault        
        
//中断 9 -- 协处理器段溢出
//中断 10 -- 无效的 TSS
//中断 11 -- 段不存在        
//中断 12 -- 堆栈异常        
//中断 13 -- 一般保护例外        
//中断 14 -- 页面错误        
//中断 16 -- 协处理器错误        
```

由于太多且不容易记住，也有很多概念没有学过，所以就简单罗列一下。

具体参考

```
https://pdos.csail.mit.edu/6.828/2017/readings/i386/s09_08.htm
```



##### 摘要：异常和错误号

```
Description               Interrupt   Return Address  Exception     Function That Can Generate
Number      Points to       Type          the Exception
Faulting
Instruction

Divide error               0          YES             FAULT         DIV, IDIV
Debug exceptions           1
Some debug exceptions are traps and some are faults.  The exception
handler can determine which has occurred by examining DR6.  (Refer to Chapter 12.)
Some debug exceptions are traps and some are faults.  The exception
handler can determine which has occurred by examining DR6.  (Refer to Chapter 12.) Any instruction
Breakpoint                 3          NO              TRAP          One-byte INT 3
Overflow                   4          NO              TRAP          INTO
Bounds check               5          YES             FAULT         BOUND
Invalid opcode             6          YES             FAULT         Any illegal instruction
Coprocessor not available  7          YES             FAULT         ESC, WAIT
Double fault               8          YES             ABORT         Any instruction that can
generate an exception
Coprocessor Segment
Overrun                    9          NO              ABORT         Any operand of an ESC
instruction that wraps around
the end of a segment.
Invalid TSS               10          YES             FAULT
An invalid-TSS fault is not restartable if it occurs during the
processing of an external interrupt.        JMP, CALL, IRET, any interrupt
Segment not present       11          YES             FAULT         Any segment-register modifier
Stack exception           12          YES             FAULT         Any memory reference thru SS
General Protection        13          YES             FAULT/ABORT
All GP faults are restartable. If the fault occurs while attempting to
vector to the handler for an external interrupt, the interrupted program is
restartable, but the interrupt may be lost.  Any memory reference or code
fetch
Page fault                14          YES             FAULT         Any memory reference or code
fetch
Coprocessor error         16          YES             FAULT
Coprocessor errors are reported as a fault on the first ESC or WAIT
instruction executed after the ESC instruction that caused the error.        ESC, WAIT
Two-byte SW Interrupt     0-255       NO              TRAP          INT n
```

```
Description                       Interrupt     Error Code
Number

Divide error                       0            No
Debug exceptions                   1            No
Breakpoint                         3            No
Overflow                           4            No
Bounds check                       5            No
Invalid opcode                     6            No
Coprocessor not available          7            No
System error                       8            Yes (always 0)
Coprocessor Segment Overrun        9            No
Invalid TSS                       10            Yes
Segment not present               11            Yes
Stack exception                   12            Yes
General protection fault          13            Yes
Page fault                        14            Yes
Coprocessor error                 16            No
Two-byte SW interrupt             0-255         No
```

`int $n`按顺序包括以下几步：

1. 查找idtr寄存器高32位即IDT表基址，找到IDT表，从而找到即第n号中断的gate
2. 检查cpl和中断gate的dpl，如果cpl>dpl（越级调用）则产生保护异常（13号异常），否则继续
3. 根据tr寄存器（存储描述符selector）找到TSS描述符（在GDT内），再通过描述符找到TSS内核任务状态段，加载内核TSS段的`esp、ss`以切换到内核栈。
4. 如果是一个用户态到内核态的陷入操作，则向内核栈中压入用户态进程的ss和esp；如果是内核→内核，则不压入
5. 压入old eflags,cs,eip
6. 修改eflags中的某些位（如屏蔽外部中断置IF=0）
7. 如果有必要，压入errorcode，各中断是否有errorcode以及errorcode的含义可查看[idt.pdf](https://link.zhihu.com/?target=https%3A//pdos.csail.mit.edu/6.828/2011/lec/x86_idt.pdf)。



#### 受保护的控制传输

异常和中断都是“受保护的控制传输”：**它们导致处理器从用户模式切换到内核模式(CPL-0)，而不会给用户模式代码任何干扰内核或其他环境功能的机会。**

中断是一种受保护的控制转移，它通常由处理器外部的异步事件引起，例如外部设备I/O活动的通知。相反，异常是由当前运行的代码同步引起的受保护的控制传输，例如，由于除零或无效的内存访问。

为了确保这些受保护的控制传输实际上是受保护的，处理器的中断/异常机制被设计成这样，当中断或异常发生时，当前运行的代码不能任意选择进入内核的位置或方式。相反，处理器确保只有在精心控制的条件下才能进入内核。

在x86上，有两种机制协同工作来提供这种保护:

1. 中断描述符表。处理器确保中断和异常只能导致内核进入几个特定的、定义良好的入口点，这些入口点由内核本身决定，而不是由中断或异常发生时运行的代码决定。
2. 任务状态段。处理器需要一个地方来保存中断或异常发生之前的旧处理器状态，例如处理器调用异常处理程序之前的EIP和cs的原始值，以便异常处理程序稍后可以恢复旧状态并从中断的地方恢复被中断的代码。但是这个保存旧处理器状态的区域必须反过来受到非特权用户模式代码的保护;否则，错误或恶意的用户代码可能会危及内核。



#### 异常和中断的类型

x86处理器可以在**内部生成的所有同步异常都使用0到31之间的中断向量**，因此映射到IDT项0-31。例如，页面错误总是通过向量14导致异常。**大于31的中断向量仅用于软件中断**，它可以由int指令产生，或者外部设备在需要注意时引起的异步硬件中断。

在本节中，我们将扩展JOS以处理vector 0-31中内部生成的x86异常。在下一节中，我们将使JOS处理软件中断向量48 (Ox30)， JOS(相当随意地)将其用作自己的系统调用中断向量。在实验4中，我们将扩展JOS来处理外部生成的硬件中断，例如时钟中断。



#### 嵌套异常和中断

处理器可以从内核模式和用户模式接受异常和中断。但是，只有在从用户模式进入内核时，x86处理器才会在将旧的寄存器状态推入堆栈并通过IDT调用适当的异常处理程序之前自动切换堆栈。**当内核代码执行嵌套的中断或异常处理程序时，处理器会将相关的寄存器值和其他上下文信息推送到相同的内核堆栈上，以便在处理完当前中断或异常后能够正确地返回到之前的中断或异常处理程序。**通过这种方式，内核可以优雅地处理由内核内部代码引起的嵌套异常。

这个功能是实现保护的重要工具，我们将在后面关于系统调用的部分中看到。

如果处理器已经处于内核模式并接受嵌套异常，因为它不需要切换堆栈，所以它不会保存旧的ss或Esp寄存器。

需要注意的是，在处理器的内核堆栈上嵌套过多的中断或异常可能会导致堆栈溢出。因此，内核需要确保内核堆栈的大小足够来处理可能的嵌套情况，并采取相应的堆栈管理措施来防止堆栈溢出。



#### 设置IDT:练习 4

现在，您应该拥有了设置IDT和处理JOS异常所需的基本信息。现在，您将设置IDT来处理中断向量0-31(处理器异常)。我们将在稍后的实验中处理系统调用中断，并在稍后的实验中添加中断32-47(设备IRQs)。

头文件inc/trap.h和kern/trap.h包含与中断和异常相关的重要定义，您需要熟悉这些定义。文件kern/trap.H包含对内核严格私有的定义，而inc/trap.h包含对用户级程序和库也有用的定义。

注意:在0-31范围内的一些例外被Intel定义为保留。因为它们永远不会由处理器生成，所以如何处理它们并不重要。做你认为最干净的事。

1. 每个异常或中断都应该在trapentry.s中有自己的处理程序
2. trap_init()应该用这些处理程序的地址初始化IDT。
3. 每个处理程序都应该在栈上构建一个结构体Trapframe(参见inc/trap.h)
4. 用一个指向该Trapframe的指针调用trap()(在trap.c中)。
5. Trap()处理异常/中断或分派给特定的处理程序函数。

**要求**

```
练习4
	1.编辑trapentry.S和trap.c并实现上述特性。
	2.trapentry.s中的TRAPHANDLER和TRAPHANDLER_NOEC宏和inc/trap.h中的T_*定义应该对你有所帮助。
	3.你需要在trapentry.s中添加一个入口点。(使用这些宏)用于定义在inc/trap.h中的每个陷阱，并且您必须提供陷阱处理程序宏所引用的_alltraps。
	4.你还需要修改trap_init()，使idt指向trapentry.S中定义的每个入口点;SETGATE宏在这里很有用。
	
你的_alltraps应该:
	1.push值使栈看起来像一个结构Trapframe
	2.将GD_KD加载到%ds和%es中
	3.pushl %esp将指向Trapframe的指针作为参数传递给trap()
	4.call 陷阱(陷阱能返回吗?)

考虑使用pushal指令;它非常适合结构体Trapframe的布局。
```

**问题**

```
1.对每个异常/中断都有一个单独的处理程序函数的目的是什么?(即，如果所有异常/中断都交付给同一个处理程序，当前实现中的哪些特性无法提供?)

2.你需要做些什么来让user/softtint程序的行为正确吗?grade脚本期望它产生一个一般的保护故障(陷阱13)，但softint的代码显示int $14。为什么要产生中断向量13?如果内核实际上允许softint的int $14指令调用内核的缺页异常处理程序(即中断向量14)，会发生什么?
```

**前置准备和工具**

1. `inc/trap.h`

   相关详见 `the source code lab3 trap.c`

2. `trapentry.S`的宏

   `TRAPHANDLER`宏用于处理CPU自动推送错误码的异常。它定义了一个全局可见的函数，将一个异常号推送到栈上，然后跳转到`_alltraps`函数。使用`TRAPHANDLER`宏时，传入两个参数：`name`是函数名，`num`是异常号。

   `TRAPHANDLER_NOEC`宏用于处理CPU不推送错误码的异常。它与`TRAPHANDLER`宏类似，但在推送异常号之前，推送了一个0作为错误码。这样，无论CPU是否推送错误码，异常帧的格式都是相同的。

   这两个宏的作用是简化异常处理函数的定义过程，并确保异常帧的格式正确。在使用这些宏时，应该注意不要从C代码中直接调用生成的函数，而是在C代码中声明这些函数（例如，在IDT设置过程中获取函数指针时）。

3. 关于异常号，可以参考前面练习3中9.10的图表。有异常号的为：8,10,11,12,13,14

4. xv6的汇编代码主要使用AT&T语法，这是一种常见的x86汇编语言语法。有个要注意的点是根据`Trapframe的es和ds`是16位

5. 在`mmu.h`(按照`trap.c`头文件瞎找的)中有一个建立中断/陷阱门的描述符的宏，题中最后那点提示`SETGATE`的源码就在这里。这里居然第一个用的数组，啊心烦。

6. `#define T_SYSCALL   48`容易被落下。注意，`syscall`的权限是用户级的，且没有错误码。同样是用户级的还有个`brkpt`，这个在前面练习3有提到。

<img src="https://cdn.staticaly.com/gh/ri-umk/picx-images-hosting@master/xv6/lab3_5_cpu模型.28k9uyiahuv4.jpg" alt="lab3_5_cpu模型" />



**代码**

##### `trapentry.S`

```assembly
 // Error Code : no
TRAPHANDLER_NOEC(Int_divide, T_DIVIDE)
TRAPHANDLER_NOEC(Int_debug, T_DEBUG)
TRAPHANDLER_NOEC(Int_nmi, T_NMI)
TRAPHANDLER_NOEC(Int_brkpt, T_BRKPT)
TRAPHANDLER_NOEC(Int_oflow, T_OFLOW)
TRAPHANDLER_NOEC(Int_bound, T_BOUND)
TRAPHANDLER_NOEC(Int_illop, T_ILLOP)
TRAPHANDLER_NOEC(Int_device, T_DEVICE)
TRAPHANDLER_NOEC(Int_fperr, T_FPERR)
TRAPHANDLER_NOEC(Int_mchk, T_MCHK)
TRAPHANDLER_NOEC(Int_simderr, T_SIMDERR)
TRAPHANDLER_NOEC(Int_syscall, T_SYSCALL)
 // Error Code : yes
TRAPHANDLER(Int_dblflt, T_DBLFLT)
TRAPHANDLER(Int_tss, T_TSS)
TRAPHANDLER(Int_segnp, T_SEGNP)
TRAPHANDLER(Int_stack, T_STACK)
TRAPHANDLER(Int_gpflt, T_GPFLT)
TRAPHANDLER(Int_pgflt, T_PGFLT)
TRAPHANDLER(Int_align, T_ALIGN)

_alltraps:
  pushl %ds;
  pushl %es; 
  pushal; //push用户态所有寄存器即Trapframe域的PushRegs结构体
  movw $GD_KD, %ax; //不允许直接mov给ds、es，段寄存器都只有16bit。
  movw %ax, %ds
  movw %ax, %es
  pushl %esp;//由于trap函数需要的形参是一个4B的指针，而目前的esp就是Trapfram的基址，因此push %esp
  call trap;//将控制权交给os处理中断
```



##### `trap.c`

```
//trapentry.s function entry.
void Int_divide();
void Int_debug();
void Int_nmi();
void Int_brkpt();
void Int_oflow();
void Int_bound();
void Int_illop();
void Int_device();
void Int_fperr();
void Int_mchk();
void Int_simderr();
void Int_dblflt();
void Int_tss();
void Int_segnp();
void Int_stack();
void Int_gpflt();
void Int_pgflt();
void Int_align();
void Int_syscall();

void
trap_init(void)
{
	extern struct Segdesc gdt[];

	// LAB 3: Your code here.
	SETGATE(idt[T_DIVIDE], 	 0, GD_KT, Int_divide,	0);
	SETGATE(idt[T_DEBUG],	 0, GD_KT, Int_debug, 	0);
	SETGATE(idt[T_NMI], 	 0, GD_KT, Int_nmi, 	0);
	SETGATE(idt[T_BRKPT], 	 0, GD_KT, Int_brkpt,	3);
	SETGATE(idt[T_OFLOW], 	 0, GD_KT, Int_oflow, 	0);
	SETGATE(idt[T_BOUND], 	 0, GD_KT, Int_bound, 	0);
	SETGATE(idt[T_ILLOP], 	 0, GD_KT, Int_illop, 	0);
	SETGATE(idt[T_DEVICE], 	 0, GD_KT, Int_device, 	0);
	SETGATE(idt[T_DBLFLT], 	 0, GD_KT, Int_dblflt, 	0);
	SETGATE(idt[T_TSS], 	 0, GD_KT, Int_tss, 	0);
	SETGATE(idt[T_SEGNP], 	 0, GD_KT, Int_segnp, 	0);
	SETGATE(idt[T_STACK], 	 0, GD_KT, Int_stack, 	0);
	SETGATE(idt[T_GPFLT], 	 0, GD_KT, Int_gpflt, 	0);
	SETGATE(idt[T_PGFLT], 	 0, GD_KT, Int_pgflt, 	0);
	SETGATE(idt[T_FPERR], 	 0, GD_KT, Int_fperr, 	0);
	SETGATE(idt[T_ALIGN], 	 0, GD_KT, Int_align, 	0);
	SETGATE(idt[T_MCHK], 	 0, GD_KT, Int_mchk, 	0);
	SETGATE(idt[T_SIMDERR],  0, GD_KT, Int_simderr, 0);
	SETGATE(idt[T_SYSCALL],  0, GD_KT, Int_syscall, 3);
	
	// Per-CPU setup 
	trap_init_percpu();
}

```

**回答**

```
1.对每个异常/中断都有一个单独的处理程序函数的目的是什么?(即，如果所有异常/中断都交付给同一个处理程序，当前实现中的哪些特性无法提供?)

所有中断handler都调用trap函数，如果各个中断的trapframe构造方法一致，就可以放在同一个handler中处理（汇编指令相同），可以看到有些中断没有error_code因此指令是不同的，从而需要不同的handler。
```

```
2.你需要做些什么来让user/softtint程序的行为正确吗?grade脚本期望它产生一个一般的保护故障(陷阱13)，但softint的代码显示int $14。为什么要产生中断向量13?如果内核实际上允许softint的int $14指令调用内核的缺页异常处理程序(即中断向量14)，会发生什么?

不需要，int指令基于硬件，cpu会自动帮我们完成。用户态欲引起14号中断T_PGFLT，其IDT表gate的DPL为0，不可越级，因此出现了13号的general protection fault，只有断点和系统调用中断才允许用户调用陷入内核态。int指令第2步也解释了该问题。
```

**结语**

debug依旧那么的抽象



### Prat B：缺页异常、断点异常和系统调用

1. 在trap_dispatch中完善三种异常pagefault、breakpoints、system-calls的dispatch
2. 完善系统调用，为用户提供四种系统调用实例
3. 完善Page Fault和内存保护

#### 处理缺页异常:练习5

缺页异常(中断向量14 (T_PGFLT))是一个特别重要的异常，我们将在本实验和下一个实验中大量使用它。当处理器发生缺页异常时，它将导致该异常的线性(即虚拟)地址存储在一个特殊的处理器控制寄存器CR2中。在`trap.c`中，我们已经提供了一个用于处理缺页异常的特殊函数，即`page_fault_handler()`。

```
练习5:
1.修改trap_dispatch()，将页面异常分派给page_fault_handler()。
2.现在应该能够让make grade在faultread、faultreadkernel、faultwrite和faultwritekernel测试中成功了。如果其中任何一个不起作用，找出原因并修复它们。记住，可以使用make run-x或make run-x-nox将jo引导到特定的用户程序中。例如，make run-hello-nox运行hello用户程序。
```

##### `trap_dispatch`

**代码**

```c
static void
trap_dispatch(struct Trapframe *tf)
{
	// Handle processor exceptions.
	// LAB 3: Your code here.
	if (tf->tf_trapno == T_PGFLT){
		page_fault_handler(tf);
		return;
	}
	// Unexpected trap: The user process or the kernel has a bug.
	print_trapframe(tf);
	if (tf->tf_cs == GD_KT)
		panic("unhandled trap in kernel");
	else {
		env_destroy(curenv);
		return;
	}
}
```



#### 断点异常:练习6

断点异常(interrupt vector 3, T_BRKPT)通常用于允许调试器在程序代码中插入断点，具体做法是**将相关的程序指令临时替换为专门的1字节int3软件中断指令。**

在JOS中，我们将稍微滥用这个异常，将其转换为任何用户环境都可以使用的原始伪系统调用来调用JOS内核监视器。如果我们将JOS内核监视器视为基本调试器，那么这种用法实际上是适当的。例如，lib/panic.c中panic()的用户模式实现在显示紧急情况消息后执行int3

```
练习6
修改trap_dispatch()，使断点异常调用内核监视器。现在你应该能够让make grade在断点测试中成功了。
```

lab 要求我们引发断点异常时启动kernel monitor，那么dispatch时直接调用`monitor.c`中定义的`monitor(*tf)`即可。

##### `trap_dispatch()`

**代码**

```
static void
trap_dispatch(struct Trapframe *tf)
{
	// Handle processor exceptions.
	// LAB 3: Your code here.
	if (tf->tf_trapno == T_PGFLT){
		page_fault_handler(tf);
		return;
	}
	if (tf->tf_trapno == T_BRKPT){
		monitor(tf);
		return;
	}
	// Unexpected trap: The user process or the kernel has a bug.
	print_trapframe(tf);
	if (tf->tf_cs == GD_KT)
		panic("unhandled trap in kernel");
	else {
		env_destroy(curenv);
		return;
	}
}
```

**问题**

```
1.根据IDT中初始化断点条目的方式(即从trap_init调用SETGATE)，断点测试用例将生成断点异常或一般保护故障。为什么?您需要如何设置它才能使断点异常像上面指定的那样工作，哪些不正确的设置将导致它触发通用保护故障?

2.您认为这些机制的要点是什么，特别是根据用户/软测试程序所做的工作?
```

**回答**

```
1.在测试用户进程breakpoint.c时用户进程权限等级CPL为3，初始化IDT时将断点异常dpl设置为3，因此不会出发13号通用保护异常。

2.当然是防止用户态能随意调用内核代码，改变内核的内容，因此设置权限等级和通用保护异常，即使是允许用户系统调用的入口也是固定的，如breakpoints和system calls。
```



#### 系统调用:练习7

用户进程通过调用系统调用，要求内核为其做一些事情。在用户进程调用系统调用时，处理器进入核心态，处理器和内核协同保存用户进程的状态，内核执行适当的代码以执行系统调用，然后恢复用户进程。

在JOS内核中，我们将使用int指令，它会导致处理器中断。特别地，我们将使用int $0x30作为系统调用中断。我们将常数T_SYSCALL定义为48 (0x30)。你必须设置中断描述符，以允许用户进程触发该中断。请注意，中断0x30不能由硬件生成，因此允许用户代码生成中断0x30不会导致歧义。

应用程序将在寄存器中传递系统调用编号和系统调用参数。这样，内核就不需要遍历用户环境的栈或指令流。

系统调用编号将以%eax表示，参数(最多5个)将分别以%edx、%ecx、%ebx、%edi和%esi表示。内核将返回值传递回%eax。调用系统调用的汇编代码已经为你写好了，在lib/syscall.c的syscall()中。

```c
练习7
//1.在内核中为中断向量T_SYSCALL添加一个处理程序。你必须编辑kern/trapentry.s,kern/trap.c的trap_init()。
//2.您还需要更改trap_dispatch()，通过使用适当的参数调用syscall()(在kern/syscall.c中定义)来处理系统调用中断，然后安排将返回值传递回%eax中的用户进程。
//3.你需要在kern/syscall.c中实现syscall()。确保如果系统调用编号无效，syscall()返回-E_INVAL。
//4.你应该阅读并理解lib/syscall.c(特别是内联汇编例程)，以确认你对系统调用接口的理解。
//5.处理inc/syscall.h中列出的所有系统调用，对每个调用调用对应的内核函数。

在内核下运行user/hello程序(make Run -hello)。它应该在控制台中打印"hello, world"，然后在用户模式下导致缺页异常。如果没有发生这种情况，可能意味着你的系统调用处理程序不完全正确。您现在还应该能够获得make grade以在testbss测试中获得成功。
```

##### `trap_dispatch &  syscall`

**代码**

```c
//第一个要求在之前已经添加过了，所以不说了
trap_dipatch:

static void
trap_dispatch(struct Trapframe *tf)
{
	// Handle processor exceptions.
	// LAB 3: Your code here.
	if (tf->tf_trapno == T_PGFLT){
		page_fault_handler(tf);
		return;
	}
	if (tf->tf_trapno == T_BRKPT){
		monitor(tf);
		return;
	}
	if (tf->tf_trapno == T_SYSCALL){
		struct PushRegs* regs = &tf->tf_regs;
		regs->reg_eax = syscall(regs->reg_eax,regs->reg_edx, regs->reg_ecx, 
		regs->reg_ebx, regs->reg_edi, regs->reg_esi);
		return;
	}
	// Unexpected trap: The user process or the kernel has a bug.
	print_trapframe(tf);
	if (tf->tf_cs == GD_KT)
		panic("unhandled trap in kernel");
	else {
		env_destroy(curenv);
		return;
	}
}

//注意syscall.c的系统调用号在syscall.h中。调用函数的参数去参考lib的那个syscall.c。
int32_t
syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
{
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	// LAB 3: Your code here.
	switch (syscallno) {
	case SYS_cputs:
		sys_cputs((const char *)a1,a2);
		return -E_INVAL;
	case SYS_cgetc:
		return sys_cgetc();
	case SYS_getenvid:
		return sys_getenvid();
	case SYS_env_destroy:
		return sys_env_destroy(a1);
	default:
		return -E_INVAL;
	}
}
```



#### 用户模式启动:练习8

一个用户程序从`lib/entry.S`开头开始运行。在一些设置之后，这段代码在`lib/libmain.c`中调用。您应该修改`libmain()`，使全局指针指向数组中的此环境。(注意，`lib/entry.S`已经定义为指向你在a部分中建立的映射。)提示:查看`inc/env.h`并使用。

然后`Libmain()`调用，在hello程序中，这个调用位于`user/hello.c`中。注意，在打印"hello, world"之后，它会尝试访问。这就是它之前出错的原因。现在你已经正确初始化了，它应该不会出错了。如果它仍然出错，你可能还没有映射用户可读的区域(回到`pmap.c`的A部分;这是我们第一次真正使用这个区域)。

```
练习8:
1.将所需的代码添加到用户库，然后启动内核。
2.你会看到user/hello输出"hello, world"，然后输出"i am environment 00001000"。然后User /hello试图通过调用“退出”(参见lib/libmain.c和lib/exit.c)。
3.由于内核目前只支持一个用户环境，它应该报告它已经销毁了唯一的一个环境，然后进入内核监视器。你应该能够成功地完成hello测试。sys_env_destroy()
```

**简单回顾**

```shell
#sys_cputs函数的作用是打印用户提供的字符串。
#sys_cgetc函数的作用是从系统控制台读取一个字符，并返回该字符的ASCII码。
#sys_getenvid函数的作用是返回当前环境（进程）的环境ID。
#sys_env_destroy函数的作用是销毁给定的环境（可能是当前正在运行的环境）。
```

##### `libmain()`

**代码**

一个用户程序的入口函数`libmain`的实现。我们完成的是设置`thisenv`指针，使其指向当前环境的`struct Env`结构。这里可以去看看`env.h`

```c
thisenv = ENVX(sys_getenvid()) + envs;
ENVX(envid)是一个宏，用于从环境ID中提取环境索引。
```

这段代码是将`thisenv`指针指向当前环境（进程）的`struct Env`结构体。它使用了`sys_getenvid`函数来获取当前环境的环境ID，并通过将环境ID与环境数组的索引进行按位与运算，得到当前环境在`envs`数组中的索引。然后将`thisenv`指针设置为`envs`数组中对应索引的元素的地址。



#### 缺页异常和内存保护:练习9，10

大多数系统调用接口允许用户程序向内核传递指针。这些指针指向要读或写的用户缓冲区。然后内核在执行系统调用时对这些指针解引用。这里有两个问题:

1. 内核中的页面错误可能比用户程序中的页面错误严重得多。如果内核在操作自己的数据结构时出现页面错误，那就是内核错误，错误处理程序应该让内核(以及整个系统)感到恐慌。但是当内核解引用用户程序给它的指针时，它需要一种方法来记住这些解引用引起的任何页面错误实际上是代表用户程序。
2. 内核通常比用户程序拥有更多的内存权限。用户程序可能传递一个指向系统调用的指针，该系统调用指向内核可以读写但程序不能读写的内存。内核必须小心不要被骗去解引用这样的指针，因为这可能会泄露私有信息或破坏内核的完整性。

由于这两个原因，内核在处理用户程序提供的指针时必须非常小心。现在，您将使用一种机制来解决这两个问题，**该机制检查从用户空间传递到内核的所有指针。**

**当程序向内核传递一个指针时，内核将检查该地址是否在地址空间的用户部分，并且页表是否允许内存操作。**因此，内核永远不会因为解引用用户提供的指针而出现页面错误。如果内核发生了页面错误，它应该发生恐慌并终止。

**练习9**

```
1.如果在内核模式发生缺页异常，则更改为panic。kern/trap.c
提示:要确定故障是在用户模式发生还是在内核模式发生，请检查的低位。tf_cs
2.读取kern/pmap.c并在同一个文件中实现。user_mem_check
3.将kern/syscall.c改为系统调用的完整性检查参数。user_mem_assert 
4.启动内核，运行user/buggyhello。应该销毁环境，内核不应该惊慌。你会看到:
	[00001000] user_mem_check assertion failure for va 00000001
	[00001000] free env 00001000
	Destroyed the only environment - nothing more to do!
5.最后，修改kern/kdebug.c，调用、和。如果您现在运行user/breakpoint，您应该能够从内核监视器运行，并在内核出现缺页异常之前查看对lib/libmain.c的回溯遍历。什么原因导致缺页异常?
debuginfo_eip user_mem_check usdstabsstabstr
```

请注意，刚才实现的机制也适用于恶意用户应用程序(例如user/evilhello)。

1. 首先如果页错误发生在内核态时应该直接panic。
2. 实现kern/pmap.c中的user_mem_check()工具函数，该函数检测用户环境是否有权限访问线性地址区域[va, va+len)。然后对在kern/syscall.c中的系统调用函数使用user_mem_check()工具函数进行内存访问权限检查。

**练习10**

```
启动内核，运行user/evilhello。应该销毁环境，内核不应该惊慌。你会看到:
	[00000000] new env 00001000
	...
	[00001000] user_mem_check assertion failure for va f010000c
	[00001000] free env 00001000
```

##### `page_fault_handler`

**代码**

```
	if((tf->tf_cs & 3) == 0){
		panic("page fault in kernel mode!\n");
	}
```



##### `user_mem_check`

**注释**

```c
//
//检查环境是否允许访问权限为'perm | PTE_P'的范围内的内存[va, va+len]。
//通常'perm'至少包含PTE_U，但这不是必需的。
// va 和 len 不需要按页面对齐;你必须测试所有包含这个范围的页面。
//你将测试 len/PGSIZE 、 len/PGSIZE + 1 或 len/PGSIZE + 2 页面。
//
//用户程序可以访问虚拟地址，如果(1)该地址低于ULIM，且(2)页表给予了它权限。这些正是你应该在这里实现的测试。
//
//如果发生错误，将 user_mem_check_addr 变量设置为第一个错误的虚拟地址。
//
```

**代码**

```c
int
user_mem_check(struct Env *env, const void *va, size_t len, int perm)
{
	// LAB 3: Your code here.
	size_t end = (size_t)ROUNDUP(va+len, PGSIZE);
	size_t start = (size_t)ROUNDDOWN(va, PGSIZE);

	for(;start < end; start += PGSIZE){
		pte_t *env_pte = pgdir_walk(env->env_pgdir,(void *)start, 0);
		if((start >= ULIM) || !(env_pte) || !(*env_pte & PTE_P) || !(*env_pte & perm)){
			user_mem_check_addr = (i < (uint32_t)va ? (uint32_t)va : i); 
			return -E_FAULT;	
		}
	}
	return 0;
}
```

虽然自己用的不是三目运算符，但是感觉这东西挺舒服的，拿过来了。



##### `sys_cputs`

**代码**

```
	user_mem_assert(curenv, s, len, PTE_U);
```



**完结撒花**

<img src="https://cdn.staticaly.com/gh/ri-umk/picx-images-hosting@master/xv6/屏幕截图-2023-07-27-111954.69m0lz8sxi00.jpg" alt="屏幕截图-2023-07-27-111954" />

最后判断的大小于号反了，真的乐。



## lab 4

**配置**

```shell
git init
git add .
git config --global user.name "riumk"
git config --global user.email "2638489723@qq.com"
git checkout -b lab4 origin/lab4
git commit -m "xxx"
git merge lab3
git add . 
git commit -m "xxx"
make
//然后你自己debug吧，把配置的小冲突删掉就行
```

**抢先多任务处理**

在本实验中，您将在多个同时活跃的用户模式环境中实现抢占式多任务处理。

1. 在A部分中，我们将为JOS添加多处理器支持，实现轮询调度，并添加基本的环境管理系统调用(创建和销毁环境的调用，以及分配/映射内存的调用)。
2. 在B部分中，我们将实现一个类似unix的fork()，它允许用户态环境创建自身的副本。
3. 在C部分，你将添加对进程间通信(IPC)的支持，允许不同的用户模式环境显式地相互通信和同步。您还将添加对硬件时钟中断和抢占的支持。



### Part A: 多处理器支持和协作多任务处理

在本实验室的第一部分中，您将首先扩展JOS以在多处理器系统上运行，然后实现一些新的JOS内核系统调用，以允许用户级环境创建额外的新环境。大家还将实现协作式轮询调度，允许内核在当前环境主动放弃CPU(或退出)时从一个环境切换到另一个环境。在C部分后面的内容中，读者将实现抢占式调度，它允许内核在一段时间后从环境重新获得对CPU的控制权，即使环境不配合。



#### 多处理器支持:练习1

**前言部分**

我们将使JOS支持“对称多处理”(SMP)，这是一种多处理器模型，在这种模型中，所有cpu对系统资源(如内存和I/O总线)具有相同的访问权限。

在SMP中所有cpu的功能都是相同的，还是将cpu分为两类

1. 引导处理器(bootstrap processor, BSP)负责初始化系统和引导操作系统;
2. 只有在操作系统启动并运行之后，BSP才会激活应用程序处理器(APs)。

到目前为止，所有现有的JOS代码都在BSP上运行。

在SMP系统中，每个CPU都有一个相应的本地APIC (LAPIC)单元。LAPIC单元负责在整个系统中交付中断。LAPIC还为其连接的CPU提供一个唯一标识符。在本实验室中，我们利用了以下LAPIC单元的基本功能(在kern/ LAPIC .c中):

- 读取LAPIC标识符(APIC ID)来判断代码当前运行在哪个CPU上(参见`cpunum()`)。
- 从BSP向ap发送启动处理器间中断(IPI)，以启动其他cpu(参见`lapic_startap()`)。
- 在C部分中，我们编写了LAPIC的内置定时器来触发时钟中断，以支持抢占式多任务(参见`apic_init()`)。

你提到的MMIO是一种通过内存映射的方式访问I/O设备寄存器的方法。在这种方法中，一部分物理内存被硬连接到I/O设备的寄存器，因此可以使用与访问内存相同的指令来访问这些设备寄存器。

在JOS操作系统中，你已经看到了一个IO空洞，位于物理地址0xA0000处，用于写入VGA显示缓冲区。而LAPIC位于从物理地址0xFE000000开始的一个空洞中，比4GB少32MB。因此，使用常规的直接映射方式在KERNBASE上访问LAPIC会导致地址太高。

为了解决这个问题，JOS在MMIOBASE中留下了4MB的空间，用于虚拟内存映射设备。

由于后续实验中可能会引入更多的MMIO区域，所以我们需要编写一个简单的函数来分配空间并将设备内存映射到该区域。

这个函数的作用是**为设备分配一块内存区域，并将设备的寄存器映射到这个区域。这样，我们就可以通过访问这个区域来访问设备的寄存器，而无需担心物理地址的限制。**

##### `mmio_map_region`

**练习1**

```
在kern/pmap.c中实现mmio_map_region。要了解如何使用它，请查看kern/lapic.c中lapic_init的开头部分。在运行mmio_map_region的测试之前，你还必须完成下一个练习。
```

**注释**

```c
// lapic_init 开头
// lapicaddr是LAPIC的4K MMIO区域的物理地址
// 将它映射到虚拟内存中，以便我们可以访问它。

//
// 在MMIO区域中保留size字节，并在该位置保留map [pa,pa+size)。返回保留区域的基值。
// size 不一定是PGSIZE的倍数。
//

// 从哪里开始下一个region.最初，这是 MMIO区域的开始
// 因为这是静态的值将在调用mmio_map_region之间保留
//(就像boot_alloc中的nextfree一样)
static uintptr_t base = MMIOBASE;

//从base开始分配大小字节的虚拟内存，并将物理内存页[pa,pa+size)映射到虚拟地址[base,base+size)。
//因为这是设备内存而不是普通的DRAM，你必须告诉CPU，缓存对该内存的访问是不安全的。
//幸运的是，页表为此提供了比特位。只需加上PTE_W，用PTE_PCD|PTE_PWT(禁用缓存和透写)创建映射。
//确保将size取整为PGSIZE的倍数，并处理预留是否会溢出MMIOLIM(如果发生这种情况，可以简单地恐慌)。
//提示:staff解决方案使用boot_map_region。
```

**步骤**

```
1.从base开始分配大小字节的虚拟内存
2.将物理内存页[pa,pa+size)映射到虚拟地址[base,base+size)。
3.告诉CPU，缓存对该内存的访问是不安全的。
4.加上PTE_W，用PTE_PCD|PTE_PWT(禁用缓存和透写)创建映射。
5.确保将size取整为PGSIZE的倍数，并处理预留是否会溢出MMIOLIM(如果发生这种情况，可以简单地恐慌)。(这里的MMILIM是设备结束的地址)
6.staff解决方案使用boot_map_region。
7.在MMIO区域中保留size字节，并在该位置保留map [pa,pa+size)。返回保留区域的基值。
```

**代码**

```
//说了那么多就用个boot_map_region啊,看的步骤6，期待突然就没了
	size = ROUNDUP(size, PGSIZE);
	pa =ROUNDDOWN(pa, PGSIZE);
	if(base + size >= MMIOLIM)
		panic("mmio_map_region not implemented");
	boot_map_region(kern_pgdir, base, size, pa, PTE_W | PTE_PCD | PTE_PWT);  
	
	uintptr_t curr_base = base;
	base += size;
	return (uint32_t *)(curr_base);
```

`base += size` 的目的是将 `base` 的值增加 `size`，以便指向下一个可用的虚拟地址。这样，在下一次调用 `mmio_map_region` 函数时，就可以使用更新后的 `base` 值作为新的设备内存区域的起始地址。



#### 应用处理器引导程序:练习2

系统在启动过程中会初始化并启动所有的处理器，包括引导处理器（BSP）和非引导处理器（AP）。

**前言**

在启动APs之前，BSP应该首先收集有关多处理器系统的信息，例如cpu的总数、APIC id和LAPIC单元的MMIO地址。`kern/mpconfig.c`中的**`mp_init()`函数通过读取位于BIOS内存区域中的MP配置表来获取该信息。**

`boot_aps()`函数(在`kern/init.c`中)驱动AP引导进程。

APs在真实模式中启动，就像引导加载程序在`boot/boot.S`中启动一样。因此，`boot_aps()`将AP入口代码`(kern/mpentry.S)`复制到真实模式下可寻址的内存位置。**与引导加载程序不同，我们对AP开始执行代码的位置有一定的控制;**

控制：你可以选择合适的物理地址来存放 AP 入口代码，只要它满足低于640KB、未使用、按页对齐的要求。

`boot_aps()`函数负责启动多处理器系统中的每个 AP（辅助处理器）。它通过发送中断请求（IPI）到相应的 AP 的 LAPIC（本地高级可编程中断控制器）单元，并指定初始的 CS:IP 地址，从而逐个激活 AP。

过程如下：

1. `boot_aps()` 函数发送 IPI 到相应的 AP 的 LAPIC 单元，指示 AP 开始执行其入口代码。
2. AP 在指定的 CS:IP 地址开始运行其入口代码，即 `kern/mpentry.S` 中的代码。
3. 入口代码首先进行一些简短的设置，将 AP 切换到保护模式并启用分页机制。
4. 然后，入口代码调用 C 设置例程 `mp_main()`，该例程位于 `kern/init.c` 中。`mp_main()` 函数负责初始化 AP 的状态和执行其他必要的操作。
5. 在 `mp_main()` 函数执行期间，AP 在其 `struct CpuInfo` 的 `cpu_status` 字段中发出 `CPU_STARTED` 标志，表示它已经启动完成。
6. `boot_aps()` 函数等待 AP 发出 `CPU_STARTED` 标志后，继续唤醒下一个 AP，并重复上述过程，直到所有的 AP 都被激活。

**MPS**

```
真6了，给了个论文，看的还行
https://wenku.baidu.com/view/615ea3c6aa00b52acfc7ca97.htmlhttps://pdos.csail.mit.edu/6.828/2018/readings/ia32/MPspec.pdf?_wkts_=1690537302958
```

##### `page_init`

**练习2**

```
1.读取kern/init.c中的boot_aps()和mp_main()，以及kern/mpentry.S中的汇编代码。确保你理解APs引导过程中的控制流转移。
2.然后修改kern/pmap.c中对page_init()的实现，避免将MPENTRY_PADDR中的页添加到未使用内存列表中，这样我们就可以安全地复制并在该物理地址上运行AP引导代码。
3.你的代码应该能通过更新后的check_page_free_list()测试(但更新后的check_kern_pgdir()测试可能会失败，我们很快就会修复这个问题)。
```

**问题**

```
将kern/mpentry.S和boot/boot.S并排比较。请记住，kern/mpentry.S被编译并链接到KERNBASE之上运行，就像内核中的其他所有内容一样，
1.宏MPBOOTPHYS的目的是什么?
2.为什么它在kern/mpentry.S中是必要的，但在boot/boot.S中不是?换句话说，如果在kern/mpentry.S中省略了它，会发生什么问题?

提示:回想一下我们在实验1中讨论过的链接地址和加载地址之间的差异。
(这个在引导加载程序的加载内核有提到)
```

**代码**

```c
	size_t i;
	for (i = 0; i < npages; i++) {
		if(i == 0){
                        pages[i].pp_ref = 1;
                        pages[i].pp_link = NULL;
                } else if(i>=1 && i<npages_basemem){
                	if (i == MPENTRY_PADDR/PGSIZE){
                		pages[i].pp_ref = 1;
                		continue;
                	}
                        pages[i].pp_ref = 0;
                        pages[i].pp_link = page_free_list;
                        page_free_list = &pages[i];
                } else if(i>=IOPHYSMEM/PGSIZE && i < EXTPHYSMEM/PGSIZE){
                        pages[i].pp_ref = 1;
                        pages[i].pp_link = NULL;
                } else if(i >= EXTPHYSMEM/ PGSIZE && i < (PADDR(boot_alloc(0)))/PGSIZE){
                        pages[i].pp_ref = 1;
                        pages[i].pp_link = NULL;
                } else{
                        pages[i].pp_ref = 0;
                        pages[i].pp_link = page_free_list;
                        page_free_list = &pages[i];
                }
	}
}
```

**阅读**

调用关系

在`boot_aps()`中，该函数遍历cpus数组，一个接一个启动所有的AP，当一个AP启动后会执行`kern/mpentry.S`中的代码，然后跳转到`mp_main()`中，该函数为当前AP设置GDT，TTS，最后设置cpus数组中当前CPU对应的结构的`cpu_status`为CPU_STARTED。

`mpentry.S`注释

```
#每个非启动CPU(“AP”)响应启动CPU的启动IPI而启动。AP将在实模式下启动，CS:IP设置为XY00:0000，其中XY是启动时发送的8位值。因此，该代码必须从4096字节的边界开始。
#
#因为这段代码将DS设置为0，所以它必须从物理内存的低216字节的地址运行。
#
# boot_aps() (in init.c)将此代码复制到MPENTRY_PADDR(满足上述限制)。然后，对于每个AP，它将预分配的每个核栈的地址存储在mpentry_kstack中，发送启动IPI，并等待该代码确认它已经启动(这在init.c中的mp_main中进行)。
#
#这段代码类似于boot/boot.S除了那个
# -不需要启用A20
# -它使用MPBOOTPHYS来计算符号的绝对地址，而不是依赖链接器来填充它们
```

APs引导过程中的控制流转移:(这块要了解源码,跑下面源码部分)

```
1.引导加载程序（Bootloader）将 AP 入口代码复制到指定的物理地址，例如 0x7000 (MPENTRY_PADDR)。

2.boot_aps() 函数通过发送中断请求（IPI）到 AP 的 LAPIC 单元，指示 AP 开始执行其入口代码。

3.AP 在指定的物理地址处开始执行其入口代码。

4.入口代码(kern/mpentry.S)执行一些设置，例如将 AP 切换到保护模式并启用分页机制。

5.入口代码调用 C 设置例程 mp_main()，该例程负责初始化 AP 的状态和执行其他必要的操作。

6.mp_main() 函数执行期间，AP 进行一系列的初始化工作，例如设置 AP 的局部描述符表（LDT）、全局描述符表（GDT）、任务状态段（TSS）等。

7.AP 可能会进入等待状态，直到主处理器（Bootstrap Processor，BSP）发出特定的信号或指令，以确保所有处理器同时开始执行。

8.一旦 AP 完成初始化并准备好执行任务，它会在 struct CpuInfo 的 cpu_status 字段中发出 CPU_STARTED 标志，表示它已经启动完成。

9.boot_aps() 函数检查 cpu_status 字段，等待 AP 发出 CPU_STARTED 标志后，继续唤醒下一个 AP，并重复上述过程，直到所有的 AP 都被激活。
```

**回答**

```
1.宏MPBOOTPHYS的目的是什么?
2.为什么它在kern/mpentry.S中是必要的，但在boot/boot.S中不是?换句话说，如果在kern/mpentry.S中省略了它，会发生什么问题?

1.宏 MPBOOTPHYS 的目的是获取引导处理器（BSP）的物理地址。将 MPENTRY_PADDR 减去 KERNBASE 来计算 BSP 的物理地址。
2.如果在 kern/mpentry.S 中省略了 MPBOOTPHYS 宏，那么计算得到的 BSP 的物理地址将是错误的，导致非引导处理器（AP）的初始化过程出现问题。

链接和加载的区别就在偏移吧
```



#### Per-CPU状态和初始化:练习3 ,4

在编写多处理器操作系统时，区分每个处理器私有的 per-CPU 状态和整个系统共享的全局状态非常重要。`kern/cpu.h` 文件定义了大多数各 CPU 状态，包括存储各 CPU 变量的 `struct CpuInfo` 结构体。

```
struct CpuInfo {
	uint8_t cpu_id;                 //本地APIC ID;索引到cpu[]下面
	volatile unsigned cpu_status;   // CPU的状态
	struct Env *cpu_env;            // 当前运行的环境。
	struct Taskstate cpu_ts;        // x86用于查找中断的栈
};
```

你应该知道的per-CPU状态:

- Per-CPU内核栈。(位置)

  因为多个cpu可能同时进入内核，我们需要为每个处理器提供一个单独的内核栈，以防止它们干扰彼此的执行。数组`percpu_kstacks[NCPU] [KSTKSIZE]`为NCPU级别的内核栈分配空间。

  在实验2中，您将`bootstack`引用的物理内存映射为BSP的内核堆栈，就在`KSTACKTOP`下面。类似地，在本实验中，您将把每个CPU的内核堆栈映射到这个区域，保护页充当它们之间的缓冲区。CPU 0的栈仍然会从`KSTACKTOP`向下增长;CPU 1的栈将从CPU 0的栈底部以下的`KSTKGAP`字节开始，以此类推。`Inc /memlayout.h`显示映射布局

- Per-CPU TSS和TSS描述符。(位置)

  还需要一个per-CPU任务状态段(TSS)，用于指定每个CPU的内核栈所在的位置。**CPU i的TSS存储在cpus[i]中。对应的TSS描述符定义在GDT项GDT [(GD_TSS0 >> 3) + i]中。**在`kern/trap.c`中定义的全局ts变量将不再有用。

- Per-CPU当前环境指针.(环境/进程)

  由于每个CPU可以同时运行不同的用户进程，我们重新定义了符号curenv，表示`CPU [cpunum()]`。`cpu_env`(或这个`cpuu ->cpu_env`)，指向当前CPU(代码运行所在的CPU)上当前执行的环境。

- Per-CPU系统寄存器(初始化)

  所有寄存器(包括系统寄存器)都是CPU私有的。因此，初始化这些寄存器的指令，如`lcr3()、ltr()、lgdt()、lidt()`等，必须在每个CPU上执行一次。函数`env_init_percpu()`和`trap_init_percpu()`就是为此定义的。

除此之外，如果您在解决方案中添加了任何额外的per-CPU状态或执行了任何额外的特定于CPU的初始化(例如，在CPU寄存器中设置新的位)以解决早期实验中的问题，请务必在这里的每个CPU上复制它们!

**练习3**

```
修改mem_init_mp()(在kern/pmap.c中)以映射从KSTACKTOP开始的各cpu栈，如inc/memlayout.h所示。每个栈的长度是KSTKSIZE字节加上未映射保护页的KSTKGAP字节。你的代码应该在check_kern_pgdir()中传递新的检查。
```

**练习4**

```
trap_init_percpu() (kern/trap.c)中的代码初始化BSP的TSS和TSS描述符。它在实验3中正常工作，但在其他cpu上运行时不正确。修改代码，使其可以在所有cpu上工作。(注意:您的新代码不应再使用全局ts变量。)
```

##### `mem_init_mp()`

**注释**：映射从`KSTACKTOP`开始的各cpu栈

```c
//从KSTACKTOP开始映射各cpu栈，最多映射 NCPU cpu。
//
//对于CPU i，使用 percpu_kstacks[i] 表示的物理内存作为内核栈。CPU i的内核栈从虚拟地址kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP)向下增长，并分为两部分，就像您设置的单个栈一样
// mem_init:
// * [kstacktop_i - KSTKSIZE, kstacktop_i)
//由物理内存支持
// * [kstacktop_i - (KSTKSIZE + KSTKGAP)， kstacktop_i - KSTKSIZE]
//不支持;因此，如果内核溢出了它的栈，它将出错，而不是覆盖另一个CPU的栈。
//称为“保护页”。
//权限:内核RW，用户无
```

**代码**：`mem_init_mp()`

```
	for(int i = 0; i<NCPU; i++){
		boot_map_region(kern_pgdir, KSTACKTOP - i * (KSTKSIZE + KSTKGAP) - KSTKSIZE,
		 		KSTKSIZE,  PADDR(percpu_kstacks[i]), PTE_W);
	}
```

发现都是这么写的，但是题中不是说`PADDR(percpu_kstacks[i])`是物理地址吗？怎么就成为内核虚拟地址了？



##### `trap_init_percpu`

**注释**

```c
//这里的示例代码设置任务状态段(TSS)和CPU 0的TSS描述符。
//但如果我们运行在其他CPU上，则是不正确的，因为每个CPU都有自己的内核堆栈。
//修复代码，使其适用于所有cpu。
//
//提示:
// -宏" thispu "始终指向当前CPU的struct CpuInfo;
// -当前CPU的ID由cpunum()或thiscpu->cpu_id给出;
// -使用" thiscpu ->cpu_ts"作为当前CPU的TSS，而不是全局的"ts"变量;
// -使用gdt[(GD_TSS0 >> 3) + i]作为CPU i的TSS描述符;
// -你在mem_init_mp()中映射了各cpu内核栈
// -初始化cpu_tsts_iomb用于防止未经授权的环境执行IO操作(0不是正确的值!)
//
//ltr在TSS选择器中设置了'busy'标志，所以如果你不小心在多个CPU上加载了相同的TSS，你将会遇到三重错误。
//如果您设置了一个单独的CPU的TSS错误，您可能不会遇到错误，直到您尝试从该CPU上的用户空间返回。
//

trap_init_percpu() (kern/trap.c)中的代码初始化BSP的TSS和TSS描述符。它在实验3中正常工作，但在其他cpu上运行时不正确。修改代码，使其可以在所有cpu上工作。(注意:您的新代码不应再使用全局ts变量。)
```

**准备工作**

```
1.看cpu.h
2.解析现有代码 trap_init_percpu
3.thiscpu 是一个指向 struct CpuInfo 的指针,而struct CpuInfo 结构体中有一个名为 cpu_ts 的成员变量。

备份:
	ts.ts_esp0 = KSTACKTOP;
	ts.ts_ss0 = GD_KD;
	ts.ts_iomb = sizeof(struct Taskstate);

	// Initialize the TSS slot of the gdt.
	gdt[GD_TSS0 >> 3] = SEG16(STS_T32A, (uint32_t) (&ts),
					sizeof(struct Taskstate) - 1, 0);
	gdt[GD_TSS0 >> 3].sd_s = 0;

	// Load the TSS selector (like other segment selectors, the
	// bottom three bits are special; we leave them 0)
	ltr(GD_TSS0);

	// Load the IDT
	lidt(&idt_pd);
```

**代码**:`trap_init_percpu`

```
	// LAB 4: Your code here:
	int i = thiscpu->cpu_id;
	thiscpu->cpu_ts.ts_esp0 = KSTACKTOP - i * (KSTKSIZE + KSTKGAP);
	thiscpu->cpu_ts.ts_ss0 = GD_KD;
	thiscpu->cpu_ts.ts_iomb = sizeof(struct Taskstate);

	// Initialize the TSS slot of the gdt.
	gdt[(GD_TSS0 >> 3) + i] = SEG16(STS_T32A, (uint32_t) (&thiscpu->cpu_ts),
					sizeof(struct Taskstate) - 1, 0);
	gdt[(GD_TSS0 >> 3) + i].sd_s = 0;

	// Load the TSS selector (like other segment selectors, the
	// bottom three bits are special; we leave them 0)
	ltr(GD_TSS0 + (i << 3));

	// Load the IDT
	lidt(&idt_pd);
```

找了半天可是找见bug了，`ltr(GD_TSS0 + (thiscpu->cpu_id * sizeof(struct Gatedesc)));`



#### 锁:练习5

初始化AP后，我们需要首先解决多个cpu同时运行内核代码时的竞争条件。最简单方法是使用一个大的内核锁。大内核锁是一个全局锁，在环境进入核心态时持有，在环境返回用户态时释放。在该模型中，用户态环境可以在任何可用的cpu上并发运行，但内核态环境只能运行一个;任何其他试图进入核心态的环境都必须等待。

**扩展**

大内核锁，或者称为全局内核锁，是一个非常基础的同步机制，用于在多处理器系统中防止内核代码的并发执行。这种模型的主要优点是简单和易于实现，因为只需要一个锁，即可在所有CPU上同步内核代码的执行。然而，这种模型也有其缺点。因为它阻止了内核级别的并行性，所以在多处理器系统上的性能可能会受到限制。此外，持有大内核锁的时间越长，其他等待进入内核态的进程就必须等待越长时间。

虽然大内核锁是一个简单的解决方案，但对于那些需要更高级别并行性的系统来说，可能会需要更复杂的模型。例如：

1. **精细级锁**：与全局锁相比，精细级锁（fine-grained locking）对并发执行有更高的容忍度，它可以允许在不同的内核结构或数据上同时执行不同的内核代码。这种方法需要更复杂的编程和设计，但可以提供更好的性能。
2. **读写锁**：这是一种特殊类型的锁，它区分了读操作和写操作。在只读操作中，多个线程可以同时持有锁，但在写操作中，只有一个线程可以持有锁。
3. **优化的互斥锁**：这些锁的设计允许在没有竞争的情况下，以较低的成本获取和释放锁。当有竞争时，它们会使用更复杂的算法（如队列）来管理锁的所有权。
4. **无锁编程**：在某些情况下，可以完全避免使用锁。这通常涉及到使用原子操作和处理器特定的同步指令。无锁编程可能会非常复杂，但是在正确使用时，可以提供非常高的性能和可扩展性。

这些模型中的每一个都有其优点和缺点，需要根据具体的应用场景和需求来选择最适合的模型。

`kern /spinlock.h`声明大内核锁，即`kernel_lock`。它还提供了`lock_kernel()`和`unlock_kernel()`，这是获取和释放锁的快捷方式。大家应该在4个位置应用大内核锁：

- 在`i386_init()`中，在BSP唤醒其他cpu之前获取锁。为了防止其他CPU在初始化过程尚未完成时就开始执行任务，从而导致系统状态不一致。
- 在`mp_main()`中，在初始化AP后获得锁，然后调用`sched_yield()`在该AP上开始运行环境。
- 在`trap()`中，当从用户模式捕获时获取锁。要确定陷阱是发生在用户态还是核心态，可以检查`tf_cs`的低位。为了保护共享数据的一致性。
- 在`env_run()`中，在切换到用户模式之前释放锁。不要太早或太晚这样做，否则你会经历竞争或死锁。



**练习**

```
上文所述，通过在适当的位置调用lock_kernel()和unlock_kernel()应用大内核锁。
```

**问题**

```
似乎使用大内核锁可以保证同一时间只有一个CPU可以运行内核代码。为什么我们仍然需要为每个CPU提供单独的内核栈?描述一个使用共享内核栈将出错的场景，即使有大内核锁的保护。
```

**代码**

先给出要打开的文件。

```
init.c->i386_init	init.c->mp_main	sched.c->sched_yield	trap.c->trap	env.c->env_run
```

代码如下

```
略，按要求加锁就行。
```

**回答**

```
大内核锁只能保证同一时间只有一个CPU可以运行内核代码，但无法保证不同CPU之间对共享资源（如内核栈）的互斥访问。
假设：
CPU1正在执行内核代码，而CPU2正在执行用户代码。CPU2触发了一个中断，需要进入内核模式执行中断处理程序。CPU2开始将中断上下文保存到内核栈上。正好在这个时候，CPU1也需要执行内核代码，并且获取了大内核锁。CPU1可能会修改内核栈上的数据，例如修改中断上下文或其他内核数据。而在此同时，CPU2正在将中断上下文保存到内核栈上。
这样就会导致数据的不一致性或损坏。
```



#### 轮转调度:练习6

您在这个实验室中的下一个任务是更改JOS内核，以便它可以以“轮询”方式在多个环境之间切换。JOS中的轮询调度机制如下:

- 新`kern/sched.c`中的函数`sched_yield()`负责选择要运行的新环境。它以循环方式顺序搜索`envs[]`数组，从之前运行的环境之后开始(如果没有之前运行的环境，则从数组的开头开始)，选择它找到的第一个状态为`ENV_RUNNABLE`的环境(参见`inc/env.h`)，并调用`env_run()`以跳转到该环境。
- `sched_yield()`绝对不能在两个cpu上同时运行同一个环境。它可以判断当前环境正在某个CPU上运行(可能是当前CPU)，因为该环境的状态将是`ENV_RUNNING`。
- 我们为大家实现了一个新的系统调用`sys_yield()`，用户环境可以调用它来调用内核的`sched_yield()`函数，从而主动将CPU让与另一个环境。

轮转调度是一种常见的调度算法，它按照时间片的大小将CPU时间平均分配给就绪队列中的进程。除了轮转调度，还有其他一些相似的调度机制，例如优先级调度、多级反馈队列调度等。

**练习6**

```c
//在sched_yield()中实现如上所述的轮询调度。别忘了修改syscall()，让它dispatch sys_yield()。
//确保在mp_main中调用sched_yield()。
//修改kern/init.c，创建三个(或者更多!)运行user/yield.c程序的环境。
```

**问题**

```
1.在env_run()的实现中，你应该调用lcr3()。在调用lcr3()之前和之后，代码都会引用变量e(至少应该这样)，它是env_run的参数。加载%cr3寄存器后，MMU使用的寻址上下文立即改变。但是，相对于给定的地址上下文，虚拟地址(即e)具有意义——地址上下文指定了虚拟地址映射到的物理地址。为什么在寻址开关前后都可以解引指针e ?

2.每当内核从一个环境切换到另一个环境时，它必须确保保存旧环境的寄存器，以便稍后可以正常恢复。为什么?这发生在哪里?
```



**注释**

```c
//实现简单的轮询调度
//
//在 envs 中循环搜索ENV_RUNNABLE环境，从该CPU上次运行的环境开始。
//切换到发现的第一个这样的环境。
//
//如果没有可运行的环境，但该CPU上之前运行的环境仍然是ENV_RUNNING，则可以选择该环境。——
//
//永远不要选择当前运行在另一个CPU上的环境(env_status == ENV_RUNNING)。
//如果没有可运行环境，只需使用下面的代码停止cpu。
```

**代码**

写代码前推荐回顾一下之前看过的`inc/env.h`；lab3 的练习8；lab3 的`env_run`

##### `sched_yield()`

```c
	// LAB 4: Your code here.
	struct Env *i = thiscpu->cpu_env;
	int32_t startid = (i) ? ENVX(i->env_id): 0;
	int32_t nextid;
	size_t j;

	for(j = 0; j < NENV; j++) {
     		nextid = (startid+j)%NENV;
     		if(envs[nextid].env_status == ENV_RUNNABLE) {
             		env_run(&envs[nextid]);
             		return;
	        }
	}
 
	if(envs[startid].env_status == ENV_RUNNING && envs[startid].env_cpunum == cpunum()) {
		env_run(&envs[startid]);
	}
 
	// sched_halt never returns
 	sched_halt();
```

 `NENV` 取模，可以确保索引始终在合法范围内。回头是不是得做一个函数表了，写的时候好找过去的函数。

改来改去的放弃思考了。

##### `i386_init`

```c
void
i386_init(void)
{
	extern char edata[], end[];

	// Before doing anything else, complete the ELF loading process.
	// Clear the uninitialized global data (BSS) section of our program.
	// This ensures that all static/global variables start out zero.
	memset(edata, 0, end - edata);

	// Initialize the console.
	// Can't call cprintf until after we do this!
	cons_init();

	cprintf("6828 decimal is %o octal!\n", 6828);

	// Lab 2 memory management initialization functions
	mem_init();

	// Lab 3 user environment initialization functions
	env_init();
	trap_init();

	// Lab 4 multiprocessor initialization functions
	mp_init();
	lapic_init();

	// Lab 4 multitasking initialization functions
	pic_init();

	// Acquire the big kernel lock before waking up APs
	// Your code here:
	lock_kernel();

	// Starting non-boot CPUs
	boot_aps();

#if defined(TEST)
	// Don't touch -- used by grading script!
	ENV_CREATE(TEST, ENV_TYPE_USER);
#else
	// Touch all you want.
	ENV_CREATE(user_yield, ENV_TYPE_USER);
	ENV_CREATE(user_yield, ENV_TYPE_USER);
	ENV_CREATE(user_yield, ENV_TYPE_USER);
#endif // TEST*

	// Schedule and run the first user environment!
	sched_yield();
}
```

6,查了一圈，最后用`grep -r "user_yield"`发现这东西完全没有提前定义。x是什么看算是临时加上的变量，什么都行，也可以看出来网上多是互相参考，我都查不出来第二个不一样命名。

**回答**

```
1.为什么在寻址开关前后都可以解引指针e(env_run)?
2.每当内核从一个环境切换到另一个环境时，它必须确保保存旧环境的寄存器，以便稍后可以正常恢复。为什么?这发生在哪里?

1.在调用 lcr3() 之前和之后，代码可以继续引用变量 e，因为在调用 lcr3() 之后，虚拟地址 e 仍然具有相同的意义。它能在旧的地址上下文中解析为相应的物理地址。但是代码需要访问新的页表所映射的物理地址，那么它需要使用新的虚拟地址进行访问，而不是使用原来的虚拟地址 e。
2.因为不保存下来就无法正确地恢复到原来的环境。这样的切换之处都是要在系统栈上建立用户态的TrapFrame。，在进入trap()函数后，语句curenv->env_tf ;将内核栈上需要保存的寄存器的状态实际保存在用户环境的env_tf域中。
```



#### 系统调用用于创建环境:练习7

尽管您的内核现在能够在多个用户级环境之间运行和切换，但仍然限于内核最初设置的运行环境。现在将实现必要的JOS系统调用，以允许用户环境创建和启动其他新用户环境。

您将提供一组不同的、更原始的JOS系统调用，用于创建新的用户模式环境。通过这些系统调用，您将能够完全在用户空间中实现类unix的fork()，以及其他创建环境的风格。为JOS编写的新系统调用如下：

- `sys_exofork`

  该系统调用创建了一个几乎是空白的新环境:没有任何东西映射到其地址空间的用户部分，环境是不可运行的。

  在`sys_exofork`调用时，新环境将具有与父环境相同的寄存器状态。在父进程中，`sys_exofork`将返回新创建环境的`envid_t`(如果环境分配失败，则返回负的错误码)。然而，在子进程中，它将返回0。

- `sys_env_set_status`

  将指定环境的状态设置为`ENV_RUNNABLE`或`ENV_NOT_RUNNABLE`。该系统调用通常用于标记一个新环境，在其地址空间和寄存器状态完全初始化之后，该环境就可以运行了。

- `sys_page_alloc`

  分配一页物理内存，并将其映射到给定环境的地址空间中的给定虚拟地址。

- `sys_page_map`

  将页映射(而不是页的内容)从一个环境的地址空间复制到另一个环境的地址空间，保持内存共享，使得新映射和旧映射都指向物理内存的同一页。

- `sys_page_unmap`

  解除映射到给定环境中给定虚拟地址的页。

对于上述所有接受环境id的系统调用，JOS内核支持这样一种约定，即值0表示“当前环境”。`kern/env.c`中的`envid2env()`实现了这个约定。

**练习7**

```
在kern/syscall.c中实现上述系统调用，并确保syscall()调用它们。你需要使用kern/pmap.c和kern/env.c中的各种函数，特别是envid2env()。现在，每当调用envid2env()时，都将checkperm参数传入1。请确保检查了所有无效的系统调用参数，在这种情况下返回-E_INVAL。使用user/dumbfork测试你的JOS内核，确保它能正常工作。
```

**前置工作**

1. 注释：`envid2env`

   函数 `envid2env`，用于根据给定的 `envid` 查找对应的 `struct Env` 结构体，并将结果存储在 `env_store` 指针指向的位置。

   ```c
   //
   //将envid转换为env指针
   //如果设置了checkperm，则指定的环境必须是当前环境或当前环境的直接子环境
   //
   //返回
   // 0表示成功，-E_BAD_ENV表示错误。
   //成功时，将*env_store设置为环境变量。
   //发生错误时，将*env_store设置为NULL。
   //
   envid2env(envid_t envid, struct Env **env_store, bool checkperm)
   ```

2. 看lab3代码作用。part A。env相关函数

3. `inc/trap.h`

4. `inc/mmu.h`(PGOFF)

5. `envid`是什么？

   `envid` 是一个用于标识环境（或进程）的唯一标识符，它通常被存储在操作系统内部的数据结构中。通过将 `envid` 传递给 `envid2env` 函数，操作系统可以根据该标识符找到对应的环境结构体，并进行相应的操作。

6. 看之前lab写过的函数









##### `sys_exofork`

该系统调用创建了一个几乎是空白的新环境:没有任何东西映射到其地址空间的用户部分，环境是不可运行的。

**注释**

```c
//分配一个新环境
//返回新环境的env_id，错误时返回< 0。错误情况:
//没有空闲环境，则- e_no_free_env。
//内存耗尽，则- e_no_mem。

//使用来自kern/env.c的env_alloc()创建新环境。
//它应该保持env_alloc创建它的状态，除了将status设置为ENV_NOT_RUNNABLE，并且从当前环境复制寄存器集
//调整为sys_exofork将返回0。
```

**代码**

```c
	struct Env *new_env;
	if(env_alloc(&new_env, curenv->env_id) < 0)
		return 0;
	new_env->env_status = ENV_NOT_RUNNABLE;
	new_env->env_tf = curenv->env_tf;
	new_env->env_tf.tf_regs.reg_eax = 0;
	
	return new_env->env_id;
```



##### `sys_env_set_status`

将指定环境的状态设置为`ENV_RUNNABLE`或`ENV_NOT_RUNNABLE`。该系统调用通常用于标记一个新环境，在其地址空间和寄存器状态完全初始化之后，该环境就可以运行了。

**注释**

```c
//将envid的env_status设置为status，它必须是ENV_RUNNABLE
//或者ENV_NOT_RUNNABLE。
//

//成功时返回0，错误时< 0返回错误:
// - e_bad_env如果环境envid当前不存在，
//或者调用者没有修改envid的权限
// - e_inval如果status不是环境的有效状态。

//提示:使用kern/Env.c中的 envid2env 函数将envid转换为struct Env。
//你应该将envid2env的第三个参数设置为1，它将检查当前环境是否有权限设置envid的状态。
```

**代码**

```c
	struct Env *env_store;
	
	if(status != ENV_RUNNABLE && status != ENV_NOT_RUNNABLE)
		return -E_INVAL;
	int err_code = envid2env(envid, &env_store, 1);
	if(err_code < 0){
		return -E_BAD_ENV;
	}
	env_store->env_status = status;
	
	return 0; 
```



##### `sys_page_alloc`

分配一页物理内存，并将其映射到给定环境的地址空间中的给定虚拟地址。

**注释**

```c
//分配一页内存，并将其映射到地址空间 envid 中的 va ，权限为perm。
//页面内容设置为0
//如果一页已经映射到'va'，那么该页将被解除映射。
//
// perm——PTE_U | PTE_P 必须设置，PTE_AVAIL | PTE_W可以设置，也可以不设置，
//但不能设置其他比特位参见inc/mmu.h中的PTE_SYSCALL。
//
//成功时返回0，错误时返回< 0错误:
// - e_bad_env如果环境envid当前不存在，
//或者调用者没有修改envid的权限
// - e_inval如果va >= UTOP，或va不是页对齐的。
// - e_inval如果 perm 不合适(见上文)。
// - e_no_mem如果没有内存可分配给新页，
//或分配任何必要的页表。

//提示:这个函数是kern/pmap.c中的page_alloc()和page_insert()的包装器。
//你编写的大部分新代码应该用于检查参数的正确性。
//如果page_insert()失败，记得释放已分配的页!
```

**代码**

要判断一个虚拟地址 `va` 是否是页对齐的，可以检查它的低12位是否为零。如果低12位为零，那么该地址就是页对齐的；如果低12位不为零，则说明地址不是页对齐的。这里的PGOFF就是这个原理。

这里用那两个函数一定要回去看，不然有些参数可能会出问题。

```c
sys_page_alloc(envid_t envid, void *va, int perm){
	struct Env *env;

// 调用函数 envid2env(envid, &env, 1) 来获取指定 envid 对应的环境结构体，并将结果存储在 env 中。然后检测一些参数是否合法。
	if(envid2env(envid, &env, 1) < 0)
		return -E_BAD_ENV;
	if((int)va >= UTOP || PGOFF(va))
		return -E_INVAL;
	if((perm & PTE_SYSCALL) == 0)
		return -E_INVAL;
	if(perm & ~PTE_SYSCALL)
		return -E_INVAL;

// 分配物理页。根据指定的标志分配一个物理页，并返回该页的信息。将一个物理页 pp 映射到给定的虚拟地址 va 上，并设置相应的权限 perm。
	struct PageInfo *pp = page_alloc(ALLOC_ZERO);
	if(!pp)
		return -E_NO_MEM;
	if(page_insert(env->env_pgdir, pp, va, perm) < 0)
		return -E_NO_MEM;
	
	return 0;
}
```



##### `sys_page_map`

将页映射(而不是页的内容)从一个环境的地址空间复制到另一个环境的地址空间，保持内存共享，使得新映射和旧映射都指向物理内存的同一页。

**注释**

```c
// 将 srcva 地址空间中的内存页映射到 dstva 地址空间中的 srcva ,并赋予 perm 权限.
// Perm的限制与sys_page_alloc相同,只是它不能授予对只读页的写访问权.

//
//成功时返回0，错误时返回< 0错误:
// - E_BAD_ENV如果srcenvid和/或dstenvid当前不存在，
//或者调用者没有权限更改其中一个
// - E_INVAL
// 如果srcva >= UTOP或srcva不是页对齐的，
// 或dstva >= UTOP或dstva不是页面对齐的。
// srcva没有映射到srcenvid的地址空间中。
// 如果perm不合适(参见sys_page_alloc)
// 如果 (perm & PTE_W)，但srcva在srcenvid中是只读的
// -E_NO_MEM，如果没有内存来分配任何必要的页表。

//提示:这个函数是page_lookup()和page_insert(),来自于kern/pmap.c
//同样，你编写的大部分新代码应该是检查参数的正确性。
//使用page_lookup()的第三个参数来检查当前页面的权限
```

**代码**

```c
static int
sys_page_map(envid_t srcenvid, void *srcva,
	     envid_t dstenvid, void *dstva, int perm)
{
	// Hint: This function is a wrapper around page_lookup() and
	//   page_insert() from kern/pmap.c.
	//   Again, most of the new code you write should be to check the
	//   parameters for correctness.
	//   Use the third argument to page_lookup() to
	//   check the current permissions on the page.

	// LAB 4: Your code here.
	struct Env *srcenv, *dstenv;
	struct PageInfo *srcpp, *dstpp;
	pte_t *pte = 0;
	
	if (envid2env(srcenvid, &srcenv, 1) < 0 || envid2env(dstenvid, &dstenv, 1))
		return -E_BAD_ENV;
	if (((uintptr_t)srcva >= UTOP || (uintptr_t)dstva >= UTOP) || (PGOFF(srcva) || PGOFF(dstva)))
		return -E_INVAL;
	if((perm & PTE_SYSCALL) == 0)
		return -E_INVAL;
	if(perm & ~PTE_SYSCALL)
		return -E_INVAL;
	if(!(srcpp = page_lookup(srcenv->env_pgdir, srcva, &pte)))
		return -E_INVAL;
	if((perm & PTE_W) && (*pte & PTE_W) == 0)
		return -E_INVAL;
	if(page_insert(dstenv->env_pgdir, srcpp, dstva, perm) < 0)
		return -E_NO_MEM;
    return 0;
}
```

这里写的时候不会就看看过去的代码。



##### `sys_page_unmap`

解除映射到给定环境中给定虚拟地址的页。

**注释**

```c
//解除 envid 地址空间中 va 处内存页的映射。
//如果没有映射页，该函数会静默地成功
//
//成功时返回0，错误时返回< 0错误:
// - E_BAD_ENV如果环境envid当前不存在，
//或者调用者没有修改envid的权限
// - E_INVAL如果va >= UTOP，或va不是页对齐的。
```

**代码**

```c
sys_page_unmap(envid_t envid, void *va){
	struct Env *env;
 
	if (envid2env(envid, &env, 1) < 0) 
     		return -E_BAD_ENV;
	if ((uintptr_t)va >= UTOP || PGOFF(va))
    		return -E_INVAL;
	page_remove(env->env_pgdir, va);
		return 0;
}
```



**最后记得放到系统调用里**

```c
int32_t
syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
{
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	// LAB 3: Your code here.
	switch (syscallno) {
	case SYS_cputs:
		sys_cputs((const char *)a1,a2);
		return -E_INVAL;
	case SYS_cgetc:
		return sys_cgetc();
	case SYS_getenvid:
		return sys_getenvid();
	case SYS_env_destroy:
		return sys_env_destroy(a1);
	case SYS_yield:
		sys_yield();
		return 0;
	case SYS_exofork:
        	return sys_exofork();
    case SYS_env_set_status:
    		return sys_env_set_status(a1, a2);
	case SYS_page_alloc:
        	return sys_page_alloc(a1, (void *) a2, a3);
	case SYS_page_map:
        	return sys_page_map(a1, (void *) a2, a3, (void *) a4, a5);
	case SYS_page_unmap:
        	return sys_page_unmap(a1, (void *) a2);
	default:
		return -E_INVAL;
	}
}
```

**结语**

1. 这里会出现大量的

   `user_mem_check`输出，我把输出注释掉了。

2. 为期一天多终于把程序完美的运行起来了，泪目了。

```
感谢该网页给出每一步的输出正确结果，让我好比对错误
https://www.dingmos.com/index.php/archives/10/
```

3. 关于为什么要放到同一页

   将内存映射到同一页上主要是为了实现内存共享和提高内存访问效率。

   

### Part B:写时复制

Unix 利用虚拟内存硬件来允许父子进程共享映射到各自地址空间的内存，直到其中一个进程实际修改它。 这种技术称为写时复制（Copy-on-Write Fork）。为此，在fork上，内核会将地址空间映射从父级复制到子级而不是映射页面的内容，同时将现在共享的页面标记为只读。 当其中一个进程尝试写入其中一个共享页面时，该进程会发生页面错误。

**前言**

对于Unix通过系统调用创建子进程，开销最大的是将父进程的地址空间复制到子进程。

在调用之后，子进程经常会立即调用，用一个新程序替换子进程的内存。在这种情况下，花在复制父进程地址空间上的时间基本上是浪费了，因为子进程在调用之前只会使用很少的内存。

因此，后续的Unix允许父进程和子进程共享映射到各自地址空间中的内存，直到其中一个进程实际修改为止。这种技术称为写时复制(copy-on-write)。

为此，内核将地址空间映射从父进程复制到子进程，而不是映射页的内容，同时将现在共享的页标记为只读。当两个进程中的一个试图写入这些共享页时，该进程将发生缺页异常。

在这一点上，Unix内核意识到该页实际上是一个“虚拟”或“写时复制”副本，因此它为出错的进程创建了一个新的、私有的、可写的该页副本。这样，在实际写入各个页之前，各个页的内容实际上不会被复制。这种优化使得在子进程中紧跟在a之后的开销更小:子进程在调用之前可能只需要复制一页(栈的当前页)。



#### 用户级页错误处理

用户级写时复制需要知道写保护页上的缺页异常，因此我们首先要实现这一点。

在操作系统中，通常会使用按需分页（demand paging）的技术来延迟内存分配和映射，从而节省内存和加快进程的启动速度。

按需分页是一种虚拟内存管理技术，它允许进程只在需要时才将虚拟地址映射到物理内存，而不是一次性将整个地址空间都映射到物理内存中。

当一个进程首次访问尚未映射到物理内存的虚拟地址时，会触发缺页异常（page fault）。这时操作系统会捕获该异常，并根据异常的类型以及访问的虚拟地址的位置，采取相应的行动。

这有很多内核需要跟踪的大量信息。您将决定如何处理用户空间中的每个缺页异常，而不是采用传统的Unix方法，在用户空间中，bug的破坏性较小。这种设计还有一个额外的好处，即允许程序在定义内存区域时具有极大的灵活性。稍后，您将使用用户级页面错误处理来映射和访问基于磁盘的文件系统上的文件。

#### 设置页面异常处理程序:练习8

为了处理自己的缺页异常，用户环境需要向JOS内核注册一个缺页异常处理程序入口点。用户环境通过新的`sys_env_set_pgfault_upcall`系统调用注册其缺页异常入口点。我们已经向Env结构添加了一个新成员，`env_pgfault_upcall`，以记录此信息。

```c
//练习8,实现sys_env_set_pgfault_upcall系统调用。在查找目标环境的环境ID时，请确保启用权限检查，因为这是一个“危险”的系统调用。
```

**注释**

```c
//通过修改相应的struct Env的 env_pgfault_upcall 字段，设置 envid 的页面异常向上调用。
//当 envid 导致缺页异常时，内核将把错误记录压入异常堆栈，然后分支到 func 。
//
//成功时返回0，错误时返回< 0错误:
// - e_bad_env如果环境envid当前不存在，或者调用者没有修改envid的权限。
```

##### `sys_env_set_pgfault_upcall`

设置指定环境（`envid`）的页面错误处理函数（`pgfault_upcall`）。

**代码**

```
static int
sys_env_set_pgfault_upcall(envid_t envid, void *func)
{
	// LAB 4: Your code here.
	struct Env *env;
	int err_code = envid2env(envid, &env, 1);
	
	if(err_code < 0)
		return -E_BAD_ENV;
	
	env->env_pgfault_upcall = func;
	return 0;	
}
```

这里推荐回顾一下lab4的`inc/env.h`，结构体env增加了一下新东西。写完记得添加。

```
        case SYS_env_set_pgfault_upcall:
        	return sys_env_set_pgfault_upcall(a1, (void *) a2);
```



#### 用户环境中的正常和异常堆栈

在JOS操作系统中，用户环境通常在普通用户栈上运行，其栈顶（ESP寄存器）初始位置为`USTACKTOP`。用户环境执行期间，栈数据被保存在从`USTACKTOP-PGSIZE`到`USTACKTOP-1`的地址范围内的页面中。(用`memlayout.h`配合观看)

当用户环境处于用户态（用户模式）执行时，如果发生了缺页异常，例如访问尚未映射到物理内存的虚拟地址，内核会介入处理这个异常。**为了保证安全性和可靠性，内核会在用户异常栈上（用户环境的特定栈区域）运行指定的用户级缺页异常处理程序，而不是直接在用户环境的普通用户栈上运行异常处理代码。**

这种做法类似于处理器在从用户态转换到核心态时的堆栈切换过程。当处理器由用户态切换到核心态时，它会自动切换到内核栈，以便在核心态执行内核代码。类似地，JOS内核为用户环境实现了自动的堆栈切换，以在用户异常发生时，将控制权转移到内核的用户异常栈上，执行预定义的异常处理程序。

JOS用户异常栈的大小也是一页，其顶部被定义为虚拟地址`UXSTACKTOP`，因此用户异常栈的有效字节是从`UXSTACKTOP- PGSIZE`到`UXSTACKTOP-1`(包括`UXSTACKTOP-1`)。在此异常堆栈上运行时，用户级缺页异常处理程序可以使用JOS的常规系统调用来映射新页或调整映射，以便修复最初导致缺页异常的任何问题。然后，用户级的页错误处理程序通过汇编语言存根返回到原始堆栈上的错误代码。

每个希望支持用户级页异常处理的用户环境都需要使用A部分介绍的`sys_page_alloc()`系统调用为自己的异常栈分配内存。

**三个栈**

```
　　[KSTACKTOP - KSTKSIZE,  KSTACKTOP) 
　　内核态系统栈

　　[UXSTACKTOP - PGSIZE, UXSTACKTOP )
　　用户态错误处理栈

　　[UTEXT, USTACKTOP)
　　用户态运行栈
```

内核态系统栈是运行内核相关程序的栈，在有中断被触发之后，CPU会将栈自动切换到内核栈上来，而内核栈是在`kern/trap.c`的`trap_init_percpu()`中设置的。

当正常执行过程中发生了页错误，那么栈的切换是

- 用户运行栈—>内核栈—>异常栈

而如果在异常处理程序中发生了也错误，那么栈的切换是

- 异常栈—>内核栈—>异常栈





#### 调用用户页面错误处理程序:练习9

现在需要修改`kern/trap.c`中的缺页异常处理代码，以便在用户状态下处理缺页异常，如下所示。我们将发生故障时的用户环境状态称为`trap-time`状态。

如果没有注册缺页异常处理程序，JOS内核会像以前一样用一条消息销毁用户环境。否则，内核在异常栈上设置一个陷阱帧，看起来像`inc/trap.h`中的`struct UTrapframe`:

```
                    <-- UXSTACKTOP
trap-time esp
trap-time eflags
trap-time eip
trap-time eax       start of struct PushRegs
trap-time ecx
trap-time edx
trap-time ebx
trap-time esp
trap-time ebp
trap-time esi
trap-time edi       end of struct PushRegs
tf_err (error code)
fault_va            <-- %esp when handler is run
```

内核接下来安排用户环境使用该栈帧恢复异常栈上运行的缺页异常处理程序的执行。你必须想办法让这一切发生。`fault_va`是导致缺页异常的虚拟地址。

如果在发生异常时，用户环境已经在用户异常堆栈上运行，那么缺页异常处理程序本身就发生了异常。在这种情况下，您应该在当前的`tf->tf_esp`下启动新的堆栈帧，而不是在`UXSTACKTOP`。你应该首先推送一个32位的空单词，然后是一个`struct UTrapframe`。

要测试`tf->tf_esp`是否已经在用户异常栈上，请检查它是否在`UXSTACKTOP-PGSIZE`和`UXSTACKTOP-1`之间(包括`UXSTACKTOP-1`)。

```
练习9
在kern/trap.c中实现page_fault_handler中的代码，用于将缺页异常分派给用户态处理程序。在写入异常栈时，请确保采取适当的预防措施。(如果用户环境耗尽异常栈上的空间会发生什么?)
```

**注释**

```
//我们已经处理了核心态异常，所以如果我们到这里，就说明缺页异常发生在用户态。
//调用环境的缺页调用(如果存在的话)。
//在用户异常栈上设置一个缺页异常栈帧(在UXSTACKTOP下面)，然后分支到curenv->env_pgfault_upcall。
//
//向上调用缺页异常可能会导致另一个缺页异常，在这种情况下，我们递归地分支到向上调用缺页异常，将另一个缺页异常堆栈帧压入用户异常堆栈的顶部。
//
//对于我们从缺页异常(lib/pfentry.S)返回的代码来说，在陷阱时间栈的顶部有一个暂写空间是很方便的;它允许我们更容易地恢复eip/esp。
//在非递归的情况下，我们不必担心这一点，因为普通用户栈的顶部是空闲的。
//在递归的情况下，这意味着我们必须在异常栈的当前顶部和新栈帧之间留下一个额外的单词，因为异常栈是陷阱时间栈。
//
//如果没有缺页异常上调，环境没有为其异常栈分配页，或者无法写入，或者异常栈溢出，则销毁导致异常的环境。
//注意，grade脚本假设你首先会检查是否有页面异常，如果没有就打印"user fault va"消息。剩下的三种检查可以组合成一个测试。
//
//提示:
// user_mem_assert()和env_run()在这里很有用
//修改 curenv->env_tf 以更改用户环境运行的内容
// ( tf 变量指向 curenv->env_tf )。
//实验4:这里是你的代码
```

**梳理**

```
1.这里的user_mem_assert()在pamp.c
    user_mem_assert(struct Env *env, const void *va, size_t len, int perm)
    该函数用于检查用户空间内存区域是否满足指定的权限要求。
2.env_run(struct Env *e)
	启动在用户模式下运行的给定环境。
3.需要判断的3点:则销毁导致异常的环境
	1.如果没有缺页异常上调，环境没有为其异常栈分配页
	2.无法写入
	3.异常栈溢出
4.看inc/trap.c中的新增的UTrapframe栈	
5.上面注释是否递归这里，可以参考一下大佬的的练习9回答部分
	https://blog.csdn.net/bysui/article/details/51842817
	不在栈上就不需要递归，但是正在栈上需要留出一个eip/esp的空间，也就是4字节。
6.上面重要的一段话
	如果在发生异常时，用户环境已经在用户异常堆栈上运行，那么缺页异常处理程序本身就发生了异常。在这种情况下，您应该在当前的`tf->tf_esp`下启动新的堆栈帧，而不是在UXSTACKTOP。你应该首先推送一个32位的空单词，然后是一个struct UTrapframe。
	要测试tf->tf_esp是否已经在用户异常栈上，请检查它是否在UXSTACKTOP-PGSIZE和UXSTACKTOP-1之间(包括UXSTACKTOP-1)。
```

##### `page_fault_handler`

**代码**

梳理的还是有些乱

```
	struct UTrapframe *utf;
	
	if (curenv->env_pgfault_upcall) {
		if (tf->tf_esp < UXSTACKTOP && tf->tf_esp >= UXSTACKTOP - PGSIZE) {
			//In the exception stack
			utf = (struct UTrapframe*)(tf->tf_esp-4-sizeof(struct UTrapframe));
		} else {
			// outside the exception stack
			utf = (struct UTrapframe*)(UXSTACKTOP-sizeof(struct UTrapframe));
		}
		
		user_mem_assert(curenv, (const void *) utf, 
			sizeof(struct UTrapframe), PTE_P|PTE_W);
				
		utf->utf_fault_va = fault_va;	
		utf->utf_err = tf->tf_trapno;
		utf->utf_regs = tf->tf_regs;
		utf->utf_eip = tf->tf_eip;
		utf->utf_eflags = tf->tf_eflags;
		utf->utf_esp = tf->tf_esp;
		
		tf->tf_eip = (uint32_t)curenv->env_pgfault_upcall;
		tf->tf_esp = (uint32_t)utf;
		env_run(curenv);
	} else {		
		// Destroy the environment that caused the fault.	
		cprintf("[%08x] user fault va %08x ip %08x\n",
				curenv->env_id, fault_va, tf->tf_eip);
		print_trapframe(tf);
		env_destroy(curenv);
	}
```

1. 这里的`user_mem_assert`自带销毁功能

2. 相比于`UTrapframe`，这里多了`utf_fault_va`，因为要记录触发错误的内存地址，同时还少了es,ds,ss等。因为从用户态栈切换到异常栈，或者从异常栈再切换回去，实际上都是一个用户进程，所以不涉及到段的切换，不用记录。



#### 用户模式页面错误入口点:练习10,11

**练习10**

接下来，您需要实现汇编例程，该例程将负责调用C页异常处理程序，并在原始异常指令处恢复执行。该汇编例程是使用`sys_env_set_pgfault_upcall()`注册到内核的处理程序。

```
在lib/pfentry.S中实现_pgfault_upcall例程。有趣的是返回到导致缺页异常的用户代码的原点。您将直接返回到那里，而无需返回到内核。困难的部分是同时交换栈和重新加载EIP。
```

**注释**

```
//每当在用户空间引起缺页异常时，我们都要求内核将我们重定向到该函数(请参见pgfault.c中对sys_set_pgfault_handler的调用)。
//
//当实际发生缺页异常时，如果我们不在user异常栈上，内核将我们的ESP切换到user异常栈，然后它将UTrapframe压入我们的user异常栈
//异常栈:
//
// trap-time esp
// trap-time eflags
// trap-time eip
// utf_regs.reg_eax
//……
// utf_regs.reg_esi
// utf_regs.reg_edi
// utf_err(error code)
// utf_fault_va <——%esp
//
//如果这是一个递归错误，内核将在陷阱时间上方为我们保留一个空白字(esp)，以便我们展开递归调用时进行临时工作。
//
//然后在C代码中调用适当的缺页异常处理程序，它由全局变量 _pgfault_handler 指向。

//现在C语言的页面异常处理程序已经返回，你必须返回
//到trap-time state。
//将trap-time %eip推入trap-time栈。
//
//说明:
//我们必须准备陷阱时间栈，以便最终返回重新执行发生错误的指令。
//不幸的是，我们不能直接从异常栈返回:
//我们不能调用 jmp ，因为这需要我们将地址加载到寄存器中，并且所有寄存器在返回后必须有它们的trap-time值。
//我们也不能从异常堆栈中调用 ret ，因为如果我们这样做，%esp将具有错误的值。
//因此，我们将trap-time %eip压入*trap-time*栈!
//下面我们将切换到该堆栈并调用 ret ，它将恢复%eip到错误前的值。
//
//如果在异常栈上发生递归错误，
//注意，我们现在推送的单词将放入内核为我们保留的空白单词中。
//
//在剩余的代码中，仔细考虑哪些寄存器可用于中间计算。你
//可能会发现你不得不以不明显的方式重新排列代码，因为寄存器成为不可用的临时空间。
//
//实验4:这里是你的代码

//恢复trap时间寄存器。这样做之后，就不能再修改任何通用寄存器了。
//实验4:这里是你的代码

//从栈中恢复eflags。这样做之后，就不能再使用算术运算或任何其他修改eflags的操作了。
//实验4:这里是你的代码

//切换回调整后的trap时间栈。
//实验4:这里是你的代码

//返回重新执行发生错误的指令。
//实验4:这里是你的代码

```

**步骤**：明确这个入口点函数的作用

```
已经有的汇编:将异常栈传递给调用页面错误处理函数，处理完以后恢复异常栈

1.恢复trap时间寄存器
2.从栈中恢复eflags。
3.切换回调整后的trap时间栈。
4.返回重新执行发生错误的指令。
要注意的点:
1.返回到导致缺页异常的用户代码的原点。
2.忽略异常栈中的 fault_va 和 tf_err。在恢复处理器状态后，我们不再需要这些值。
3.utf_esp 预留 4 字节空间，这样在调用 ret 返回时，ret 指令会读取这个 32 位的值，恢复执行页面错误发生时的指令。

这里用16进制的值发现会更舒服些啊。
```

##### `pfentry.S`

**代码**

```
movl 0x28(%esp), %eax	//uft_eip
addl $8, %esp
subl $4, 0x28(%esp)
movl 0x28(%esp), %ebp	//utf_esp - 4
movl %eax, (%ebp)
// %ebp = utf_eip(addr) -> utf_esp-4(value)

popal 
// pop PushRegs and utf_eip

addl $4, %esp
popfl
// pop uft_eflags

popl %esp
// The stack pointer switches back to the adjusted exception stack.

ret
//Returns to re-execute the instruction in which the error occurred
```

这里对于汇编的理解错误了，`subl $4, 0x28(%esp)` 的结果存放在 `0x28(%esp)`中。

这段代码算是仅通过`mov`和`pop`实现恢复页面异常发生时的处理器状态。



**练习11**

最后，需要实现用户级缺页处理机制的C用户库端。

```
在lib/pgfault.c中完成set_pgfault_handler()。
```

**注释**

又又又是读注释

```
//汇编语言pgfault入口点定义在lib/pfentry.S中。
extern void _pgfault_upcall(void);
//指向当前安装的c语言pgfault处理程序的指针
void (*_pgfault_handler)(struct UTrapframe *utf);

//
//设置页面异常处理函数。
//如果还没有，_pgfault_handler将为0。
//第一次注册处理程序时，我们需要分配一个异常栈(顶部位于UXSTACKTOP的一页内存)，并告诉内核在发生缺页异常时调用汇编语言的_pgfault_upcall例程。
//
```

注意前面说的：该汇编例程是使用`sys_env_set_pgfault_upcall()`注册到内核的处理程序。

##### `set_pgfault_handler`

**代码**

```
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
	int r;

	if (_pgfault_handler == 0) {
		// First time through!
		// LAB 4: Your code here.
		sys_page_alloc(sys_getenvid(), (void *)(UXSTACKTOP - PGSIZE), PTE_SYSCALL);
		sys_env_set_pgfault_upcall(sys_getenvid(), _pgfault_upcall);		

	}

	// Save handler pointer for assembly to call.
	_pgfault_handler = handler;
}
```

不是，这东西不提前提示一下的吗？`sys_getenvid`，这找半天。这些参数找出来秒懂，前提是找到。

**特别注意：`user_mem_check()`中的`cprintf()`需要去掉，不然`faultregs`这个测试可能会过不了，改了好久。**



#### 实现写时复制Fork:练习12

我们已经在`lib/fork.c`中提供了一个框架。类似，应该创建一个新环境，然后扫描父环境的整个地址空间，并在子环境中建立相应的页映射。关键的区别在于，虽然复制了页，但最初只复制页映射。仅当其中一个环境试图写入每个页面时，才复制它。

基本的控制流程如下:

1. 父进程使用上面实现的函数安装为c级的页面异常处理程序。`pgfault()` `set_pgfault_handler()`

2. 调用父进程来创建子进程。`sys_exofork()`

3. 对于位于UTOP下的地址空间中的每个可写或写时复制页，父进程调用该函数，将该页的写时复制映射到子进程的地址空间中，然后在自己的地址空间中重新映射该页的写时复制。

   **[注意:这里的排序(即先在子页面中标记为COW，再在父页面中标记)实际上很重要!你知道为什么吗?试着想一个具体的例子，如果颠倒顺序可能会引起麻烦。]**设置两个pte，使页不可写，并将其包含在"avail"字段中，以区分写时复制的页和真正的只读页。

   不过，异常栈不会以这种方式重新映射。相反，您需要在子进程中为异常栈分配一个新页。由于缺页异常处理程序将执行实际的复制，而缺页异常处理程序运行在异常栈上，因此不能在写时复制异常栈:谁会复制它呢?

   `Fork()`也需要处理存在但不可写或写时复制的页面。

4. 父进程设置用户页面异常入口点，使子进程看起来像自己的。

5. 子进程现在可以运行了，因此父进程将其标记为可运行。

每当某个环境写入尚未写入的写时复制页时，就会发生缺页异常。以下是用户页面异常处理程序的控制流:

1. 内核将缺页异常传播到`_pgfault_upcall`，后者调用`fork()`的`pgfault()`处理程序。
2. `pgfault()`检查异常是否是写异常(检查错误码中的`FEC_WR`)，并且该页的PTE标记为`PTE_COW`。如果没有，那就惊慌吧。
3. `Pgfault()`分配一个映射在临时位置的新页，并将发生故障的页的内容复制到临时位置。然后，错误处理程序将新页映射到具有读/写权限的适当地址，而不是旧的只读映射。

用户级的`lib/fork.c`代码在执行上述几个操作时，必须查阅环境的页表(例如，某一页的页表项标记为PTE_COW)。内核将环境的页表映射到UVPT正是为此目的。它使用了一个巧妙的映射技巧，使查找用户代码的pte变得容易。`lib/entry.S`设置uvpt和uvpd，使您可以轻松查找`lib/fork.c`中的页表信息。

```
练习12
实现fork.c

用叉树程序测试代码。它应该产生以下消息，其中穿插着 new env, free env 和 exit graceful 消息。消息可能不是按此顺序出现的，而且环境id可能不同。
```

**梳理**

```
fork控制流如下:

1.父进程使用 pgfault() 函数设置C级页面异常处理程序，通过 set_pgfault_handler() 进行安装。

2.父进程通过 sys_exofork() 创建子进程。

3.对于位于地址空间中 UTOP 以下的每个可写或写时复制页，父进程：
    a.在子进程中标记为COW并映射写时复制页
    b.在父进程中重新映射为COW页，并设置 PTE 为不可写

4.父进程设置子进程的用户页面异常入口，使其与父进程相同。

5.标记子进程为可运行状态。

每次某个环境对从未写过的COW页进行写操作时，就会发生 page fault。 接下来就要交给 user page fault handler处理:

1.内核将缺页异常传递给 _pgfault_upcall，后者调用父进程的 pgfault() 处理程序。

2.pgfault() 检查是否为写异常并且页的PTE标记为COW。

3.如果是COW异常，pgfault() 在子进程中映射新的临时页，并将发生故障的页内容复制到临时页。然后，更新错误处理程序将新页映射到适当地址，以便子进程具有读/写权限。
注意：颠倒步骤3中子进程和父进程的标记顺序可能会导致问题，因为写时复制的逻辑会被破坏。为了处理异常栈，需要在子进程中为其分配新的异常栈页。

4.子进程现在可以运行，标记为可运行状态。
```

通常情况下，页目录和页表是连续存放的，页目录在前，页表在后。所以才有`.set uvpd, (UVPT+(UVPT>>12)*4)`

写代码前可以去`mmu.h`回顾一些判断的值。





##### `pgfault`

**注释**

```c
//检查错误访问是否(1)是写访问，(2)是写时复制页面。如果没有，那就惊慌吧。
//提示:
//在uvpt使用只读页表映射
//(参见<inc/memlayout.h>)。
//实验4:这里是你的代码

//分配一个新页，映射到一个临时位置(PFTEMP)，
//将数据从旧页面复制到新页面，然后将新页面移动到旧页面的地址。
//提示:
//你应该进行三次系统调用
//实验4:这里是你的代码

```



**代码**

啊啊啊，好难写，先把`inc/mmu.h`全部读完再写,没宏了解那些没用过的宏写不来一点。

```c
static void
pgfault(struct UTrapframe *utf)
{
	void *addr = (void *) utf->utf_fault_va;
	uint32_t err = utf->utf_err;
	int r;

	// Check that the faulting access was (1) a write, and (2) to a
	// copy-on-write page.  If not, panic.
	// Hint:
	//   Use the read-only page table mappings at uvpt
	//   (see <inc/memlayout.h>).

	// LAB 4: Your code here.
	if(!(err & FEC_WR) && !(uvpt[PGNUM(addr)] & PTE_COW)){
		panic("page fault: Write exception and the page's PTE is marked as COW\n");
	}

// Allocate a new page, map it at a temporary location (PFTEMP),
// copy the data from the old page to the new page, then move the new
// page to the old page's address.
// Hint:
//   You should make three system calls.
//   No need to explicitly delete the old page's mapping.
	addr = ROUNDDOWN(addr, PGSIZE);
	if ((r = sys_page_alloc(0, PFTEMP, PTE_P|PTE_U|PTE_W)) < 0)
  		panic("sys_page_alloc: %e", r);
	memcpy((void *)PFTEMP, addr, PGSIZE);
	if ((r = sys_page_map(0, PFTEMP, 0, addr, PTE_P|PTE_U|PTE_W)) < 0)
  		panic("sys_page_map: %e", r);
	if ((r = sys_page_unmap(0, PFTEMP)) < 0)
  		panic("sys_page_unmap: %e", r);
}
```

注意写时复制策略用的是一个物理内存页面，一开始，所以像`envid`是一样的。这里的代码使用 `sys_page_unmap` 将临时页 PFTEMP 从当前进程的虚拟地址空间解除映射，释放临时页的映射，确保不会产生冗余的映射。

这段代码的目的就是保存了页面故障的内容，其他进程用旧页面，引发页面故障的进程用临时页面。



##### `duppage`

**注释**

```c
//将虚拟页pn(地址pn*PGSIZE)映射到目标envid的相同虚拟地址。
//如果页是可写的或写时复制的，则必须在写时复制创建新的映射，然后我们的映射也必须标记为写时复制。
//(练习:如果在这个函数开始时就已经是写时复制了，为什么还要再次标记它呢?)
//
//成功时返回0，错误时返回< 0
//发生错误时使用panic也是可以的
```



**代码**

```c
static int
duppage(envid_t envid, unsigned pn)
{
	int r;
	uint32_t va = pn * PGSIZE;
	envid_t cur_envid = sys_getenvid();
	// LAB 4: Your code here.
	if((uvpt[pn] & PTE_W) || (uvpt[pn] & PTE_COW)){
		if((r = sys_page_map(cur_envid, (void *)va, envid, (void *)va, PTE_P | PTE_U 
			| PTE_COW)) < 0)
			panic("sys_page_map: %e\n", r);
		if((r = sys_page_map(cur_envid, (void *)va, cur_envid, (void *)va, PTE_P | 
			PTE_U | PTE_COW)) < 0)
			panic("sys_page_map: %e\n", r);
	} else {
		if((r = sys_page_map(cur_envid, (void *)va, envid, (void *)va, PTE_P | 
			PTE_U)) < 0)
			panic("sys_page_map: %e\n", r);
	}
    return 0;
}
```

这个函数会在子进程的地址空间中创建一个新的虚拟地址映射，与父进程中的指定页面共享同一物理页面。



##### `fork`

**注释**

```c
//
//具有写时复制功能的用户级fork。
//适当设置页面异常处理程序。
//创建子节点
//将地址空间和缺页异常处理程序的设置复制到子进程。
//然后将子进程标记为runnable并返回
//
//返回:子进程的envid给父进程，子进程 0给，< 0出错。
//发生错误时使用panic也是可以的
//
//提示:
//使用uvpd、uvpt和duppage。记得修复子进程中的“thisenv”。
//两个用户异常栈都不应该标记为写时复制，因此你必须为子进程的用户异常栈分配一个新页。
//
```

别忘了前面的

```
fork控制流如下:

1.父进程使用 pgfault() 函数设置C级页面异常处理程序，通过 set_pgfault_handler() 进行安装。

2.父进程通过 sys_exofork() 创建子进程。

3.对于位于地址空间中 UTOP 以下的每个可写或写时复制页，父进程：
    a.在子进程中标记为COW并映射写时复制页
    b.在父进程中重新映射为COW页，并设置 PTE 为不可写

4.父进程设置子进程的用户页面异常入口，使其与父进程相同。

5.标记子进程为可运行状态。
```



**代码**

```c
envid_t
fork(void)
{
	// LAB 4: Your code here.
 	extern void _pgfault_upcall(void);
	int r;
	uintptr_t va;
	
	set_pgfault_handler(pgfault);
	envid_t c_envid = sys_exofork();
	
	if(c_envid < 0)
		panic("sys_exofork failed\n");
	if(c_envid == 0){
		thisenv = &envs[ENVX(sys_getenvid())];
		return 0;
	}
	// Copy our address space and page fault handler setup to the child.	
	for(va = 0; va < USTACKTOP; va += PGSIZE){
		if ((uvpd[PDX(va)] & PTE_P) && (uvpt[PGNUM(va)] & (PTE_P | PTE_U))){
			duppage(c_envid, PGNUM(va));
		} 
	}
	
	// alloc a page and map child exception stack
	if ((r = sys_page_alloc(c_envid, (void *)(UXSTACKTOP-PGSIZE), 
		PTE_U | PTE_P | PTE_W)) < 0)
     		panic("sys_page_alloc: %e\n", r);

 	if ((r = sys_env_set_pgfault_upcall(c_envid, _pgfault_upcall)) < 0)
     		panic("sys_env_set_pgfault_upcall: %e\n", r);

	// Start the child environment running
	if ((r = sys_env_set_status(c_envid, ENV_RUNNABLE)) < 0)
		panic("sys_env_set_status: %e\n", r);
 
	return c_envid;	
}
```

进程这块回顾一下`env.h`，后面涉及地址还是看一下`memlayout.h`感觉后续也得梳理一个`memlayout.h`全解析。

改完代码了上面的`fork`的那个循环条件得重新理解一下。

关于我注释掉一个另一个`cprintf`以后找了2个小时bug这件事。能写成报错的那种还是尽量写成那样吧，及时报错，这样就可以在报错之外的代码找问题。



### Part C:抢占式多任务和进程间通信(IPC)

抢占式多任务： 抢占式多任务是指操作系统具有在任何时刻都能够强制中断当前正在执行的任务，并切换到其他任务执行的能力。

进程间通信(IPC)：IPC 是指在操作系统中，不同的进程之间进行数据传递和通信的机制。由于进程之间具有独立的地址空间，它们无法直接访问彼此的内存。

在实验4的最后一部分，您将修改内核以抢占不合作的环境，并允许环境之间显式传递消息。

#### 时钟中断和抢占：练习13,14

运行`user/spin`测试程序。这个测试程序分支出一个子环境，一旦它接收到CPU的控制，它就永远在一个紧密的循环中旋转。父环境和内核都不会重新获得该CPU。就保护系统不受用户态环境中的bug或恶意代码的影响而言，这显然不是理想的情况，因为任何用户态环境都可能导致整个系统停止，只要进入无限循环，而CPU就永远不会被占用。为了允许内核抢占运行环境，强制重新获得对CPU的控制，我们必须扩展JOS内核以支持来自时钟硬件的外部硬件中断。

**中断管理:实验13**

外部中断（如设备中断）被称为 IRQs。 IRQ号到 IDT 项的映射不是固定的，其会加上一个`IRQ_OFFSET`的偏移，在`picirq.c `的`pic_init`中进行了这个映射过程。外部中断的初始化，实际上就是对硬件 8259A的初始化。

**在`inc/trap.h`中，`IRQ_OFFSET`定义为十进制32。因而IDT项32-47对应于`IRQs 0-15`。例如，时钟中断是`IRQs 0`。因而，`IDT [IRQ _OFFSET+0]` (即`IDT[32]`)包含了内核中时钟中断处理程序例程的地址。**选择该`IRQ_OFFSET`是为了使设备中断不与处理器异常重叠，这显然可能导致混淆。(事实上，在运行`MS-DOS`的pc的早期，`IRQ_OFFSET`实际上是0，这确实在处理硬件中断和处理处理器异常之间造成了巨大的混乱!)

在JOS中，与`xv6 Unix`相比，我们做了一个键的简化。外部设备中断在内核中总是禁用的(与xv6类似，在用户空间启用)。**外部中断由`%eflags`寄存器的FL_IF标志位控制(参见`inc/mmu.h`)。**在设置该比特位时，将启用外部中断。虽然位可以通过几种方式进行修改，但由于我们的简化，我们将只通过在进入和离开用户模式时保存和恢复`%eflags`寄存器的过程来处理它。

**用户必须确保运行时在用户环境中设置`FL_IF`标志，以便在中断到达时，它被传递到处理器并由中断代码处理。**否则，中断将被屏蔽或忽略，直至重新启用中断。我们用引导加载程序的第一个指令屏蔽了中断，到目前为止，我们还没有重新启用它们。

```
练习13:修改kern/trapentry.S和kern/trap.c来初始化IDT中适当的项，并为IRQs 0~15 提供处理程序。然后修改kern/env.c中env_alloc()中的代码，以确保用户环境总是在启用中断的情况下运行。

还要取消sched_halt()中sti指令的注释，以便空闲 CPUs 解除中断掩码。

在调用硬件中断处理程序时，处理器从不推送错误代码。此时，读者可能需要重读80386参考手册的9.2节，或IA-32《英特尔体系结构软件开发人员手册》第3卷的5.8节。(9.2前面有,可以翻回去看看)

完成这个练习后，如果你用任何运行一定时间长度(例如spin)的测试程序运行内核，你应该会看到内核打印硬件中断的陷阱帧。虽然中断现在在处理器中启用了，但JOS还没有处理它们，因此您应该看到它将每个中断错误地归为当前运行的用户环境并销毁它。最终，它应该耗尽可以销毁的环境并放入监视器。
```

**代码**

1. 参考前面 lab3 的设置 IDT ,这里的宏在`trap.h`中
2. 要确保用户环境总是在启用中断的情况下运行

##### `trapentry.S`

```
TRAPHANDLER_NOEC(Int_timer, IRQ_OFFSET + IRQ_TIMER)
TRAPHANDLER_NOEC(Int_kbd, IRQ_OFFSET + IRQ_KBD)
TRAPHANDLER_NOEC(Int_serial, IRQ_OFFSET + IRQ_SERIAL)
TRAPHANDLER_NOEC(Int_spurious, IRQ_OFFSET + IRQ_SPURIOUS)
TRAPHANDLER_NOEC(Int_ide, IRQ_OFFSET + IRQ_IDE)
TRAPHANDLER_NOEC(Int_error, IRQ_OFFSET + IRQ_ERROR)
```

```
TRAPHANDLER_NOEC(Int_timer, IRQ_OFFSET + IRQ_TIMER)
TRAPHANDLER_NOEC(Int_kbd, IRQ_OFFSET + IRQ_KBD)
TRAPHANDLER_NOEC(Int_2, IRQ_OFFSET + 2)
TRAPHANDLER_NOEC(Int_3, IRQ_OFFSET + 3)
TRAPHANDLER_NOEC(Int_serial, IRQ_OFFSET + IRQ_SERIAL)
TRAPHANDLER_NOEC(Int_5, IRQ_OFFSET + 5)
TRAPHANDLER_NOEC(Int_6, IRQ_OFFSET + 6)
TRAPHANDLER_NOEC(Int_spurious, IRQ_OFFSET + IRQ_SPURIOUS)
TRAPHANDLER_NOEC(Int_8, IRQ_OFFSET + 8)
TRAPHANDLER_NOEC(Int_9, IRQ_OFFSET + 9)
TRAPHANDLER_NOEC(Int_10, IRQ_OFFSET + 10)
TRAPHANDLER_NOEC(Int_11, IRQ_OFFSET + 11
TRAPHANDLER_NOEC(Int_12, IRQ_OFFSET + 12)
TRAPHANDLER_NOEC(Int_13, IRQ_OFFSET + 13)
TRAPHANDLER_NOEC(Int_ide, IRQ_OFFSET + IRQ_IDE)
TRAPHANDLER_NOEC(Int_15, IRQ_OFFSET + 15)
TRAPHANDLER_NOEC(Int_error, IRQ_OFFSET + IRQ_ERROR)
```



##### `trap_init`

```c
	//lab 4: IRQs Settings
	void Int_timer();
	void Int_kbd();
	void Int_serial();
	void Int_spurious();
	void Int_ide();
	void Int_error();

	//lab 4: IRQs Settings
	SETGATE(idt[IRQ_OFFSET + IRQ_TIMER], 	 0, GD_KT, Int_timer, 	3);
	SETGATE(idt[IRQ_OFFSET + IRQ_KBD], 	 0, GD_KT, Int_kbd, 	3);
	SETGATE(idt[IRQ_OFFSET + IRQ_SERIAL], 	 0, GD_KT, Int_serial, 	3);
	SETGATE(idt[IRQ_OFFSET + IRQ_SPURIOUS],  0, GD_KT, Int_spurious,3);
	SETGATE(idt[IRQ_OFFSET + IRQ_IDE],  	 0, GD_KT, Int_ide,     3);
	SETGATE(idt[IRQ_OFFSET + IRQ_ERROR],     0, GD_KT, Int_error,   3);
```

```
	void Int_timer();
	void Int_kbd();
	void Int_2();
	void Int_3();
	void Int_serial();
	void Int_5();
	void Int_6();
	void Int_spurious();
	void Int_8();
	void Int_9();
	void Int_10();
	void Int_11();
	void Int_12();
	void Int_13();
	void Int_ide();
	void Int_15();
	void Int_error();

	//lab 4: IRQs Settings
	SETGATE(idt[IRQ_OFFSET + IRQ_TIMER], 	 0, GD_KT, Int_timer, 	3);
	SETGATE(idt[IRQ_OFFSET + IRQ_KBD], 	 0, GD_KT, Int_kbd, 	3);
	SETGATE(idt[IRQ_OFFSET + 2], 		 0, GD_KT, Int_2, 	3);
	SETGATE(idt[IRQ_OFFSET + 3], 		 0, GD_KT, Int_3, 	3);
	SETGATE(idt[IRQ_OFFSET + IRQ_SERIAL], 	 0, GD_KT, Int_serial, 	3);
	SETGATE(idt[IRQ_OFFSET + 5], 		 0, GD_KT, Int_5, 	3);
	SETGATE(idt[IRQ_OFFSET + 6], 		 0, GD_KT, Int_6, 	3);
	SETGATE(idt[IRQ_OFFSET + IRQ_SPURIOUS],  0, GD_KT, Int_spurious,3);
	SETGATE(idt[IRQ_OFFSET + 8], 		 0, GD_KT, Int_8, 	3);
	SETGATE(idt[IRQ_OFFSET + 9], 		 0, GD_KT, Int_9, 	3);
	SETGATE(idt[IRQ_OFFSET + 10], 		 0, GD_KT, Int_10, 	3);
	SETGATE(idt[IRQ_OFFSET + 11], 		 0, GD_KT, Int_11, 	3);
	SETGATE(idt[IRQ_OFFSET + 12], 		 0, GD_KT, Int_12, 	3);
	SETGATE(idt[IRQ_OFFSET + 13], 		 0, GD_KT, Int_13, 	3);
	SETGATE(idt[IRQ_OFFSET + IRQ_IDE],  	 0, GD_KT, Int_ide,     3);
	SETGATE(idt[IRQ_OFFSET + 15], 		 0, GD_KT, Int_15, 	3);
	SETGATE(idt[IRQ_OFFSET + IRQ_ERROR],     0, GD_KT, Int_error,   3);
```

删除`sched_halt`的`sti`注释并且在`env_alloc`中添加以下代码。

```
	// Enable interrupts while in user mode.
	// LAB 4: Your code here.
	e->env_tf.tf_eflags |= FL_IF;
```



**处理时钟中断：练习14**

在`user/spin`程序中，在子环境第一次运行之后，它只是在循环中旋转，内核再也没有获得控制权。我们需要对硬件进行编程，以周期性地产生时钟中断，这将迫使控制权回到内核，在内核中，我们可以将控制权切换到不同的用户环境。

对`lapic_init`和`pic_init`(来自`init.c`中的`i386_init`)的调用设置了时钟和用于产生中断的中断控制器。现在需要编写代码来处理这些中断。

```
修改内核的trap_dispatch()函数，使其在时钟中断发生时调用sched_yield()来查找并运行一个不同的环境。

现在应该能够让user/spin测试工作了:父环境应该fork子环境，sys_yield()多次，但每次都在一个时间片之后重新获得对CPU的控制，最后终止子环境并优雅地终止。
```

**注释**

```
//处理时钟中断。在调用调度器之前，不要忘记使用lapic_eoi()确认中断!
//实验4:这里是你的代码
```

**代码**

```
	if (tf->tf_trapno == IRQ_OFFSET + IRQ_TIMER) {
		lapic_eoi();
		sched_yield();
		return;
	}
```

偏移量的值错了，寄。改成`IRQ_TIMER`就对头了



#### 进程间通信(IPC): 练习15

**JOS中的IPC**

我们将实现几个额外的JOS内核系统调用，它们共同提供了一个简单的进程间通信机制。用户需要实现两个系统调用，`sys_ipc_recv`和`sys_ipc_try_send`。然后你将实现两个库包装器`ipc_recv`和`ipc_send`。

用户环境可以使用JOS的`IPC`机制相互发送的“消息”由两个部分组成:

1. 单个32位值

2. 可选的单个页映射。

允许环境以消息的形式传递页映射，这提供了一种高效的方式来传输比单个32位整数所能容纳的更多的数据，还允许环境轻松地建立共享内存。



**发送和接收消息**

**为接收消息，环境调用`sys_ipc_recv`。**该系统调用取消当前环境的调度，直到收到消息后才再次运行。当一个环境等待接收消息时，任何其他环境都可以向它发送消息——不仅仅是特定的环境，也不仅仅是与接收环境有父/子关系的环境。

换句话说，你在A部分实现的权限检查不适用于IPC，因为IPC系统调用经过了精心设计，是“安全的”:一个环境不会仅仅通过向它发送消息就导致另一个环境故障(除非目标环境也有bug)。

**为了尝试发送一个值，环境调用`sys_ipc_try_send`，传入接收方的环境id和要发送的值。**如果指定的环境实际上正在接收(它已经调用了`sys_ipc_recv`，但还没有得到值)，则发送端发送消息并返回0。否则，发送返回`-E_IPC_NOT_RECV`，表示目标环境当前不期望接收值。

**用户空间中的库函数`ipc_recv`负责调用`sys_ipc_recv`，然后在当前环境的`struct Env`中查找接收到的值的信息。**

类似地，库函数`ipc_send`将负责重复调用`sys_ipc_try_send`，直到发送成功。



**页面转移**

在环境用有效的`dstva`参数(在UTOP下面)调用`sys_ipc_recv`时，环境表示它愿意接收页映射。如果发送方发送了一页，那么该页应该映射到接收方地址空间的`dstva`。如果接收方已经在`dstva`映射了一页，则取消映射前一页。

当一个环境用一个有效的`srcva`(在UTOP下面)调用`sys_ipc_try_send`时，这意味着发送方想要将当前映射在`srcva`的页发送给接收方，并具有perm权限。在一个成功的IPC之后，发送方在其地址空间中保留其对`srcva`页的原始映射，但接收方也在接收方的地址空间中获得了接收方最初指定的`dstva`中相同物理页的映射。因此，该页面在发送方和接收方之间共享。

如果发送方或接收方没有指示要传输一页，则不传输一页。在任何IPC之后，内核将接收方的Env结构体中的新字段`env_ipc_perm`设置为接收到的页的权限，如果没有接收到页，则设置为0。



**实现IPC**

```
在kern/syscall.c中实现sys_ipc_recv和sys_ipc_try_send。在实现它们之前，请阅读它们的注释，因为它们必须一起工作。在这些例程中调用envid2env时，应该将checkperm标志设置为0，这意味着任何环境都允许向任何其他环境发送IPC消息，而且内核除了验证目标envid是否有效外，不进行特殊的权限检查。

然后实现lib/ipc.c中的ipc_recv和ipc_send函数。

使用user/pingpong和user/primes函数测试你的IPC机制。user/primes将为每个质数生成一个新环境，直到JOS用完所有环境。读者可能会对user/primes.c的内容感兴趣，因为它可以看到所有在幕后发生的分支和IPC。
```

##### `sys_ipc_try_send`

**注释**

```
//尝试将 value 发送到目标环境 envid 。
//如果srcva < UTOP，则同样发送当前映射到 srcva 的页面，以便接收方获得相同页面的重复映射。
//
//如果目标没有被阻塞，正在等待IPC，发送失败，返回值为-E_IPC_NOT_RECV。
//
//发送也可能因为下面列出的其他原因而失败。
//
//否则，发送成功，目标的ipc字段更新如下:
// env_ipc_recving设置为0，用于阻塞未来的发送;
// 将env_ipc_from设置为发送的envid;
// env_ipc_value被设置为参数'value';
// 如果要传输页，env_ipc_perm设置为'perm'，否则设置为0。
//目标环境再次被标记为可运行，从暂停的sys_ipc_recv系统调用返回0。(提示:sys_ipc_recv函数实际会返回吗?)
//
//如果发送方想要发送一个页面，但接收方没有要求，
//这样就不会传输页映射，也不会发生错误。
//只有在没有错误发生时，ipc才会发生。
//
//成功时返回0，错误时返回< 0
//错误是:

//如果环境envid当前不存在，则-e_bad_env。
//(无需检查权限。)
//如果envid当前没有在sys_ipc_recv中被阻塞，或者其他环境首先设法发送。
//如果srcva < UTOP，但srcva没有按页对齐，则- e_inval。
//如果srcva < UTOP和perm不合适，则- e_inval
//(参见sys_page_alloc)。
//如果srcva < UTOP，但srcva没有映射到调用者的地址空间，则- e_inval。
//如果(perm & PTE_W)，但srcva在当前环境的地址空间中是只读的。
//如果envid的地址空间中没有足够的内存映射srcva，则- e_no_mem。
```

**代码**

```
static int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)
{
  struct Env *e;
  int r;
  if((r = envid2env(envid, &e, 0) ) < 0)
    return r;
  if(!e->env_ipc_recving)
    return -E_IPC_NOT_RECV;
  if(srcva < (void*)UTOP){
    if(PGOFF(srcva) || (perm & (PTE_U | PTE_P)) != (PTE_U | PTE_P) || (perm & (~PTE_SYSCALL)))
      return -E_INVAL;
    pte_t *pte;
    struct PageInfo *pg;
    if(!(pg = page_lookup(curenv->env_pgdir, srcva, &pte)))
      return -E_INVAL;
    if((*pte & perm) != perm)
      return -E_INVAL;
    if(e->env_ipc_dstva < (void *)UTOP){
      if((r = page_insert(e->env_pgdir, pg, e->env_ipc_dstva, perm)) < 0)
        return r;
    }
  }
  e->env_ipc_recving        = 0;
  e->env_ipc_from           = curenv->env_id;
  e->env_ipc_value          = value;
  e->env_ipc_perm           = perm;
  e->env_status             = ENV_RUNNABLE;
  e->env_tf.tf_regs.reg_eax = 0;
  return 0;
}
```

##### `sys_ipc_recv`

**注释**

```
//阻塞直到值准备好使用struct Env的env_ipc_recving和env_ipc_dstva字段记录你想要接收的CPU，标记自己不是可运行的，然后放弃CPU。
//
//如果 dstva 是< UTOP，那么你愿意接收一页数据。
// dstva 是被发送页面映射的虚拟地址。
//
//这个函数只在出错时返回，而系统调用在成功时最终返回0。
//出错时返回< 0。错误:
// - e_inval如果dstva < UTOP，但dstva不是页面对齐的。
```

**代码**

```
static int
sys_ipc_recv(void *dstva)
{
	if(!(dstva < (void*)UTOP) || !PGOFF(dstva)){
    	curenv->env_ipc_recving = 1;
    	curenv->env_ipc_dstva   = dstva;
    	curenv->env_status      = ENV_NOT_RUNNABLE;
		sched_yield();
		return 0;
	}
	return -E_INVAL;
}
```

记得添加到到最下面呦。懒，就不写了。

##### `ipc_recv`

**注释**

```
//通过IPC接收一个值并返回它
//
//如果` pg `不为空，那么发送方发送的任何页面都将映射到该地址。
//如果` from_env_store `非null，那么将IPC发送者的envid存储在*from_env_store中。
//如果` perm_store `不为null，那么存储IPC发送者的页面权限
//在perm_store中(在页成功传输到'pg'时，该值为非零)。
//如果系统调用失败，则将0存储在*fromenv和*perm中(如果它们不为null)并返回错误。
//否则，返回发送者发送的值
//
//提示:
//使用` thisenv `来发现值以及发送者。
//如果` pg `为null，传递给sys_ipc_recv一个值，它会理解为“没有页面”。(0不是正确的值，因为这是映射一个页
```

**代码**

```
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
	// LAB 4: Your code here.
	if(!pg)
		pg = (void *)UTOP;
	if(sys_ipc_recv(pg) < 0){
		*from_env_store = 0;
		*perm_store = 0;			
		return sys_ipc_recv(pg);
	}		
	
	if(from_env_store)
		*from_env_store = thisenv->env_ipc_from;
	if(perm_store)
		*perm_store = thisenv->env_ipc_perm;
	return thisenv->env_ipc_value;	
}
```

##### `ipc_send`

**注释**

```
//发送 val (以及 pg 和 perm ，如果 pg 不为null)到 toenv 。
//这个函数会一直尝试直到成功
//除了-E_IPC_NOT_RECV之外，任何错误都应该使用panic()。
//
//提示:
//使用sys_yield()对cpu友好。
//如果` pg `为null，传递给sys_ipc_try_send一个值，它会理解为“没有页面”。(零不是正确的值。)
```

**代码**

```
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
	// LAB 4: Your code here.
	if (pg == NULL) {
		pg = (void *)-1;
	}
	int r;
	while(1) {
		r = sys_ipc_try_send(to_env, val, pg, perm);
		if (r == 0) {		
			return;
		} else if (r == -E_IPC_NOT_RECV) {	
			sys_yield();
		} else {			
			panic("ipc_send():%e", r);
		}
	}
}
```

改了一天多，还是解决不了练习14时钟一开以后就超时寄的问题，无奈根据后续经验这不能不改。先写`Homework`换换脑子。

1个小时终于找见有问题的在`env.c`了,有花了20分钟比对代码，发现是最下面的代码有问题。为什么是最后一个函数啊（恼）

改完了，泪目了,有bug的两个代码直接复制粘贴放弃思考了。回头二次整理再思考吧

<img src="https://cdn.staticaly.com/gh/ri-umk/picx-images-hosting@master/xv6/屏幕截图-2023-08-08-184233.1ji1qi5364kg.jpg" alt="屏幕截图-2023-08-08-184233" />



## lab 5

**环境配置参考`lab4`**

写前保佑我前面的lab没有bug。这种bug真的难改。

### 文件系统基础知识

您将使用的文件系统比大多数“真正的”文件系统(包括xv6 UNIX的文件系统)简单得多，能够提供基本特性:创建、读取、写入和删除组织在分层目录结构中的文件。

我们(至少目前)只开发了一个单用户操作系统，它提供了足够的保护来捕获bug，但无法保护多个相互怀疑的用户相互攻击。

因此，我们的文件系统不支持UNIX中关于文件所有权或权限的概念。我们的文件系统目前也不支持硬链接、符号链接、时间戳或大多数UNIX文件系统支持的特殊设备文件。



#### 磁盘文件系统结构

可用的磁盘空间划分为两种主要类型的区域:`inode`区域和数据区域。

UNIX文件系统为文件系统中的每个文件分配一个`inode`。

- 文件的`inode`保存了有关文件的关键元数据，如stat属性和指向数据块的指针。
- 数据区域划分为更大的数据块(通常为8KB或更多)，文件系统在其中存储文件数据和目录元数据。

目录项包含了文件名和指向`inode`的指针。如果文件系统中的多个目录项引用了该文件的`inode`，则称该文件是硬链接(`hard-linked`)的。由于我们的文件系统不支持硬链接，我们不需要这种间接级别，因此可以进行方便的简化:我们的文件系统根本不使用`inode`，只是**将文件(或子目录)的所有元数据存储在描述该文件的(唯一的)目录项中。**

文件和目录逻辑上都由一系列数据块组成，文件系统环境隐藏了块布局的细节，提供了读取和写入文件中任意偏移位置的字节序列的接口。文件系统环境在内部处理对目录的所有修改，作为执行文件创建和删除等操作的一部分。

我们的文件系统确实允许用户环境直接读取目录元数据(例如，使用read)，这意味着用户环境可以自己执行目录扫描操作(例如，实现ls程序)，而不必依赖对文件系统的额外特殊调用。这种目录扫描方法的缺点是，它使应用程序依赖于目录元数据的格式，在不更改或至少重新编译应用程序的情况下，很难更改文件系统的内部布局，这也是大多数现代UNIX变体不鼓励使用这种方法的原因。

##### 扇区和块

大多数磁盘不能以字节粒度进行读写，而是以扇区为单位进行读写。在JOS中，扇区的长度为512字节。文件系统实际上以块为单位分配和使用磁盘存储。请注意这两个术语之间的区别:**扇区长度是磁盘硬件的属性，而块长度是使用磁盘的操作系统的一个方面。**文件系统的块大小必须是底层磁盘扇区大小的倍数。

UNIX xv6文件系统使用的块大小为512字节，与底层磁盘的扇区大小相同。然而，大多数现代文件系统使用更大的块大小，因为存储空间已经变得更便宜，并且在更大的粒度上管理存储更加有效。我们的文件系统将使用4096字节的块大小，方便地匹配处理器的页面大小。



##### 超级块

![Disk layout](https://pdos.csail.mit.edu/6.828/2017/labs/lab5/disk.png)

文件系统通常会在磁盘上“容易找到”的位置保留某些磁盘块(例如最开始或最末尾)，用于**保存描述文件系统整体属性的元数据**，例如块大小、磁盘大小、查找根目录所需的任何元数据、文件系统最后一次挂载的时间、文件系统最后一次检查错误的时间，等等。这些特殊的块称为超级块(`superblock`)。

我们的文件系统只有一个超级块，它始终位于磁盘的第1块。其布局由`inc/fs.h`中的`struct Super`定义。块0通常用于保存启动加载程序和分区表，因此文件系统通常不会使用第一个磁盘块。**许多“真正的”文件系统维护多个超级块，复制到磁盘上几个分布很广的区域中**，这样，如果其中一个超级块损坏了，或者磁盘在该区域发生了介质错误，仍然可以找到其他超级块并用于访问文件系统。



##### 文件元数据

在我们的文件系统中描述文件的元数据的布局由`inc/fs.h`中的`struct file`描述。**这个元数据包括文件的名称、大小、类型(普通文件或目录)，以及指向组成该文件的块的指针。**如前所述，我们没有`inode`，因此**该元数据存储在磁盘上的一个目录项中**。与大多数“真实的”文件系统不同，为了简单起见，**我们将使用这个文件结构来表示同时出现在磁盘和内存中的文件元数据。**

![File structure](https://pdos.csail.mit.edu/6.828/2017/labs/lab5/file.png)

`struct File`中的`f_direct`数组包含了存储文件前10个(`NDIRECT`)块号的空间，我们称之为文件的直接块(`direct block`)。对于大小不超过10*4096 = 40KB的小文件，这意味着所有文件块的块号将直接放入文件结构本身。然而，对于较大的文件，我们需要一个地方来保存文件其余的块号。因此，对于任何大于40KB的文件，我们分配了一个额外的磁盘块，称为文件的间接块，用于存储最多4096/4 = 1024个额外的块号。因此，**我们的文件系统允许文件大小达到1034块，即4兆字节多一点。为了支持更大的文件，“真正的”文件系统通常还支持双重或三重间接块。**二重再`Homework`里面搞过了。



##### 目录与普通文件

文件系统中的文件结构可以表示普通文件，也可以表示目录;**这两种“文件”由文件结构中的`type`字段区分。**文件系统以完全相同的方式管理普通文件和目录文件，只是它根本不解释与普通文件相关的数据块的内容，而文件系统将目录文件的内容解释为一系列文件结构，描述了该目录下的文件和子目录。

文件系统中的超级块包含一个文件结构(`struct Super`中的root字段)，它保存了文件系统根目录的元数据。**该目录文件的内容是一系列文件结构，描述了位于文件系统根目录中的文件和目录。**根目录下的任何子目录又可能包含更多表示子目录的文件结构，以此类推。



### 文件系统

**用户将负责将数据块读取到块缓存中，并将它们刷写回磁盘;分配磁盘块;将文件偏移量映射到磁盘块;并在IPC接口中实现读、写和打开。**因为您不会自己实现所有文件系统，所以熟悉所提供的代码和各种文件系统接口非常重要。

#### 磁盘访问:练习1

我们操作系统中的文件系统环境需要能够访问磁盘，但我们还没有在内核中实现任何磁盘访问功能。**我们没有采用传统的“单体”操作系统策略，即向内核中添加一个IDE磁盘驱动器以及必要的系统调用以允许文件系统访问它，而是将IDE磁盘驱动器实现为用户级文件系统环境的一部分。**我们仍然需要稍微修改内核，以便使文件系统环境具有实现磁盘访问所需的权限

只要我们依赖轮询、基于“编程I/O”(PIO)的磁盘访问，并且不使用磁盘中断，就可以很容易地在用户空间中实现磁盘访问。在用户态也可以实现中断驱动的设备驱动程序(例如，L3和L4内核会这样做)，但难度更大，因为内核必须对设备中断进行处理，并将其分发到正确的用户态环境。

**x86处理器使用`EFLAGS`寄存器中的`IOPL`位来确定是否允许保护模式代码执行特殊的设备I/O指令，如in和OUT指令。由于我们需要访问的所有IDE磁盘寄存器都位于x86的I/O空间中，而不是内存映射，因此为文件系统环境赋予“I/O权限”是我们唯一需要做的，以便允许文件系统访问这些寄存器。**实际上，`EFLAGS`寄存器中的`IOPL`位向内核提供了一种简单的“全有或全无”方法，用于控制用户态代码是否可以访问I/O空间。在我们的例子中，我们希望文件系统环境能够访问I/O空间，但是我们根本不希望任何其他环境能够访问I/O空间。

```
练习1
i386_init通过将类型ENV_TYPE_FS传递给创建环境的函数env_create来标识文件系统环境。在env.c中修改env_create，使其赋予文件系统环境的I/O权限，但绝不将该权限赋予任何其他环境。

问题:
当您随后从一个环境切换到另一个环境时，您是否必须执行其他操作以确保正确地保存和恢复此I/O权限设置?为什么?
```

**代码**

##### `env_create`

```
	if (type == ENV_TYPE_FS){
		e->env_tf.tf_eflags |= FL_IOPL_MASK;
	}
```

相关的在`mmu.h`和`trap.h`中

**回答**

```
不需要，因为在环境切换时，会保存eflags的值，也会用 env_pop_tf恢复eflags的值。
```



#### 块缓存:练习2

我们将借助处理器的虚拟内存系统实现一个简单的“缓冲区缓存”(实际上只是块缓存)。块缓存的代码在`fs/bc.c`中。

我们的文件系统只能处理3GB或更小的磁盘。我们保留了文件系统环境地址空间的一个大的、固定的3GB区域，从0x10000000 (`DISKMAP`)到0xD0000000 (`DISKMAP+DISKMAX`)，作为磁盘的“内存映射”版本。`fs/bc.c`中的`diskaddr`函数实现了从磁盘块号到虚拟地址的转换(以及一些完整性检查)。

我们的文件系统环境有自己的虚拟地址空间，独立于系统中所有其他环境的虚拟地址空间，并且文件系统环境只需要做一件事就是实现文件访问，因此以这种方式保留文件系统环境的大部分地址空间是合理的。

将整个磁盘读入内存需要很长时间，因此我们将实现一种按需分页的形式，在这种形式中，我们只在磁盘映射区域中分配页，并在该区域出现缺页异常时从磁盘中读取相应的块。这样，我们就可以假装整个磁盘都在内存中。

```
练习2
实现fs/bc.c中的bc_pgfault和flush_block函数。

bc_pgfault是一个缺页异常处理程序，就像您在上一个关于写时复制分支的实验中编写的那样，只是它的工作是从磁盘加载页以响应缺页异常。在写这段代码时，请记住:(1)addr不能对齐到块边界;(2)ide_read以扇区而不是块为单位操作。

flush_block函数在必要时将一个块写入磁盘。如果块不在块缓存中(即页没有映射)，或者该页不是脏的，flush_block不应该做任何操作。我们将使用VM硬件来跟踪磁盘块自最后一次读取或写入磁盘以来是否被修改过。要确定一个块是否需要写入，只需查看uvpt项中的PTE_D“dirty”位是否设置。(PTE_D比特位由处理器设置，以响应对该页的写操作。参见386参考手册第5章5.2.4.3。)在将块写入磁盘之后，flush_block应该使用sys_page_map清除PTE_D位。
```

`fs/fs.c`中的`fs_init`函数是如何使用块缓存的一个主要例子。在初始化块缓存之后，它只是将指针存储到磁盘映射区域的超全局变量中。在这一点上，我们可以简单地从超级结构中读取，就像它们在内存中一样，我们的缺页异常处理程序将根据需要从磁盘读取它们。

**准备**

```
ide.c

ide_read(uint32_t secno, void *dst, size_t nsecs)
secno表示扇区号（sector number），dst表示目标内存缓冲区，nsecs表示要读取的扇区数。
这个函数用于从IDE设备读取数据。

ide_write(uint32_t secno, const void *src, size_t nsecs)
这个函数用于向IDE设备写入数据。

utf：这是一个指向 struct UTrapframe 类型的指针，其中包含有关陷阱帧的信息。
addr：这是一个指向 void 类型的指针，表示导致页面错误的虚拟地址。
blockno：这是一个 uint32_t 类型的变量，表示导致页面错误的虚拟地址对应的磁盘块号。
```

**代码**

##### `bc_pgfault`

```c
	addr = (void *)ROUNDDOWN(addr, PGSIZE);
	if ((r = sys_page_alloc(0, addr, PTE_P | PTE_W | PTE_U)) < 0){
		panic("In bc_pgfault, sys_page_alloc fault: %e", r);
	}
	if ((r = ide_read(blockno*BLKSECTS, addr, BLKSECTS)) < 0){
		panic("In bc_pgfault, ide_read fault: %e", r);
	}
```

**提示**

```
//如果需要，将包含VA的块的内容刷写到磁盘，然后使用sys_page_map清除PTE_D比特位。
//如果块不在块缓存中或不是脏的，则什么都不做
//提示:使用va_is_mapped、va_is_dirty和ide_write。
//提示:在调用sys_page_map时，使用PTE_SYSCALL常量。
//提示:不要忘记将addr向下舍入。
```

`va_is_mapped`,`va_is_dirty`在`fs.h`中

**代码**

##### `flush_block`

```c
	int r;
	addr = (void *)ROUNDDOWN(addr, PGSIZE);
	if(va_is_mapped(addr) && va_is_dirty(addr)){
		if ((r = ide_write(blockno * BLKSECTS,addr,BLKSECTS)) < 0 ) 
			panic("in flush block ,ide_write fault: %e",r);
		if((r = sys_page_map(0, addr, 0, addr, uvpt[PGNUM(addr)] &
			PTE_SYSCALL)) < 0)
			panic("In flush_block, sys_page_map fault: %e", r);	
	} else {
		return;
	}
```

这里有的是`BLKSECTS`啊,发现理解错了，还是好好读读`fs.h`再写比较好。



#### 块位图:练习3

在`fs_init`设置位图指针之后，我们可以将`bitmap`视为一个位数组，每个位代表磁盘上的一个块。

```c
练习3
    
在fs/fs.c中实现alloc_block时，使用free_block作为模型，该函数应在位图中找到一个空闲磁盘块，标记它已使用，并返回该块的编号。在分配块时，应该立即用flush_block将修改后的位图块刷新到磁盘，以保持文件系统的一致性。

使用make grade来测试你的代码。你的代码现在应该传递"alloc_block"。
```

**注释**

```c
//位图由一个或多个块组成一个位图块
//包含BLKBITSIZE块使用的比特位磁盘中总共有super->s_nblocks块。

//得理解了那段代码才能写
//bitmap[i / 32] |= 1 << (i % 32);
//如果 blockno 不为0，则将位图（bitmap）中对应数据块的位设置为1，表示该数据块现在是空闲状态。
//反过来改成已使用。

```

**代码**

##### `alloc_block`

```c
int
alloc_block(void)
{
	// The bitmap consists of one or more blocks.  A single bitmap block
	// contains the in-use bits for BLKBITSIZE blocks.  There are
	// super->s_nblocks blocks in the disk altogether.

	// LAB 5: Your code here.
	size_t i;
	for(i = 1; i < super->s_nblocks; i++){
		if(block_is_free(i)){
			bitmap[i / 32] &= ~(1 << (i % 32));
			flush_block(&bitmap[i / 32]);
			return i;
		}
	} 
	return -E_NO_DISK;
}
```



#### 文件操作:练习4

请通读`fs/fs.c`中的所有代码，确保你理解了每个函数的作用。

```
练习4

实现file_block_walk和file_get_block。
file_block_walk将文件内的块偏移量映射到struct file中该块或间接块的指针，非常类似于pgdir_walk对页表所做的工作。
file_get_block更进一步，映射到实际的磁盘块，在必要时分配一个新的磁盘块。

使用make grade来测试你的代码。你的代码应该传递"file_open"、"file_get_block"、"file_flush/file_truncated/file rewrite"和"testfile"。
```

`file_block_walk`和`file_get_block`是文件系统的主力神。例如，`file_read`和`file_write`只是`file_get_block`上的簿记工作，在分散的块和顺序缓冲区之间复制字节是必需的。

函数的目标是为了在文件系统中管理数据块的访问和分配。

##### `file_block_walk`

**注释**

```c
//在文件` f `中找到` filebno `的第th块所在的磁盘块号槽位。
//设置'*ppdiskbno'指向该槽位。
//该槽位可以是f->f_direct[]项中的一个，或者是间接块中的一个项。
//当设置了` alloc `时，该函数将在必要时分配一个间接块。
//
//返回:
// 0表示成功(但请注意*。
// - e_not_found，如果函数需要分配一个间接块，但alloc为0。
// - e_no_disk如果磁盘上没有空间存放间接块。
// - e_inval如果filebno超出范围(它是>= NDIRECT + NINDIRECT)。
//
//类比:这类似于文件的pgdir_walk。 
//提示:不要忘记清除你分配的任何块。

//struct File *f: 指向文件结构的指针，表示要导航的文件。
//uint32_t filebno: 文件中的块编号，表示要获取的文件中的数据块在文件中的偏移。
//uint32_t **ppdiskbno: 指向指针的指针，用于返回物理磁盘块号的地址。
//bool alloc: 一个布尔值，表示如果需要的话是否分配数据块。
```

**代码**

一定得好好看前面的知识，不然没有空间相关知识写不了一点。。。

![File structure](https://pdos.csail.mit.edu/6.828/2017/labs/lab5/file.png)

```c
static int
file_block_walk(struct File *f, uint32_t filebno, uint32_t **ppdiskbno, bool alloc)
{
	// LAB 5: Your code here.
	uint32_t blockno;
	
    //Check if it is in a direct block 
	if (filebno < NDIRECT){
		if(ppdiskbno){
			*ppdiskbno = &(f->f_direct[filebno]);
			return 0;
		}
	}
    
	//Check if it's out of bounds
	if (filebno >= NDIRECT + NINDIRECT)
		return -E_INVAL;

	filebno -= NDIRECT;
    
	//Allocate an indirection block.	
	if(f->f_indirect == 0){
		if (alloc == 0)
			return -E_NOT_FOUND;
		if ((blockno = alloc_block()) < 0)
			return -E_NO_DISK;
		f->f_indirect = blockno;		
		memset(diskaddr(blockno), 0, BLKSIZE);
		flush_block(diskaddr(blockno));
	}
	
	*ppdiskbno = (uint32_t *)diskaddr(f->f_indirect) + filebno;
	return 0;
}
```

这个函数的目标是在文件系统中实现块导航，将文件内的块索引映射到磁盘上的实际物理块号，并在需要时进行分配和初始化。

##### `file_get_block`

**注释**

```
//设置*blk为文件'f'的第一个块将映射到的内存地址。
//
//成功时返回0，错误时返回< 0错误:
// - e_no_disk.如果需要分配一个块，但磁盘已满。
// - e_inval.如果filebno超出范围。
//
//提示:使用file_block_walk和alloc_block。
```

**代码**

```
int
file_get_block(struct File *f, uint32_t filebno, char **blk)
{
	// LAB 5: Your code here.
	int r;
	uint32_t *pdiskbno;
	// 调用 file_block_walk 函数来获得文件块的磁盘块号指针	
	if((r = file_block_walk(f, filebno, &pdiskbno, 1)) < 0)
		return r;
	if (filebno >= NDIRECT + NINDIRECT)
		return -E_INVAL;
    // 如果磁盘块号指针指向的内容为 0，说明该块还未分配
	if (*pdiskbno == 0){
		if ((r = alloc_block()) < 0)
			return -E_NO_DISK;
		*pdiskbno = r;
		memset(diskaddr(r), 0, BLKSIZE);
	}
	// 最终将指向该块的指针存入 blk 指向的位置
	*blk = diskaddr(*pdiskbno);
	flush_block(*blk);
	return 0;
}
```

在文件系统中用于获取指定文件的特定块并返回指向该块的指针。

改代码的一个参考

```
https://www.jianshu.com/p/a20a9a0f9a2e?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes
```



#### 文件系统接口:练习5,6

我们已经给出了spawn的代码(参见`lib/spawn.c`)，它会创建一个新环境，从文件系统加载程序映像，然后启动运行这个程序的子环境。然后，父进程继续独立于子进程运行。spawn函数实际上就像UNIX中的一个fork，后面是子进程的一个立即执行程序。

**练习5**

```
练习5
在fs/serv.c中实现serve_read。
serve_read的繁重工作将由fs/fs.c中已经实现的file_read完成(而file_read只是对file_get_block的一些调用)。serve_read只需要提供用于文件读取的RPC接口。查看serve_set_size中的注释和代码，以获得服务器函数应该如何构造的基本概念。
```

**注释&准备工作**

```c
注释:
//最多读取ipc->从ipc中的当前寻道位置计算Req_n个字->read.req_fileid。
//通过ipc->readRet将从文件读取的字节返回给调用者，然后更新寻道位置。
//返回成功读取的字节数，或在错误时返回< 0。
准备工作:
//回看之前的fs.h,里面有你需要的联合体
//其他的结构体相关数据就在serv.c中
//用到了fs.c中的函数，你再看一下
```

##### `serv_read`

```c
int
serve_read(envid_t envid, union Fsipc *ipc)
{
	struct Fsreq_read *req = &ipc->read;
	struct Fsret_read *ret = &ipc->readRet;
	int r;
	struct OpenFile *o;
	
	if (debug)
		cprintf("serve_read %08x %08x %08x\n", envid, req->req_fileid, req->req_n);

	// Lab 5: Your code here:
	if ((r = openfile_lookup(envid, req->req_fileid, &o)) < 0)
		return r;
	if ((r = file_read(o->o_file, ret->ret_buf, req->req_n, o->o_fd->fd_offset)) < 0)
		return r;
	
	o->o_fd->fd_offset += r;
	return r;
}
```

**练习6**

```
练习6。在fs/serv.c中实现serve_write，在lib/file.c中实现devfile_write。
```

**注释**

```c
//从req->req_buf开始写req-> req_fileid，从当前寻道位置开始，并相应地更新寻道位置。
//如有必要，扩展文件。返回写入的字节数，或在错误时< 0。
```

##### `serv_write`

```c
int
serve_write(envid_t envid, struct Fsreq_write *req)
{
	if (debug)
		cprintf("serve_write %08x %08x %08x\n", envid, req->req_fileid, req->req_n);

	// LAB 5: Your code here.
	int r;
	struct OpenFile *o;
	if ((r = openfile_lookup(envid, req->req_fileid, &o)) < 0)
		return r;

	//确保不会写入超过一页大小的数据，避免越界访问。
	int reqn = req->req_n > PGSIZE? PGSIZE:req->req_n;
	if ((r = file_write(o->o_file, req->req_buf, reqn, o->o_fd->fd_offset)) < 0)
		return r;
	
	o->o_fd->fd_offset += r;
	return r;
}
```

**注释**

```c
//在当前寻道位置，从 buf 到 fd 最多写入n字节。
//
//返回:
//成功写入的字节数。
// < 0表示错误。

//向文件系统服务器发出FSREQ_WRITE请求注意:fsipcbuf.write。
//Req_buf只有这么大，但请记住，写操作总是允许写入比请求的字节*少*的字节。

//看了一圈发现用的联合体，不是结构体。。。
```

##### `devfile_write`

```c
static ssize_t
devfile_write(struct Fd *fd, const void *buf, size_t n)
{
	// Make an FSREQ_WRITE request to the file system server.  Be
	// careful: fsipcbuf.write.req_buf is only so large, but
	// remember that write is always allowed to write *fewer*
	// bytes than requested.
	// LAB 5: Your code here
	// 不超过缓冲区的限制。
    int r;
	if (n > sizeof(fsipcbuf.write.req_buf))
		n = sizeof(fsipcbuf.write.req_buf);  
	
	// 设置相关参数。
	fsipcbuf.write.req_fileid = fd->fd_file.id;
	fsipcbuf.write.req_n = n;
	memmove(fsipcbuf.write.req_buf, buf, n);

    // 发送一个 FSREQ_WRITE 请求给文件系统服务器。
	return fsipc(FSREQ_WRITE, NULL);
}
```

**代码是对的，但是错误怎么也找不出来，在家也不好做lab，环境真的差。。。就这样放弃还是感觉可惜。**

```
https://github.com/YeXiaoRain/JOS_LAB_MIT_2017/commit/90ea0b09d213fa8ae6be95b4108277151e03b90f?short_path=4021a5b#diff-4021a5b61898c7796f384d4f8096cb00d37cbe8c2db779eb1843f43836e07f5f
```

在debug中帮助了不少

### 创建进程

我们已经给出了`spawn`的代码(参见`lib/spawn.c`)，它会创建一个新环境，从文件系统加载程序映像，然后启动运行这个程序的子环境。然后，父进程继续独立于子进程运行。spawn函数实际上就像UNIX中的一个fork，后面是子进程的一个立即执行程序。

我们实现了spawn而不是`unix`风格的`exec`，因为spawn更容易在用户空间以“外核方式”实现，而不需要内核的特别帮助。考虑一下在用户空间中实现exec需要做些什么，并确保你理解为什么它更难。

#### 练习7

```
练习7
Spawn依赖于新的系统调用sys_env_set_trapframe来初始化新创建的环境的状态。在kern/syscall.c中实现sys_env_set_trapframe(不要忘记在syscall()中分派新的系统调用)。
```

```
https://phimos.github.io/2020/05/20/6828-lab5/
```

**注释**

```c
//设置envid的陷阱帧为'tf'。
//修改tf，以确保用户环境始终运行在代码保护级别3 (CPL 3)、启用中断和IOPL为0。
//
//成功时返回0，错误时返回< 0错误:
// - e_bad_env如果环境envid当前不存在，
//或者调用者没有修改envid的权限
```

**代码**

##### `sys_env_set_trapframe`

```c
static int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
	// LAB 5: Your code here.
	// Remember to check whether the user has supplied us with a good
	// address!
	// panic("sys_env_set_trapframe not implemented");
	struct Env *e;
	int r;
	if ((r = envid2env(envid, &e, 1)) < 0)
		return r;
	e->env_tf = *tf;
	e->env_tf.tf_cs |= 3;
	e->env_tf.tf_eflags |= FL_IF;
	return 0;	
}
```



#### 在fork和spawn之间共享库状态:练习8

UNIX文件描述符是一个通用概念，它还包括管道、控制台I/O等。在`JOS`中，这些设备类型中的每一种都有一个相应的结构体Dev，带有实现读/写/等功能的指针。对于那个设备类型。`lib/fd.c`在此基础上实现了通用的类`unix`文件描述符接口。每个结构Fd表示它的设备类型，以及`lib/Fd`中的大多数函数。c简单地将操作分派给相应结构体Dev中的函数。

`lib/fd.c`还在每个应用程序环境的地址空间中维护文件描述符表区域，从`FDTABLE`开始。该区域为应用程序可以同时打开的每个至多`MAXFD`(目前为32个)文件描述符保留一个页面价值(4KB)的地址空间。在任何给定时间，当且仅当对应的文件描述符正在使用时，将映射特定的文件描述符表页。每个文件描述符在从`FILEDATA`开始的区域中也有一个可选的“数据页”，设备可以选择使用它。

我们希望在`fork`和`spawn`之间共享文件描述符状态，但是文件描述符状态保存在用户空间内存中。现在，在`fork`上，内存将被标记为写时复制，因此状态将被复制而不是共享。(这意味着环境将无法在它们自己没有打开的文件中查找，并且管道将无法跨分支工作。)在刷出时，内存将被留下，根本不复制。(实际上，生成的环境开始时没有打开文件描述符。)

我们将更改`fork`，以知道某些内存区域是由“库操作系统”使用的，并且应该始终共享。我们将在页表项中设置一个不使用的位，而不是在某个地方硬编码一个区域列表(就像我们在`fork`中使用`PRE_cow`位一样)。

我们在`inc/lib.h`中定义了一个新的`PTE_SHARE`位。这个位是Intel和AMD手册中标记为“可供软件使用”的三个`PTE`位之一。我们将建立这样的约定:如果一个页表条目设置了这个位，那么`PTE`应该在`fork`和`spawn`中直接从父节点复制到子节点。请注意，这与标记为“写后复制”不同:正如第一段所述，我们希望确保共享对页面的更新。

**练习8**

```
修改lib/fork.c中的duppage以遵循新的约定。如果页表项设置了PTE_SHARE位，则直接复制映射。(大家应该使用PTE_SYSCALL，而不是0xfff，来屏蔽页表项的相关比特位。0xfff也会获取访问过的比特位和脏比特位。)

同样，在lib/spawn.c中实现copy_shared_pages。它应该遍历当前进程中的所有页表项(就像fork那样)，将所有设置了PTE_SHARE位的页映射复制到子进程中。
```

**代码**

##### `duppage`

```c
static int
duppage(envid_t envid, unsigned pn)
{
	int r;
	uint32_t va = pn * PGSIZE;
	envid_t cur_envid = sys_getenvid();
	// LAB 4: Your code here.
	if(uvpt[pn] & PTE_SHARE){
		if((r = sys_page_map(cur_envid, (void *)va, envid, (void *)va, uvpt[pn] & PTE_SYSCALL)) < 0)
			return r;
	} else if((uvpt[pn] & PTE_W) || (uvpt[pn] & PTE_COW)){
		if((r = sys_page_map(cur_envid, (void *)va, envid, (void *)va, PTE_P | PTE_U 
			| PTE_COW)) < 0)
			panic("sys_page_map: %e\n", r);
		if((r = sys_page_map(cur_envid, (void *)va, cur_envid, (void *)va, PTE_P | 
			PTE_U | PTE_COW)) < 0)
			panic("sys_page_map: %e\n", r);
	} else {
		if((r = sys_page_map(cur_envid, (void *)va, envid, (void *)va, PTE_P | 
			PTE_U)) < 0)
			panic("sys_page_map: %e\n", r);
	}
    return 0;
}
```

没`spawn.c`半点注释，，，

copy_shared_pages

```

```











## lab 6

































## lab 7































# 5. other



## 5.1 Homework: shell

**实验目标**：实现ls，I/O重定向，Pipes管道

垃圾的英文能力，去理解要我干嘛就要搞半天。

基础知识`execv`, `strchr`, `access`.

**string.h**

具体查看该网站[C 标准库 –  | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-standard-library-string-h.html)

**execv**

execv会停止执行当前的进程，并且以progname替换被停止执行的进程，进程ID不会改变。`argv` 是一个字符串数组，用于传递给新程序的命令行参数。

```c
// 函数原型           文件的路径            参数
int execv(const char *progname, char *const argv[]);   
//#include <unistd.h>
```

返回值：函数返回值是一个整数，表示执行结果。如果成功执行新程序，则不会返回到原来的程序；如果出现错误，则返回-1，并设置相应的错误代码。

**access**

access用于检查文件访问权限的系统调用函数。

```c
// pathname :要检查权限的文件路径名。
// mode : 是一个整数，用于指定要检查的权限。
int access(const char * pathname, int mode)

R_OK      测试读许可权
W_OK      测试写许可权
X_OK      测试执行许可权
F_OK      测试文件是否存在
```

返回值是一个整数，表示检查结果。如果检查成功，则返回0；如果出现错误，则返回-1，并设置相应的错误代码。

通过main函数帮助你进一步了解要做什么

这段代码实现了一个简单的命令行解释器，能够执行基本的命令，并支持切换目录功能。

**main**

```c
int
main(void)
{
  // buf存储输入的命令
  static char buf[100];
  int fd, r;

  // 读取并运行输入命令
  // 通过 getcmd 函数读取输入的命令，并将命令存储在 buf 中。
  while(getcmd(buf, sizeof(buf)) >= 0){
  // 通过判断命令的第一个字符是否为 'c'，第二个字符是否为 'd'，第三个字符是否为空格来判断是否是 "cd" 命令。
    if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
      // 如果只是 cd 命令，则切换文件夹后继续等待命令
      // 一般写完命令敲回车，这里就是把回车改为'\0'
      buf[strlen(buf)-1] = 0;  // chop \n
      if(chdir(buf+3) < 0)
        fprintf(stderr, "cannot cd %s\n", buf+3);
      continue;
    }
    // 如果不是 "cd" 命令，则通过 fork1 函数创建一个子进程，并在子进程中调用 runcmd 函数来执行解析后的命令。
    if(fork1() == 0)
      runcmd(parsecmd(buf));
    // 等待子进程完成
    wait(&r);
  }
  exit(0);
}
```

你所需要实现的代码就是不是cd命令时，解析的命令。runcmd函数

**解析代码**

```c
struct cmd*
parsecmd(char *s)
{
  char *es;
  struct cmd *cmd;
    
  //通过计算 s 的长度，得到字符串的结束位置 es。  
  es = s + strlen(s);
  //解析命令行
  cmd = parseline(&s, es);
  //检查是否还有剩余的字符未被解析。
  peek(&s, es, "");
  //通过判断 s 和 es 是否相等，如果不相等，则表示解析过程中存在未解析的字符
  if(s != es){
    fprintf(stderr, "leftovers: %s\n", s);
    exit(-1);
  }
  return cmd;
}
```

要写的代码：命令分成了3个类型，分别是可执行命令，重定向命令，以及管道命令。

**可执行命令**

```
  case ' ':
    ecmd = (struct execcmd*)cmd;
    if(ecmd->argv[0] == 0)
      exit(0);
    fprintf(stderr, "exec not implemented\n");
    // Your code here ...
    break;
```

经过分析：需要做到的功能是实现exec，即执行当前命令，分为两种状况，一种是执行当前目录文件，如果没有则执行bin目录的文件

**要求的效果**

```shell
yy@yy-virtual-machine:~/OS/myShell$ ./myShell 
6.828$ ls
myShell  sh.c  t.sh
6.828$ ls ../
lab  multi-thread  myLogs  MyMemo.txt  myShell  qemu  qemu_mit_2.3  xv6-public
6.828$ abc
abc: Command not found
6.828$ 
```

**实现**

```
  case ' ':
    ecmd = (struct execcmd*)cmd;
    if(ecmd->argv[0] == 0)
      _exit(0);
    //fprintf(stderr, "exec not implemented\n");
    // Your code here ...
    if(access(ecmd->argv[0], F_OK)==0){
      execv(ecmd->argv[0], ecmd->argv);
    }else{
      char *bin = "/bin/";
      int len = strlen(bin) + strlen(ecmd->argv[0]);
      char *new_exec = (char *)malloc((len+1)*sizeof(char));
      strcpy(new_exec, bin);
      strcat(new_exec, ecmd->argv[0]);
      if(access(new_exec, F_OK)==0){
    	execv(new_exec, ecmd->argv);
      }else{
      	fprintf(stderr, "%s: Command not found\n", ecmd->argv[0]);
      }
    }
    break;
```

问题和吐槽：少了个括号调试半天，，，用free释放内存却报错，不知道为什么。

**重定向命令**

```
struct redircmd {
  int type;          // < or > 
  struct cmd *cmd;   // the command to be run (e.g., an execcmd)
  char *file;        // the input/output file
  int flags;         // flags for open() indicating read or write
  int fd;            // the file descriptor number to use for the file
};
```

**原理**

这样可以实现重定向是因为在操作系统中，每个进程都有一组打开的文件描述符。文件描述符是一个非负整数，用于标识打开的文件或其他输入/输出资源。

在C语言中，标准输入、标准输出和标准错误输出分别对应的文件描述符是 0、1 和 2。通过改变文件描述符的指向，可以实现重定向。

在示例代码中，我们使用 `dup2` 函数将目标文件的文件描述符 `fd` 复制到标准输出文件描述符 `STDOUT_FILENO` 上。这样，所有输出到标准输出的内容都会被重定向到目标文件。

`dup2` 函数的原型如下：

```
int dup2(int oldfd, int newfd);
```

它会将 `newfd` 的指向复制为 `oldfd` 的指向。在示例中，我们将目标文件的文件描述符 `fd` 复制到标准输出文件描述符 `STDOUT_FILENO` 上，即将标准输出重定向到目标文件。

这样，在执行 `printf` 函数输出时，输出的内容将会被写入到目标文件中，而不是显示在终端上。

最后，通过关闭文件描述符 `fd`，我们释放了文件资源，确保不再使用该文件描述符。

需要注意的是，重定向只影响当前进程的输出，不会影响其他进程的输出。

**代码**

```
  case '>':
  case '<':
    rcmd = (struct redircmd*)cmd;
    //fprintf(stderr, "redir not implemented\n");
    // Your code here ...
    close(rcmd->fd);
    if(open(rcmd->file, rcmd->flags, S_IWUSR | S_IRUSR) < 0){
    	fprintf(stderr, "file:%s is error\n", rcmd->file);
    	_exit(0)
    }

    runcmd(rcmd->cmd);
    break;
```

问题和吐槽：只要实现重定向这个操作就行啊，最早以为得创建文件，读取命令结果，存入文件这类的了。

**管道命令**

您必须编写的唯一代码是 `runcmd` 中的“|”情况。你可能会查找 pipe、fork、Close 和 DUP 的手册页很有用。

重定向实现的是改变输出或输入数据的来源，管道实现的是进程之间的通信。管道通信可以看这篇文章。

[(108条消息) 进程间的通信方式——pipe（管道）_pipe进程通信_sky_Mata的博客-CSDN博客](https://blog.csdn.net/skyroben/article/details/71513385)

- int pipe(int p[])

  建立一个缓冲区，并把缓冲区通过 fd 形式给程序调用。它将 p[0] 修改为缓冲区的读取端， p[1] 修改为缓冲区的写入端。

- int dup(int old_fd)

  产生并返回与old_fd指向同一文件的fd。产生的 fd 总是空闲的最小 fd。

**相关代码**

```c
struct pipecmd {
  int type;          // |
  struct cmd *left;  // left side of pipe
  struct cmd *right; // right side of pipe
};
```

**结果**

方法：

- 标准输出被重定向到写入管道末端
- 标准输入被重定向到管道的读端

本质是考你进程通信，管道里父子进程的理解。

<img src="https://cdn.staticaly.com/gh/ri-umk/picx-images-hosting@master/xv6/2019071316410695.1wa2lcz2di74.webp" alt="2019071316410695" />

```
  case '|':
    pcmd = (struct pipecmd*)cmd;
    // fprintf(stderr, "pipe not implemented\n");
    // Your code here ...
    pipe(p);
    if(fork1() == 0){
    	close(1);
    	dup(p[1]);
    	close(p[0]);
    	close(p[1]);
    	runcmd(pcmd->left);
    }
    wait(&r);
    
    if(fork1() == 0){
    	close(0);
    	dup(p[0]);
    	close(p[0]);
    	close(p[1]);
    	runcmd(pcmd->right);
    }
    close(p[0]);
    close(p[1]);
    wait(&r);   
    break;
  }    
  _exit(0);
}

```

问题和吐槽：每次关闭管道的读写端是为了确保在每个子进程中只有一个进程使用管道。

在管道命令中，数据从一个进程通过管道的写端流入，然后从另一个进程通过管道的读端流出。为了避免出现死锁或数据混乱的情况，需要在每个进程中关闭不需要的管道端口。

在第一个子进程中，关闭管道的读端是为了确保只有一个进程写入管道。因为第一个子进程的标准输出已经被重定向到管道的写端，所以关闭读端可以防止该进程从管道中读取数据。

在第一个子进程中，关闭管道的写端是为了确保只有第二个子进程可以从管道中读取数据。如果第一个子进程不关闭写端，那么第二个子进程将无法判断何时读取完所有数据，从而导致死锁。

同理

在第二个子进程中，关闭管道的写端是为了确保只有第一个子进程可以写入管道。如果第二个子进程不关闭写端，那么第一个子进程将无法判断何时停止写入数据，从而导致死锁。

在第二个子进程中，关闭管道的读端是为了确保只有该进程可以从管道中读取数据。因为第二个子进程的标准输入已经被重定向到管道的读端，所以关闭写端可以防止其他进程向管道中写入数据。

<img src="https://cdn.staticaly.com/gh/ri-umk/picx-images-hosting@master/xv6/屏幕截图-2023-07-17-213355.2a4lfhvn5tc0.webp" alt="屏幕截图-2023-07-17-213355" />



## 5.2 Homework：xv6 system calls

### Part One: System call tracing

**任务**：打印系统调用的名称和返回值

```
你的第一个任务是修改xv6内核，使其对每个系统调用都打印一行。打印系统调用的名称和返回值就足够了。你不需要打印系统调用参数。
提示:修改syscall.c中的syscall()函数。
可选挑战:打印系统调用参数。
```

**效果：**追踪系统调用

```
...
fork -> 2
exec -> 0
open -> 3
close -> 0
$write -> 1
 write -> 1
```

**代码**

```
int ret = syscalls[num]();
```

```
是一个函数指针数组，存储了系统调用函数的地址。num是系统调用的编号，在范围内且对应的系统调用函数存在时，可以通过syscalls[num]来获取对应的系统调用函数的地址。
syscalls[num]()这行代码实际上是通过函数指针调用了对应的系统调用函数。将其返回值赋值给ret变量。
```

```
题中是用了这个
curproc->tf->eax = syscalls[num]();
```

```c
//代码如下
// System call numbers
static char *syscalls_num[22] = {

        [SYS_fork] "fork",
        [SYS_exit] "exit",
        [SYS_wait] "wait",
        [SYS_pipe] "pipe",
        [SYS_read] "read",
        [SYS_kill] "kill",
        [SYS_exec] "exec",
        [SYS_fstat] "fstat",
        [SYS_chdir] "chdir",
        [SYS_dup] "dup",
        [SYS_getpid] "getpid",
        [SYS_sbrk] "sbrk",
        [SYS_sleep] "sleep",
        [SYS_uptime] "uptime",
        [SYS_open] "open",
        [SYS_write] "write",
        [SYS_mknod] "mknod",
        [SYS_unlink] "unlink",
        [SYS_link] "link",
        [SYS_mkdir] "mkdir",
        [SYS_close] "close"
};

void
syscall(void)
{
  int num;
  struct proc *curproc = myproc();

  num = curproc->tf->eax;
  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
    curproc->tf->eax = syscalls[num]();
    cprintf("%s -> %d\n", 
    	    syscalls_num[num], curproc->tf->eax);
  } else {
    cprintf("%d %s: unknown sys call %d\n",
            curproc->pid, curproc->name, num);
    curproc->tf->eax = -1;
  }
}
```



### Part Two: Date system call

**任务**：添加一个日期系统调用

第二个任务是向xv6添加一个新的系统调用。这个练习的重点是让你了解系统调用机制的不同部分。新的系统调用将获得当前UTC时间，并将其返回给用户程序。你可能需要使用辅助函数`cmostime()`(在`lapic.c`中定义)来读取实时时钟。`Date.h`包含`struct rtcdate`结构体的定义，你可以将其作为指针提供给`cmostime()`的参数。

你应该创建一个用户级的程序来调用新的日期系统调用;下面是你应该放在`date.c`中的一些源代码:

```c
#include "types.h"
#include "user.h"
#include "date.h"

int
main(int argc, char *argv[])
{
  struct rtcdate r;

  if (date(&r)) {
    printf(2, "date failed\n");
    exit();
  }

  // your code to print the time in any format you like...

  exit();
}
```

为了让新的日期程序可以在xv6 shell中运行，请在Makefile中的UPROGS定义中添加_date。

你进行日期系统调用的策略应该是克隆所有特定于某些现有系统调用的代码片段，例如“正常运行时间”系统调用。你应该在所有源文件中使用grep -n uptime *.[chS]来获取运行时间。

完成后，在xv6 shell提示符中输入date，应该会打印出当前的UTC时间。

为创建date系统调用过程中必须修改的每个文件写几句解释。

可选挑战:添加dup2()系统调用并修改shell以使用它。

**user.h**

```
struct stat;
struct rtcdate;

// system calls
int fork(void);
int exit(void) __attribute__((noreturn));
int wait(void);
int pipe(int*);
int write(int, const void*, int);
int read(int, void*, int);
int close(int);
int kill(int);
int exec(char*, char**);
int open(const char*, int);
int mknod(const char*, short, short);
int unlink(const char*);
int fstat(int fd, struct stat*);
int link(const char*, const char*);
int mkdir(const char*);
int chdir(const char*);
int dup(int);
int getpid(void);
char* sbrk(int);
int sleep(int);
int uptime(void);

// ulib.c
int stat(const char*, struct stat*);
char* strcpy(char*, const char*);
void *memmove(void*, const void*, int);
char* strchr(const char*, char c);
int strcmp(const char*, const char*);
void printf(int, const char*, ...);
char* gets(char*, int max);
uint strlen(const char*);
void* memset(void*, int, uint);
void* malloc(uint);
void free(void*);
int atoi(const char*);

```

**讨论**

在进行修改以前先用`grep -n uptime *.[chS]`这个命令搜索出所有包含uptime系统调用的文件，这样我们就可以仿照uptime系统调用实现date系统调用。

前面我们修改的函数实现了系统调用的处理逻辑，包括参数获取、越界检查和函数调用。它将用户代码的系统调用转发给对应的系统调用函数，并将返回值返回给用户代码。

所以，我们需要将日期系统调用添加到该函数中，即

```
syscall.h
#define SYS_date 22

syscall.c
[SYS_date] "date"
extern int sys_date(void)
[SYS_date]    sys_date,

//这个头文件是给函数和系统调用提供声明
user.h
uint date(struct rtcdate*);
```

后续看这个文档吧，麻了，真的不会啊。为什么打开这些文档就没个说明，提示之类的。printf这个函数原型也没找到，前面要个数字的定义就没搞明白。（知道了，在printf.c中）

跑去看课件去了，这里是抄的。

```
文件usys.S中添加：
SYSCALL(date)

文件sysproc.c中添加：
int sys_date(void) {
    struct rtcdate* r = 0;
    if (argptr(0, (char**)&r, sizeof(*r) < 0)) {
        return -1;
    }
    cmostime(r);
    return 0;
}

新建文件date.c：
#include "types.h"
#include "user.h"
#include "date.h"

int main(int argc, char* argv[]) {
    struct rtcdate r;
    if (date(&r)) {
        printf(2, "date failed\n");
    }
    printf(1, "%d-%d-%d %d:%d:%d\n", r.year, r.month, r.day, r.hour, r.minute, r.second);
    exit();
}
```



## 5.3 Homework: xv6 lazy page allocation

在本练习中，您将向 xv6 添加此延迟分配功能。

### Part One: Eliminate allocation from sbrk()

**任务**

```
你的第一个任务是从sbrk(n)系统调用实现中删除页分配，该实现是sysproc.c中的sys_sbrk()函数。sbrk(n)系统调用将进程的内存大小增加n字节，然后返回新分配区域的“起始位置”(即旧的内存大小)。
新的sbrk(n)应该将进程的大小(proc->sz)增加n并返回旧的大小。它不应该分配内存——所以您应该删除对growproc()的调用(但您仍然需要增加进程的大小!)

猜猜这个修改的结果会是什么:什么会中断?

执行这个修改，启动xv6，然后在shell中输入echo hi。你应该会看到类似下面的内容:

init: starting sh
$ echo hi
pid 3 sh: trap 14 err 6 on cpu 0 eip 0x12f1 addr 0x4004--kill proc
$ 

“pid 3 sh: trap…”消息来自trap.c中的内核trap处理程序;它捕获了一个缺页异常(陷阱14或T_PGFLT)， xv6内核不知道如何处理。一定要理解为什么会发生这个缺页异常。addr 0x4004表示导致页面异常的虚拟地址是0x4004。
```

**回答**

没啥好说的，理解函数以后，重点在于了解`myproc()->sz`在不同要求中是什么地址就行

```
int
sys_sbrk(void)
{
  int addr;
  int n;

  if(argint(0, &n) < 0)
    return -1;
  addr = myproc()->sz;
  
/*  if(growproc(n) < 0)
    return -1;		*/
  myproc()->sz += n;  
  return addr;
}
```



### Part Two: Lazy allocation

**任务**：修复缺页

```
修改trap.c中的代码，响应来自用户空间的缺页异常:将新分配的物理内存页映射到异常地址，然后返回到用户空间，让进程继续执行。您应该将代码添加到产生“pid 3 sh: trap 14”消息的cprintf调用之前。你的代码并不需要覆盖所有的边界情况和错误情况;它只需要足够好，可以让sh运行简单的命令，如echo和ls。

提示:查看cprintf参数，看看如何找到导致缺页异常的虚拟地址。

提示:从vm.c中的allocuvm()中窃取代码，这是sbrk()调用的(通过growproc())。

提示:使用PGROUNDDOWN(va)将发生错误的虚拟地址舍入到页边界。

提示:break或return以避免cprintf和proc->被杀死= 1。

提示:你需要调用mapappages()。为此，需要在vm.c中删除mapappages()声明中的静态变量，还需要在trap.c中声明mapappages()。在trap.c中调用mapappages()之前添加如下声明:
int mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm);

提示:您可以通过在trap()中检查tf->trapno是否等于T_PGFLT来检查故障是否为缺页故障。

如果一切顺利，你的惰性分配代码应该能让echo hi正常工作。在shell中，用户至少会遇到一次缺页异常(也就是延迟分配)，也许还会遇到两次。

顺便说一下，这不是一个完全正确的实现。请参阅下面的挑战，以了解我们已知的问题列表。

可选挑战:处理负的sbrk()参数。处理sbrk()参数过大等错误情况。验证即使某些sbrk()'d地址没有为它们分配内存，fork()和exit()也能工作。正确处理栈下无效页的错误。确保内核对尚未分配的用户地址的使用能够正常工作——例如，如果程序将sbrk()分配的地址传递给read()。
```

**函数**

```
  char *mem = kalloc();
  uint addr = PGROUNDDOWN(rcr2());   
  for(; addr < myproc()->sz; addr += PGSIZE){
      mem = kalloc();
      if(mem == 0){
        cprintf("allocuvm out of memory\n");
        deallocuvm(myproc()->pgdir, myproc()->sz, myproc()->tf->eax);
        return ;
      }    
      memset(mem, 0, PGSIZE);
      if(mappages(myproc()->pgdir, (char *)addr, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
        cprintf("allocuvm out of memory (2)\n");
        deallocuvm(myproc()->pgdir, myproc()->sz, myproc()->tf->eax);
        kfree(mem);
        return ;
      }
    }     
    break;
```

**卡住的点**

1. 执行新页面的建立，即`allocuvm()`的`oldsz`和`newsz`.未充分理解`cprintf`中的变量。
2. 函数位置放错，以为要放到前面检测错误的位置。就是case处，实际上是放到后半输出部分，但是您可以通过在trap()中检查tf->trapno是否等于T_PGFLT来检查故障是否为缺页故障。提示不就没有用了吗？



## 5.4 Homework: xv6 CPU alarm

**目标**：您将为xv6添加一个特性，该特性会在进程使用CPU时间时，周期性地发出警报。

您应该添加一个新的`alarm(interval, handler)`系统调用。如果应用程序调用`alarm(n, fn)`，那么在该程序消耗的CPU时间的每n个“tick”之后，内核将导致应用程序函数fn被调用。当fn返回时，应用程序将从中断的位置恢复。在xv6中，时钟是一个相当随意的时间单位，由硬件定时器产生中断的频率决定。（熟悉的系统调用添加）

这对于计算受限的进程想要限制它们占用的CPU时间，或者想要进行计算但又想采取一些周期性操作的进程可能很有用。更一般地说，你将实现用户级中断/错误处理程序的基本形式;例如，您可以使用类似的东西来处理应用程序中的缺页异常。

你应该将以下示例程序放在`alarmtest.c`中:

```
#include "types.h"
#include "stat.h"
#include "user.h"

void periodic();

int
main(int argc, char *argv[])
{
  int i;
  printf(1, "alarmtest starting\n");
  alarm(10, periodic);
  for(i = 0; i < 25*500000; i++){
    if((i % 250000) == 0)
      write(2, ".", 1);
  }
  exit();
}

void
periodic()
{
  printf(1, "alarm!\n");
}
```

该程序调用`alarm(10, periodic)`，要求内核强制每10个时钟周期调用`periodic()`一次，然后旋转一段时间。在内核中实现`alarm()`系统调用之后，`alarmtest`应该产生如下输出:

```
$ alarmtest
alarmtest starting
.....alarm!
....alarm!
.....alarm!
......alarm!
.....alarm!
....alarm!
....alarm!
......alarm!
.....alarm!
...alarm!
...$ 
```

(如果你只看到一个"alarm!"，请尝试将alarmtest.c的迭代次数增加10倍。)

提示最多的一回，，，

```c
//这几个参考之前的系统调用就行。
//提示:你需要修改Makefile，将alarmtest.c编译为xv6用户程序。
//提示:user.h中正确的声明是:
	int alarm(int ticks, void (*handler)());
//提示:这里有一个免费的sys_alarm()函数:
    int
    sys_alarm(void)
    {
      int ticks;
      void (*handler)();

      if(argint(0, &ticks) < 0)
        return -1;
      if(argptr(1, (char**)&handler, 1) < 0)
        return -1;
      myproc()->alarmticks = ticks;
      myproc()->alarmhandler = handler;
      return 0;
    }

//这里添加的字段struct proc是在proc.h中
//提示:你需要跟踪从上一次调用(或直到下一次调用)到进程的告警处理程序已经传递了多少个时钟周期;为此，你也需要在struct proc中添加一个新字段。你可以在proc.c的allocproc()中初始化proc字段。


//提示:每个时钟周期，硬件时钟都会强制执行一个中断，这在trap()中由case T_IRQ0 + IRQ_TIMER处理;你应该在这里添加一些代码。
//提示:只有在有进程正在运行并且计时器中断来自用户空间的情况下，您才需要操作进程的警报时钟;你想要的是
	if(myproc() != 0 && (tf->cs & 3) == 3) ...	
//提示:在IRQ_TIMER代码中，当进程的警报间隔到期时，您需要使它执行其处理程序。你怎么能这样做呢?
//提示:你需要安排一些事情，以便在处理程序返回时，进程从它离开的地方继续执行。你怎么能这样做呢?

//提示:你可以在alarmtest.asm中看到alarmtest程序的汇编代码。
//提示:如果你告诉qemu只使用一个CPU(可以通过运行来实现)，那么用gdb查看陷阱将更容易
    make CPUS=1 qemu
```

如果你的解决方案在调用处理程序时没有保存调用者保存的用户注册信息，也没有关系。

可选挑战:1)保存和恢复调用处理程序周围的调用方保存的用户注册。2)防止对处理程序的重入调用——如果处理程序还没有返回，不要再次调用它。3)假设你的代码没有检查tf->esp是否有效，实现一个针对内核的安全攻击，利用你的警报处理程序调用代码。

**代码**

添加到系统调用这块就不放了，回顾就看`Homework：xv6 system calls`。

**下面是`proc.h`增加的代码**，用在跟踪从上一次调用(或直到下一次调用)到进程的告警处理程序已经传递了多少个时钟周期。

```
  int alarmticks;	       // store the tick count of the timer
  void (* alarmhandler)();    // Alarm handler
  int curalarmticks;	       // Keeps track of the current number of timer ticks remaining.
```

实现前知道下跟踪步骤。`sys_alarm`的也要声明

```c
//在全局范围内定义一个整型变量，用于存储从上一次调用到进程的告警处理程序已经传递的时钟周期数
int alarmticks = 0；

//然后，在告警处理程序中，在执行相关操作之前，将alarmticks的值加上当前的时钟周期数。
即
void alarmhandler() {
  // 在执行相关操作之前，更新alarmticks的值
  alarmticks += curalarmticks;

  // 执行其他操作...
}
```

**下面是`trap.c`增加的代码**，这块在IRQ_TIMER代码中，当进程的警报间隔到期时，您需要使它执行其处理程序，并在处理程序返回时恢复进程的执行。

这里的警报间隔已经到期指的是经过一定的时间后，警报触发条件满足，需要执行相应的处理程序。

```c
    if(myproc() != 0 && (tf->cs&0x3) == 0x3){  
      myproc()->curalarmticks++;
      if(myproc()->curalarmticks == myproc()->alarmticks){
        myproc()->curalarmticks = 0;
	tf->esp -= 4;    
        *((uint *)tf->esp) = tf->eip;
        tf->eip =(uint) myproc()->alarmhandler;
      }
    }
```

写不出来，只能抄完+理解然后自己敲一遍。判断条件不是很清楚，但是将停止的压入栈，然后恢复进程还是明白了。

**下面是在proc.c中添加的代码**，这块主要是初始化。

```
  p->curalarmticks = 0;
  p->alarmticks = -1;
```

**下面是`alarmtest.c`的复制粘贴的代码**

```
#include "types.h"
#include "stat.h"
#include "user.h"

void periodic();

int
main(int argc, char *argv[])
{
  int i;
  printf(1, "alarmtest starting\n");
  alarm(10, periodic);
  for(i = 0; i < 25*500000; i++){
    if((i % 250000) == 0)
      write(2, ".", 1);
  }
  exit();
}

void
periodic()
{
  printf(1, "alarm!\n");
}
```

最后输出结果数量严重不符合的，可以改变for和if的零就行修改，主要的可能是机子的问题，毕竟不同机子对于sleep这类代码的设置是不一样的。

核心代码是`trap.c`中的代码。



## 5.5 Homework: xv6 Threads and Locking

**目的**

使用哈希表进行线程和锁的并行编程。

**课程内容**

先创建`ph.c`文件，然后编译

```
$ gcc -g -O2 ph.c -pthread
$ ./a.out 2
```

```
//它的输出：我的就不码出来了。
0: put time = 2.871728
1: put time = 2.957073
1: get time = 12.731078
1: 1 keys missing
0: get time = 12.731874
0: 1 keys missing
completion time = 15.689165
```

每个线程运行两个阶段。在第一阶段，每个线程将NKEYS/nthread键放入散列表中。在第二阶段，每个线程从散列表中获取nkey。print语句告诉你每个线程的每个阶段花费了多长时间。底部的完成时间告诉您应用程序的总运行时间。在上面的输出中，应用程序的完成时间大约是16秒。每个线程的计算时间大约为16秒(put约为3秒，get约为13秒)。

为了看看使用两个线程是否能提高性能，让我们与单线程进行比较:

```
$ ./a.out 1
0: put time = 5.350298
0: get time = 11.690395
0: 0 keys missing
completion time = 17.040894
```

单线程情况下的完成时间(约17s)比双线程情况下的完成时间(约15.6s)稍长，但双线程情况在get阶段所做的总工作是2倍。因此，**双线程的情况下，get阶段在两个核心上获得了近2倍的并行加速，这是非常好的。put阶段也实现了一些加速，但并不完美;**两个线程同时插入相同数量的键所需的时间(约2.9秒)是单线程情况(约5.3秒)的一半多一点。

当我们在4核4线程的机器上运行应用程序时:

```
2: put time = 1.516581
1: put time = 1.529754
0: put time = 1.816878
3: put time = 2.113230
2: get time = 15.635937
2: 21 keys missing
3: get time = 15.694796
3: 21 keys missing
1: get time = 15.714341
1: 21 keys missing
0: get time = 15.746386
0: 21 keys missing
completion time = 17.866878
```

有两点:

1)**完成时间和两个线程差不多，但是这次运行的get数量是两个线程的两倍;**我们正在实现良好的并行性。

2)**缺少更多的键。**在您的运行中，可能会有更多或更少的键丢失。在某些运行中甚至可能有0个键丢失。如果你用一个线程运行，永远不会有任何键丢失。为什么缺少2个或更多线程的键，而不是1个线程?识别可能导致两个线程的键丢失的事件序列。

为了避免这种事件序列，可以在put和get中插入lock和unlock语句，使丢失的键的数量始终为0。

```
pthread_mutex_t lock;     // declare a lock
pthread_mutex_init(&lock, NULL);   // initialize the lock
pthread_mutex_lock(&lock);  // acquire lock
pthread_mutex_unlock(&lock);  // release lock
```

```c
//先用一个线程测试你的代码，然后用两个线程测试。它是正确的(即你消除了缺失的键吗?)双线程版本是否比单线程版本更快?
//修改代码，让操作并行执行，同时保持正确性。(提示:这个应用程序的正确性是否需要锁?)
//修改代码，让put操作并行执行，同时保持正确性。(提示:每个桶一个锁有用吗?)
```

**加锁啊，先读代码并且回看一下锁的知识吧**

一个并发的哈希表实现，使用了多线程来进行插入和查找操作。

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <assert.h>
#include <pthread.h>
#include <sys/time.h>

#define SOL
#define NBUCKET 5
#define NKEYS 100000

//struct entry结构体
//    键key
//    值value
//    指向下一个节点的指针next。
struct entry {
  int key;
  int value;
  struct entry *next;
};

//长度为NBUCKET的哈希表数组table,用于存储所有的键值对。
//定义了一个长度为NKEYS的键数组keys，用于存储要插入和查找的键。
struct entry *table[NBUCKET];
int keys[NKEYS];

//线程数nthread
int nthread = 1;
volatile int done;

//now()函数用于获取当前时间。
double
now()
{
 struct timeval tv;
 gettimeofday(&tv, 0);
 return tv.tv_sec + tv.tv_usec / 1000000.0;
}

//print()函数用于打印整个哈希表的内容。
static void
print(void)
{
  int i;
  struct entry *e;
  for (i = 0; i < NBUCKET; i++) {
    printf("%d: ", i);
    for (e = table[i]; e != 0; e = e->next) {
      printf("%d ", e->key);
    }
    printf("\n");
  }
}

//insert()函数用于向哈希表中插入一个键值对。
static void 
insert(int key, int value, struct entry **p, struct entry *n)
{
  struct entry *e = malloc(sizeof(struct entry));
  e->key = key;
  e->value = value;
  e->next = n;
  *p = e;
}

//put()函数用于将一个键值对插入到哈希表中。
static 
void put(int key, int value)
{
  int i = key % NBUCKET;
  insert(key, value, &table[i], table[i]);
}

//get()函数用于根据键查找对应的值。
static struct entry*
get(int key)
{
  struct entry *e = 0;
  for (e = table[key % NBUCKET]; e != 0; e = e->next) {
    if (e->key == key) break;
  }
  return e;
}

//线程函数thread(),每个线程负责插入一部分键值对到哈希表中,在所有线程完成插入后,进行查找操作。
static void *
thread(void *xa)
{
  long n = (long) xa;
  int i;
  int b = NKEYS/nthread;
  int k = 0;
  double t1, t0;

  //  printf("b = %d\n", b);
  t0 = now();
  for (i = 0; i < b; i++) {
    // printf("%d: put %d\n", n, b*n+i);
    put(keys[b*n + i], n);
  }
  t1 = now();
  printf("%ld: put time = %f\n", n, t1-t0);

  // Should use pthread_barrier, but MacOS doesn't support it ...
  __sync_fetch_and_add(&done, 1);
  while (done < nthread) ;

  t0 = now();
  for (i = 0; i < NKEYS; i++) {
    struct entry *e = get(keys[i]);
    if (e == 0) k++;
  }
  t1 = now();
  printf("%ld: get time = %f\n", n, t1-t0);
  printf("%ld: %d keys missing\n", n, k);
  return NULL;
}

//在main()函数中，首先解析命令行参数获取线程数nthread.然后，创建了nthread个线程，并等待所有线程完成。最后，计算并打印整个过程的完成时间。
int
main(int argc, char *argv[])
{
  pthread_t *tha;
  void *value;
  long i;
  double t1, t0;

  if (argc < 2) {
    fprintf(stderr, "%s: %s nthread\n", argv[0], argv[0]);
    exit(-1);
  }
  nthread = atoi(argv[1]);
  tha = malloc(sizeof(pthread_t) * nthread);
  srandom(0);
  assert(NKEYS % nthread == 0);
  for (i = 0; i < NKEYS; i++) {
    keys[i] = random();		//吐槽：哈希表的灵魂
  }
  t0 = now();
  for(i = 0; i < nthread; i++) {
    assert(pthread_create(&tha[i], NULL, thread, (void *) i) == 0);
  }
  for(i = 0; i < nthread; i++) {
    assert(pthread_join(tha[i], &value) == 0);
  }
  t1 = now();
  printf("completion time = %f\n", t1-t0);
}
```

这里是查阅的函数网页

```
assert()
https://www.cnblogs.com/lvchaoshun/p/7816288.html
pthread_create and pthread_join
https://www.cnblogs.com/BlueBlueSea/p/14868229.html
atoi()
https://www.runoob.com/cprogramming/c-function-atoi.html
哈希表(忘了)
https://zhuanlan.zhihu.com/p/95156642

https://www.jianshu.com/p/2f680c14ef58
```

锁在我看来就是为了读写完全使用的，防止出现像A线程正在执行了，突然B线程开始执行，对A造成了影响导致混乱。应该一个线程完成再下一个，这里就要加锁进行阻塞。这个题的一个问题就在于跑哪里加锁。

**加锁**

理解这块函数，需要了解哈希表，这样才能看明白这次的问题。问题在于链表头的更新早了。线程之间发生了覆盖，取出的时候自然就得不到正确的结束

```c
    struct entry *e = get(keys[i]);
    if (e == 0) k++;
```

只要正常插入链表就行。也就是跑完

```
  insert(key, value, &table[i], table[i]);
```

之前，中间不会有新的线程产生就行。

```
pthread_mutex_t lock;     // declare a lock
pthread_mutex_init(&lock, NULL);   // initialize the lock
pthread_mutex_lock(&lock);  // acquire lock
pthread_mutex_unlock(&lock);  // release lock
```

加锁什么的就不多说了，用前文说过的互斥锁就行。

```
2: put time = 1.516581
1: put time = 1.529754
0: put time = 1.816878
3: put time = 2.113230
2: get time = 15.635937
2: 0 keys missing
3: get time = 15.694796
3: 0 keys missing
1: get time = 15.714341
1: 0 keys missing
0: get time = 15.746386
0: 0 keys missing
completion time = 17.866878
```

这样的输出就没问题了。



## 5.6 Homework: xv6 locking

在这个任务中，您将探索中断和锁定之间的一些交互。

### Don't do this

确保您了解如果执行 xv6 内核会发生什么 以下代码片段：

```
  struct spinlock lk;
  initlock(&lk, "test lock");
  acquire(&lk);
  acquire(&lk);
```

在`spinlock.c：acquire`(真抽象，连一块，还是反的，不是复制粘贴还意识不到读的在哪里)

```
//用一句话解释发生了什么:

搞个锁，然后初始化，记录锁的信息，之后让它报错，说明已经持有锁。
```



### Interrupts in ide.c

acquire()函数内部，需要disable 中断，防止自己在申请锁的过程中有其他进程来抢占，造成deadlock。需要观察ide.c中如果申请锁的时候打开中断会怎么样。(启动内核)（打开中断用cli）

让我们看看如果我们在保持ide锁的同时打开中断会发生什么。在ide.c的iderw中，在acquire()之后添加对sti()的调用，在release()之前添加对cli()的调用。（打开和关闭中断）

**要求**

```
//用几句话解释内核为什么会出现恐慌。你可能会发现，查看代码清单中的堆栈跟踪(panic打印的%eip值序列)会很有用
```

**回答**

```
一个个找，分别是:
proc.c		:sched 
proc.c		:yield  
trap.c		:trap 
trapasm.S	:alltraps
bio.c		:bread 
fs.c		:readsb 
fs.c		:iinit 
proc.c		:forkret 
trapasm.S	:trapret

这里可能是导致了死锁了，前面acquire禁用中断就是怕中间发生中断参数死锁。来到第一个报错的函数这里。
是这段代码报错
  if(mycpu()->ncli != 1)
    panic("sched locks");
ncli字段用于跟踪当前CPU上禁用中断的次数。很显然不为1，然后报错了。IDE锁期间发生其他中断的干扰。至于是哪个，或哪几个发生了中断就不好说了。
可能：
	1.sleep(b, &idelock)：当请求尚未完成时，代码通过调用sleep()函数将当前进程休眠，等待请求完成。在某些情况下，可能会有其他中断事件发生，例如定时器中断或外部设备中断，这可能会唤醒休眠的进程。
	2.idestart(b)：如果idequeue中的第一个请求是当前请求b，则调用idestart()函数启动磁盘操作。在启动磁盘操作的过程中，可能会发生磁盘控制器产生的中断事件。
```



### Interrupts in file.c

删除添加的sti()和cli()，重新构建内核，并确保它再次工作。

现在来看一下，如果在持有file_table_lock时打开中断，会发生什么。

该锁保护文件描述符表，内核在应用程序打开或关闭文件时修改该表。在`file.c`的`filealloc()`中，在调用`acquire()`之后添加对`sti()`的调用，并在每个`release()`之前添加一个`cli()`。您还需要在文件的顶部添加`#include "x86.h"`，在其他`#include`行之后。重建内核并在QEMU中引导它。它不会恐慌。

**要求**

```
//用几句话解释为什么内核没有恐慌。为什么file_table_lock和ide_lock在这方面有不同的行为?
//要回答这个问题,需要查看哪些函数获取了每个锁，然后查看这些函数何时被调用，可能会有所帮助。
```

有一个非常小但非零的可能性内核会因为`filealloc()`中额外的`sti()`而出现错误。如果内核确实出现错误，请确保从`iderw`中删除了`sti()`调用。如果它继续恐慌，并且唯一额外的`sti()`在`filealloc()`中

**回答**

```
申请以及释放锁之间的时间太短以至于没有触发定时器。
```

不会，查的，真抽象了。



### xv6 lock implementation

**问题**

```
为什么release()在清除lk->锁定前,要清除lk->pcs[0]和lk->cpu ?为什么不等到以后呢?
```

**回答**

```
这些字段在锁被释放之前被正确清除，以避免在其他进程获取该锁时出现错误的值。
如果等到以后再清除这些字段，可能会导致以下问题：

1.竞态条件：如果在释放锁之后，其他进程立即获取了该锁，那么它们可能会读取到之前持有锁的进程的调用栈和CPU编号。这可能导致错误的结果或调试信息。

2.数据不一致：如果在释放锁之后，其他进程获取了该锁并修改了lk->pcs[0]和lk->cpu的值，那么当再次获取该锁时，这些字段的值就会变得不一致。这可能会导致调试信息的混乱或错误。
```

锁是一种同步机制，通过控制对共享资源的访问来保证数据的一致性和正确性。它可以被实现为一个数据结构，其中包含了用于控制对共享资源访问的状态和操作。



## 5.7 Homework: User-level threads

在这个任务中，您将通过实现在线程之间执行上下文切换的代码来完成一个简单的用户级线程包。

在`“_forktest”`规则后的`“xv6”Makefile`文件中，添加如下规则:

```
_uthread: uthread.o uthread_switch.o
	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _uthread uthread.o uthread_switch.o $(ULIB)
	$(OBJDUMP) -S _uthread > uthread.asm
```

确保每行开头的空格是制表符，而不是空格。

将Makefile中的`_uthread`添加到`UPROGS`定义的用户程序列表中。

运行xv6，然后在xv6 shell中运行uthread。xv6内核会打印一条uthread遇到缺页异常的错误消息。你的工作是完成thread_switch。S，这样你就可以看到类似于下面的输出(确保运行时cpu =1):

```
~/classes/6828/xv6$ make CPUS=1 qemu-nox
dd if=/dev/zero of=xv6.img count=10000
10000+0 records in
10000+0 records out
5120000 bytes transferred in 0.037167 secs (137756344 bytes/sec)
dd if=bootblock of=xv6.img conv=notrunc
1+0 records in
1+0 records out
512 bytes transferred in 0.000026 secs (19701685 bytes/sec)
dd if=kernel of=xv6.img seek=1 conv=notrunc
307+1 records in
307+1 records out
157319 bytes transferred in 0.003590 secs (43820143 bytes/sec)
qemu -nographic -hdb fs.img xv6.img -smp 1 -m 512 
Could not open option rom 'sgabios.bin': No such file or directory
xv6...
cpu0: starting
init: starting sh
$ uthread
my thread running
my thread 0x2A30
my thread running
my thread 0x4A40
my thread 0x2A30
my thread 0x4A40
my thread 0x2A30
my thread 0x4A40
```

**要求**

```c
//1.Uthread创建两个线程并在它们之间来回切换。每个线程都会打印“my thread…”，然后让另一个线程有机会运行。

//2.了解uthread.c如何使用thread_switch.S。
	Uthread.c有两个全局变量current_thread和next_thread。每个都是指向线程结构的指针。线程结构有一个用于线程的栈和一个保存的栈指针(sp，指向线程的栈)。
	uthread_switch的工作是将当前线程状态保存到current_thread指向的结构中，恢复next_thread的状态，并使current_thread指向next_thread所指向的位置，这样，当uthread_switch返回next_thread时，next_thread正在运行，它就是current_thread。
        
//3.你应该学习thread_create，它为新线程设置初始栈。它提供了有关thread_switch应该做什么的提示。其目的是thread_switch使用汇编指令popal和pushal来恢复和保存所有8个x86寄存器。请注意，thread_create在新线程的堆栈上模拟8个压入寄存器(32字节)。  
//4.要在thread_switch中编写程序集，你需要知道C编译器如何在内存中布局struct thread，如下所示:  
    --------------------
    | 4 bytes for state|
    --------------------
    | stack size bytes |
    | for stack        |
    --------------------
    | 4 bytes for sp   |
    --------------------  <--- current_thread
         ......

         ......
    --------------------
    | 4 bytes for state|
    --------------------
    | stack size bytes |
    | for stack        |
    --------------------
    | 4 bytes for sp   |
    --------------------  <--- next_thread
变量next_thread和current_thread分别包含了一个struct线程的地址。        
//5.要写current_thread指向的结构体的sp字段，你应该这样写汇编:     //   movl current_thread, %eax
//   movl %esp, (%eax)   
//在current_thread->sp中节省%esp。这是可行的，因为sp在结构体中的偏移量为0。你可以通过查看uthread.asm来研究编译器为uthread.c生成的程序集。        
        
//6.为了测试代码，使用gdb单步执行thread_switch可能会有所帮助。你可以这样开始: 
(gdb) symbol-file _uthread
Load new symbol table from "/Users/kaashoek/classes/6828/xv6/_uthread"? (y or n) y
Reading symbols from /Users/kaashoek/classes/6828/xv6/_uthread...done.
(gdb) b thread_switch
Breakpoint 1 at 0x204: file uthread_switch.S, line 9.
(gdb)         
//在运行uthread之前，断点可能会被触发(也可能不会)。怎么会这样呢?        
//7.运行xv6 shell后，输入“uthread”，gdb将在thread_switch处中断。现在你可以输入如下命令来检查uthread的状态:        
(gdb) p/x next_thread->sp
$4 = 0x4ae8
(gdb) x/9x next_thread->sp
0x4ae8 :      0x00000000      0x00000000      0x00000000      0x00000000
0x4af8 :      0x00000000      0x00000000      0x00000000      0x00000000
0x4b08 :      0x000000d8       
//位于next_thread栈顶的0xd8是什么地址?          
```

**注释：汇编的**

```c
//从current_thread切换到next_thread。
//将next_thread设置为current_thread，并将next_thread设置为0。
//使用eax作为临时寄存器;它是调用者保存的。
```

**再整理**

```
全局变量:用于线程的栈(stack),保存的栈指针(sp),线程的状态(state)
current_thread;next_thread

uthread_switch的工作是:
1.将当前线程状态保存到current_thread指向的结构中
2.恢复next_thread的状态
3.使current_thread指向next_thread所指向的位置
这样，当uthread_switch返回next_thread时，next_thread正在运行，它就是current_thread。

thread_create提供了有关thread_switch应该做什么的提示:
1.thread_switch使用汇编指令popal和pushal来恢复和保存所有8个x86寄存器。
2.请注意，thread_create在新线程的堆栈上模拟8个压入寄存器(32字节)。 

内存分布:
    --------------------
    | 4 bytes for state|
    --------------------
    | stack size bytes |
    | for stack        |
    --------------------
    | 4 bytes for sp   |
    --------------------  <--- current_thread
         ......

         ......
    --------------------
    | 4 bytes for state|
    --------------------
    | stack size bytes |
    | for stack        |
    --------------------
    | 4 bytes for sp   |
    --------------------  <--- next_thread
    
current_thread指向的结构体的sp字段的书写:
//   movl current_thread, %eax
//   movl %esp, (%eax)  

两个问题:
1.在运行uthread之前，断点可能会被触发(也可能不会)。怎么会这样呢?  
2.位于next_thread栈顶的0xd8是什么地址? 
```

**代码**

```assembly
thread_switch:
	/* YOUR CODE HERE */
	pushal
	movl current_thread, %eax
	movl %esp, (%eax) 
	
	movl next_thread, %eax
	movl (%eax), %esp 
	popal
	
	movl next_thread, %eax
	movl %eax, current_thread
	movl $0x0, next_thread
			
	ret				/* pop return address from stack */
```



## 5.8 Homework: barriers

在这个赋值任务中，我们将探索如何使用`pthread`库提供的条件变量来实现`barrier`。**`barrier`是应用程序中的一个点，所有线程都必须等待，直到所有其他线程也到达该点。**条件变量是一种序列协调技术，类似于`xv6`的`sleep`和`wakeup`。

```
$ gcc -g -O2 -pthread barrier.c
$ ./a.out 2
Assertion failed: (i == t), function thread, file barrier.c, line 55.
```

2指定了在`barrier`上同步的线程数(在`barrier.c`中是`nthread`)。每条线都在一个紧密的循环中。在每次循环迭代中，线程都会调用`barrier()`，然后睡眠若干微秒。assert触发，因为一个线程在另一个线程到达`barrier`之前离开了`barrier`。我们期望的行为是所有线程都应该阻塞，直到有`nthread`调用了`barrier`。

除了之前见过的锁原语之外，还需要以下新的`pthread`原语(更多细节请参阅`man pthreads`):

```c
pthread_cond_wait(&cond, &mutex);  // 进入睡眠状态，释放锁互斥量
pthread_cond_broadcast(&cond);     // 唤醒所有在cond上睡觉的线程
```

`Pthread_cond_wait`在调用时释放互斥量，并在返回之前重新获取互斥量。

我们已经给出了`barrier_init()`。你的工作是实现`barrier()`，防止`panic`发生。我们已经为你定义了`struct barrier`;它的字段供你使用。

有两个问题会使你的任务复杂化。

```
1.
你必须处理一连串的障碍呼叫，每一轮我们称之为一轮.bstate.round记录当前一轮。你应该增加bstate.round每轮开始时。
2.
你必须处理这样的情况，即一个线程在其他线程退出屏障之前就在循环中竞争。特别地，你重用了bstate.nthread从一个轮到下一个轮。确保离开屏障并在循环中竞争的线程不会增加bstate.nthread，而上一轮仍在使用它。
```

没怎么看懂干嘛，先读代码吧。

```
atoi
功能:把字符串转换成整型数。
```

**代码解析**

`main`

```c
int
main(int argc, char *argv[]){
// 声明
	pthread_t *tha;	// 存储线程标识符的数组	
	void *value;	// 存储线程退出时的返回值。
	long i;			// 循环变量
	double t1, t0;	// 变量 t1 和 t0,用于时间测量。

// 确保至少传入一个参数(线程数量 nthread)
	if (argc < 2) {
		fprintf(stderr, "%s: %s nthread\n", argv[0], argv[0]);
		exit(-1);
	}
    
// 命令行参数转换为整数，存储在之前可能定义过的 nthread 变量中;为存储线程标识符的数组分配内存;初始化随机数生成器。
    nthread = atoi(argv[1]);
	tha = malloc(sizeof(pthread_t) * nthread);
	srandom(0);
    barrier_init();

// 将线程的索引传递给线程函数。    
	for(i = 0; i < nthread; i++) {
		assert(pthread_create(&tha[i], NULL, thread, (void *) i) == 0);
	}  
// 调用 pthread_join 函数来等待每个线程的结束，并获取线程的返回值。
    for(i = 0; i < nthread; i++) {
		assert(pthread_join(tha[i], &value) == 0);
	}
    printf("OK; passed\n");
}
```

`thread`

```c
// 线程函数接收一个 void 指针类型的参数 xa，在函数中将其转换为 long 类型的变量 n。
static void *
thread(void *xa){
	long n = (long) xa;
	long delay;
	int i;

	for (i = 0; i < 20000; i++) {
		int t = bstate.round;
		assert (i == t);
		barrier();
		usleep(random() % 100);
  	}
}
```

`barrier`:结构体

```
pthread_mutex_t barrier_mutex:互斥锁，用于保护对barrier状态的访问。
pthread_cond_t barrier_cond:条件变量，用于线程之间的同步。
int nthread:已经到达当前barrier轮次的线程数量。
int round:barrier的轮次。
```

`barrier_init`

```c
static void
barrier_init(void)
{
	assert(pthread_mutex_init(&bstate.barrier_mutex, NULL) == 0);
	assert(pthread_cond_init(&bstate.barrier_cond, NULL) == 0);
	bstate.nthread = 0;
}
// 使用 pthread_mutex_init 和 pthread_cond_init 分别初始化互斥锁和条件变量
// 将 nthread 设置为 0，表示还没有线程到达屏障。
```

`barrier`

```c
// 每次调用 barrier 函数，round 的值会增加，表示屏障的轮次增加了。
static void 
barrier()
{
	bstate.round++;
}
```

**步骤**

要解决问题，你需要在 `barrier()` 函数中实现以下逻辑：

1. 在每个轮次开始时，增加 `bstate.round` 的值。
2. 在 `barrier()` 函数中，使用互斥锁 `bstate.barrier_mutex` 来保护对 `bstate.nthread` 的访问。
3. 在每个线程调用 `barrier()` 函数时，首先获取互斥锁 `bstate.barrier_mutex`。
4. 检查当前轮次是否与线程进入屏障时的轮次相匹配。如果不匹配，说明线程进入屏障时已经开始了新的轮次，此时线程需要等待。
5. 如果当前轮次与线程进入屏障时的轮次相匹配，将 `bstate.nthread` 的值增加 1。
6. 检查 `bstate.nthread` 的值是否等于预期的线程数量。如果等于预期的线程数量，说明所有线程都已经到达屏障，此时可以通过调用 `pthread_cond_broadcast(&bstate.barrier_cond)` 唤醒所有等待的线程。
7. 在等待条件变量前，释放互斥锁 `bstate.barrier_mutex`。
8. 在等待条件变量后，重新获取互斥锁 `bstate.barrier_mutex`。
9. 最后，返回到循环的下一次迭代。

**写代码**

```
static void 
barrier()
{
	pthread_mutex_lock(&bstate.barrier_mutex);
	bstate.nthread++;
	// printf("in round %d as %d\n ",bstate.round, bstate.nthread);
	if(nthread == bstate.nthread){
		bstate.round++;
		bstate.nthread=0;
		pthread_cond_broadcast(&bstate.barrier_cond);
	} else {
		pthread_cond_wait(&bstate.barrier_cond, &bstate.barrier_mutex);	
	}
	pthread_mutex_unlock(&bstate.barrier_mutex);		
}
```

一开始`bstate.round`,`bstate.nthread`,`nthread`是混乱的。

回看一下锁，还是为了安全，但是这就牺牲了像流水线的设计原先要求的效率。这就只能优化，比如优化锁粒度。

**参考**

```
https://blog.csdn.net/a747979985/article/details/99285380
```



## 5.9 Homework: bigger files for xv6

第一个反应：这是什么奇怪的标题

**正文**

**在这个任务中，要增大xv6文件的最大大小。**

当前xv6文件限制为140个扇区，即71680字节。该限制来自于以下事实:一个`xv6 inode`包含12个“直接”块号和一个“单间接”块号，后者表示一个块号最多可容纳128个块号，总共12+128=140。

您可以修改xv6文件系统代码，使其在每个`inode`中支持“双间接”块，其中包含128个单间接块的地址，每个地址最多可以包含128个数据块的地址。结果是，一个文件将能够由多达`16523`个扇区(约8.5 mb)组成。

**首先要做什么**

修改Makefile对cpu的定义，使其内容如下:

```
CPUS := 1
Add
QEMUEXTRA = -snapshot
right before QEMUOPTS
```

当xv6创建大文件时，上述两个步骤极大地提高了qemu的速度。

MKFS将文件系统初始化为少于1000个空闲数据块，太少了，无法显示您将要进行的更改。修改`param.h`，将FSSIZE设置为:

```
#define FSSIZE 20000 //以块为单位的文件系统大小
```

将 [big.c](https://pdos.csail.mit.edu/6.828/2017/homework/big.c) 下载到xv6目录，添加到UPROGS列表中，启动xv6并运行big。它创建一个xv6允许的最大文件，并报告结果的大小。应该是140个扇区。

**其次要看些啥**

磁盘上`inode`的格式由`fs.h`中的`struct dinode`定义。你会对结构体`dinode`的`NDIRECT、NINDIRECT、MAXFILE`和`addr[]`元素特别感兴趣。在 [这里](https://pdos.csail.mit.edu/6.828/2017/homework/inode.pdf) 可以找到标准`xv6 inode`的关系图。

在磁盘上查找文件数据的代码在`fs.c`的`bmap()`中。看一看，确保你明白它在做什么。在读取和写入文件时都会调用`bmap()`。在写入时，`bmap()`会根据需要分配新块来保存文件内容，也会在需要保存块地址时分配一个间接块。

`bmap()`处理两种类型的块号。bn参数是一个“逻辑块”——相对于文件起始位置的块号。`ip->addr[]`中的块号和传给`bread()`的参数都是磁盘块号。您可以将`bmap()`视为将文件的逻辑块号映射到磁盘块号。

**你要干什么**

修改`bmap()`，使其除了实现一个直接块和一个单间接块外，还实现一个双间接块。你只需要11个直接区块，而不是12个，就可以为你的双重间接区块腾出空间;不允许修改磁盘上`inode`的长度。`ip->addr[]`的前11个元素应该是直接块;第12个应该是一个单独的间接块(就像当前的块一样);13号应该是你新的双间接区块。

**提示**

感觉上面就可以归为提示了。上面的修改在`fs.h`

考虑一下如何用逻辑块号索引双间接块及其指向的间接块。

如果你修改了`NDIRECT`的定义，可能就必须修改`file.h`中的`struct inode`中的`addr[]`的长度。确保`struct inode`和`struct inode`的`addr[]`数组中的元素数目相同。

如果修改了`NDIRECT`的定义，请确保创建了一个新的fs。因为`mkfs`也使用`NDIRECT`来构建初始文件系统。如果删除文件系统。img, make在Unix上(不是xv6)会为你构建一个新的。

如果您的文件系统进入一个坏的状态，可能是崩溃，删除fs。img(在Unix中执行，而不是在xv6中)。Make将为您构建一个新的干净的文件系统映像。

不要忘记对`bread()`调用的每个块调用`brelse()`。

用户应该只在需要时分配间接块和双间接块，就像原始的`bmap()`那样。

**代码**

前面的添加工作就参考过去的代码和上面的提示吧，这里只写`bmap()`和两个结构体

`fs.h`

```
#define NDIRECT 11
#define NINDIRECT (BSIZE / sizeof(uint))
//Double indirect block
#define NDINDIRECT (NINDIRECT * NINDIRECT)
#define MAXFILE (NDIRECT + NINDIRECT + NDINDIRECT)

// On-disk inode structure
struct dinode {
  short type;           // File type
  short major;          // Major device number (T_DEV only)
  short minor;          // Minor device number (T_DEV only)
  short nlink;          // Number of links to inode in file system
  uint size;            // Size of file (bytes)
  uint addrs[NDIRECT+2];   // Data block addresses
};
```

`file.h`

```
  uint addrs[NDIRECT+2];
```

`fs.c`

**注释**

```c
// PAGEBREAK !
// Inode内容
//
//与每个inode相关的内容(数据)在磁盘上以块的形式存储。第一个NDIRECT块号在ip->addr[]中列出。
//接下来的NINDIRECT块在block ip->addr [NDIRECT]中列出。

//返回inode ip中第n个块的磁盘块地址
//如果没有，bmap会分配一个。

// 不懂的
// balloc 函数的作用通常是分配一个新的磁盘块，并返回这个块的地址。ip->dev 是一个设备号，可能表示分配磁盘块所在的设备（硬盘、闪存等）。
// bread 作用是从文件系统的特定设备中读取指定地址的数据块，并将数据块内容存储在一个缓冲区中（通过指针变量 bp）。
// brelse 释放之前通过缓冲区指针 bp 引用的缓冲区。
// log_write 将包含数据块内容的缓冲区写入日志系统中，以记录数据的变更或操作。

//理解先去理解前面两段代码以及这次的一个结构，然后进行仿写，索引算是一个最麻烦的一个问题，结局了以后就是cv了。
```

**代码**

```c
static uint
bmap(struct inode *ip, uint bn)
{
  uint addr, *a;
  struct buf *bp;
  struct buf *bp2;

  //Direct block
  if(bn < NDIRECT){
    if((addr = ip->addrs[bn]) == 0)
      ip->addrs[bn] = addr = balloc(ip->dev);
    return addr;
  }
  bn -= NDIRECT;
  
  //First-order indirection block
  if(bn < NINDIRECT){
    // Load indirect block, allocating if necessary.
    if((addr = ip->addrs[NDIRECT]) == 0)
      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
    bp = bread(ip->dev, addr);
    a = (uint*)bp->data;
    if((addr = a[bn]) == 0){
      a[bn] = addr = balloc(ip->dev);
      log_write(bp);
    }
    brelse(bp);
    return addr;
  }
  bn -= NINDIRECT; 
  
  //Second-order indirection block
  if(bn < NDINDIRECT){
    // Load indirect block, allocating if necessary.
    if((addr = ip->addrs[NDIRECT+1]) == 0)
      ip->addrs[NDIRECT+1] = addr = balloc(ip->dev);
      
    bp = bread(ip->dev, addr);
    // First level index
    a = (uint*)bp->data;
    if((addr = a[bn/NINDIRECT]) == 0){
      a[bn/NINDIRECT] = addr = balloc(ip->dev);
      log_write(bp);
    }
    
    bp2 = bread(ip->dev, addr);
    // Secondary page table
    a = (uint*)bp->data;
    if((addr = a[bn%NINDIRECT]) == 0){
      a[bn%NINDIRECT] = addr = balloc(ip->dev);
      log_write(bp2);
    }   
    
    brelse(bp);
    brelse(bp2);
    return addr;
  }
  

  panic("bmap: out of range");
}
```

这输出是打点计时器吗？

**问题**

修改Makefile中的CPUS定义为`CPUS := 1`，并在`QEMUOPTS`之前添加`QEMUEXTRA = -snapshot`。为什么会提高速度？

1. 将CPUS设置为1将限制QEMU虚拟机的运行为单核模式。这意味着QEMU只会使用一个CPU核心来模拟操作系统的执行。在这种情况下，QEMU不会消耗额外的计算资源来模拟多个CPU核心的并行运行，因此可以提高性能。
2. `QEMUEXTRA = -snapshot`选项会启用快照模式。在快照模式下，QEMU会将虚拟机的状态保存在磁盘上的快照文件中。当虚拟机重新启动时，它可以从快照文件中加载状态，而不需要重新执行之前的所有操作。

减少QEMU的计算资源消耗和启动时间

关于间块的一点参考（类似页表的玩意）

```
https://blog.csdn.net/cql08e/article/details/79944012
```

```
http://osdev.foofun.cn/index.php?title=Ext2
```

## 5.10 Homework: xv6 log

### Creating a Problem

`xv6`日志的作用是使文件系统操作的所有磁盘更新都是原子的，从而避免崩溃。例如，创建文件既涉及向目录添加新项，也涉及将新文件的`inode`标记为正在使用。如果一个崩溃发生在一个崩溃之后，但在另一个崩溃之前，那么在重新启动之后，文件系统将处于不正确的状态，如果没有日志记录的话。

**以下步骤将以一种只创建部分文件的方式破坏日志记录代码。**

首先，用以下代码替换`log.c`中的`commit():`

```
#include "mmu.h"
#include "proc.h"
void
commit(void)
{
	int pid = myproc()->pid;
	if (log.lh.n > 0) {
    	write_log();
    	write_head();
   		if(pid > 1)            // AAA
      		log.lh.block[0] = 0; // BBB
    	install_trans();
    	if(pid > 1)            // AAA
      		panic("commit mimicking crash"); // CCC
    	log.lh.n = 0; 
    	write_head();
	}
}
```

BBB行导致日志中的第一个块被写入块0，而不是它应该写入的地方。在文件创建期间，日志中的第一个块是新文件的`inode`，更新为非零类型。行BBB将更新的`inode`所在的块写入到块0(永远不会读取)，而磁盘上的`inode`仍然标记为未分配。CCC线强制崩溃。AAA行消除了`init`的这种错误行为，`init`会在shell启动之前创建文件。

其次，用下面的代码替换`log.c`中的`recover_from_log():`

```
static void
recover_from_log(void)
{
	read_head();      
	cprintf("recovery: n=%d but ignoring\n", log.lh.n);
  	// install_trans();
  	log.lh.n = 0;
  	// write_head();
}
```

此修改禁止了日志恢复(这将修复您对`commit()`的更改所造成的损害)。

最后，从`Makefile`中的`QEMUEXTRA`定义中删除`-snapshot`选项，以便磁盘映像可以看到更改。

现在删除`fs. txt `文件。然后运行xv6:

```
% rm fs.img ; make qemu
```

让`xv6 shell`创建一个文件:

```
$ echo hi > a
```

你应该会看到`commit()`中的`panic`。到目前为止，就好像在非日志系统中创建文件的过程中发生了崩溃。

现在重启xv6，保持原来的`fs.img`:

```
% make qemu
```

看看文件a:

```
$ cat a
```

您应该看到`panic: ilock: no type`。确保你明白发生了什么。哪些文件创建的修改在崩溃之前写入了磁盘，哪些没有?



### Solving the Problem

现在修复`recover_from_log()`:

```
static void
recover_from_log(void){
	read_head();
	cprintf("recovery: n=%d\n", log.lh.n);
	install_trans();
	log.lh.n = 0;
	write_head();
}
```

运行`xv6`(保持不变的`fs.img`)并再次读取a:

```
$ cat a
```

这次应该不会有崩溃。请确保您理解为什么文件系统现在可以工作。

为什么文件是空的，即使你用`echo hi > a`创建它?

现在删除对`commit()`的修改(if和AAA和BBB行)，以便日志记录再次工作，并删除`fs.img`。



### Streamlining Commit

假设文件系统代码要更新第33块中的一个`inode`。文件系统代码将调用`bp=bread`(第33块)并更新缓冲区数据。`commit()`中的`Write_log()`将数据复制到磁盘上日志中的一个块中，例如块3。在`commit`之后，`install_trans()`从日志中读取block 3(包含block 33)，将其内容复制到内存中的block 33缓冲区中，然后将该缓冲区写入磁盘上的block 33。

但是，在`install_trans()`中，可以保证修改后的block 33仍然在文件系统代码留下它的缓冲区缓存中。请确保你理解了为什么在提交之前从缓存中移除33块是一个错误。

因为修改后的区块33保证已经在缓冲区缓存中，所以`install_trans()`不需要从日志中读取区块33。你的工作:修改`log.c`，以便在从`commit()`调用`install_trans()`时，`install_trans()`不会执行从日志中不必要的读取。



**代码**

- 缓冲区, log.lh.block： 定义在log结构体中，OS直接修改的内容
- 物理块： 当OS对某一块的内容进行修改后，缓冲区的内容就会与物理块的内容不同。物理块真正存在于磁盘中。
- log 块, log.start： 记录缓冲区内容的变换，log.start 记录了修改内容的地址。

```c
void
commit(void)
{
	if (log.lh.n > 0) {
    	write_log();
    	write_head();
    	install_trans();
    	log.lh.n = 0; 
    	write_head();
	}
}

static void
install_trans(void)
{
  int tail;

  for (tail = 0; tail < log.lh.n; tail++) {
    //  struct buf *lbuf = bread(log.dev, log.start+tail+1); // read log block
    struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst
    //  memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
    bwrite(dbuf);  // write dst to disk
    //  brelse(lbuf);
    brelse(dbuf);
  }
}
```



## 5.11 Homework: mmap

下载`mmap`作业并仔细查看。该程序在虚拟内存中维护一个非常大的平方根值表。但是，这个表太大了，无法放入物理内存。相反，**平方根值应该在表的地址范围内发生缺页异常时按需计算。你的工作是使用信号处理程序和UNIX内存映射系统调用来实现需求错误机制。**为保持在物理内存限制内，我们建议使用简单的策略，即每当有新页出现错误时，解除对上一页的映射。

要编译`mmap.c`，你需要一个C编译器，例如`gcc`。在`Athena`上，你可以输入:

```
$ add gnu
```

有了gcc之后，就可以像下面这样编译`mmap.c`:

```
$ gcc mmap.c -lm -o mmap
```

它会生成一个`mmap`文件，你可以运行它:

```
$ ./mmap
page_size is 4096
Validating square root table contents...
oops got SIGSEGV at 0x7f6bf7fd7f18
```

在进程访问平方根表时，该映射不存在，内核将控制权传递给`handle_sigsegv()`中的信号处理程序代码。**修改`handle_sigsegv()`中的代码，将一页映射到发生异常的地址，解除前一页的映射以保持在物理内存限制内，并用正确的平方根值初始化新页。使用函数`calculate_sqrts()`来计算这些值。**该程序包含测试逻辑，用于验证平方根表的内容是否正确。成功完成任务后，流程将打印`“All tests passed!”`。

您可能会发现`mmap()`和`munmap()`的手册页是很有帮助的参考资料。

```
$ man mmap
$ man munmap
```

**代码**

写前回去看一下Linux系统编程，`mmap`函数。

```
https://zhuanlan.zhihu.com/p/564344178
```

`handle_sigsegv`

读读前面的代码再写。

```
https://zhuanlan.zhihu.com/p/564344178
```

动态地映射新的内存区域，然后计算一系列平方根，并将结果存储在新映射的内存中。这个过程可以在发生段错误时恢复程序的执行。

```
static void
handle_sigsegv(int sig, siginfo_t *si, void *ctx){
  	// Your code here.

  	// replace these three lines with your implementation
  	static double *square_root;
  	static double *prev;
	uintptr_t fault_addr = (uintptr_t)si->si_addr;
  	munmap(prev, page_size);
  	if (prev!=0&&(munmap(prev, page_size) == -1))
  		exit(EXIT_FAILURE);
  	square_root = (double *)align_down(fault_addr, page_size);
  	square_root = mmap(square_root, page_size, PROT_WRITE, MAP_PRIVATE 
  			| MAP_ANONYMOUS, -1, 0);
  	if (square_root < 0)
  		exit(EXIT_FAILURE);		
  	calculate_sqrts((double *)square_root, (double *)square_root-sqrts, ((int)page_size)/8);
  	prev = square_root;
  	return;	
}
```
















